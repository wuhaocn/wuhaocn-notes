{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/pure/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/alipayimg.png","path":"images/donate/alipayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","path":"images/donate/wechatpayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1622429690000},{"_id":"source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1622429690000},{"_id":"source/categories/index.md","hash":"83ef3fe8852fc9a5b4952a78e9976a9256a309d4","modified":1627206150753},{"_id":"source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1622429690000},{"_id":"source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1622429690000},{"_id":"source/repository/index.md","hash":"1c4523069ab726119bca33648054870f3ee92717","modified":1627205637438},{"_id":"source/_posts/tool/hexo-config.md","hash":"04bbdc57090ab4926bc895304b9547e42fcdf25a","modified":1627205870508},{"_id":"source/docs/tool/hexo-install.md","hash":"fbdefa30beb3e8754ea0d95ced56138220f7b2e1","modified":1627060503000},{"_id":"source/_posts/language/java/深入理解单例模式-静态内部类单例原理.md","hash":"17de90dff8174cfb9426cdf3541e7cb62dad6233","modified":1627205908562},{"_id":"source/_posts/tool/hexo-install.md","hash":"fbdefa30beb3e8754ea0d95ced56138220f7b2e1","modified":1627060503485},{"_id":"source/docs/tool/hexo-config.md","hash":"f51d851b236c0d782dca3c11fe56fda71c7f88e4","modified":1627060503000},{"_id":"source/_posts/algorithm/分布式算法/分布式raft算法.md","hash":"442bffbdb8c977d4b9fa5d4a23afdd268864436e","modified":1627205899458},{"_id":"source/docs/language/java/深入理解单例模式-静态内部类单例原理.md","hash":"17de90dff8174cfb9426cdf3541e7cb62dad6233","modified":1627205908000},{"_id":"source/docs/algorithm/分布式算法/分布式raft算法.md","hash":"442bffbdb8c977d4b9fa5d4a23afdd268864436e","modified":1627205899000},{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1622429690000},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1622429690000},{"_id":"themes/pure/_config.yml","hash":"9f3f24c75a193ee4f4c63122db7b79a3981b9b44","modified":1627205409652},{"_id":"themes/pure/README.cn.md","hash":"069869e32570f32c1f78f75b92559455d1acf213","modified":1627203176383},{"_id":"themes/pure/_config.yml.example","hash":"5289c73c172ce91c4940798bbb3b3d88470a444f","modified":1627203176374},{"_id":"themes/pure/README.md","hash":"cb5632b7aba7eea02147ad738f6d07feb70ead84","modified":1627203176368},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1622429690000},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1622429690000},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1622429690000},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1622429690000},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1622429690000},{"_id":"themes/pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1622429690000},{"_id":"themes/pure/layout/archive.ejs","hash":"ded5d953b35666e30f4c6e48e2d2c62af8d95ebf","modified":1622429690000},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1622429690000},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1622429690000},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1622429690000},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1622429690000},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1622429690000},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1622429690000},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1622429690000},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1622429690000},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1622429690000},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1622429690000},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1622429690000},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1622429690000},{"_id":"themes/pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1622429690000},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/bug_report.md","hash":"83d211c67c12e8c1f6e9f796cfd0cecbf5160e15","modified":1622429690000},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1622429690000},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/custom.md","hash":"84208538d48505ee8e49812cb336eb9882e08dc7","modified":1622429690000},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1622429690000},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1622429690000},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1622429690000},{"_id":"themes/pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1622429690000},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1622429690000},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1622429690000},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1622429690000},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"c02342a354fb10f63f9e3ebd67bb8fb1496c2ce7","modified":1627203176362},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1622429690000},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1622429690000},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1622429690000},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1622429690000},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1622429690000},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"c66c86d6a6a90e00494c380603426fc0f4006311","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"e39dc762d9fe238cede462532e40eaa3d8651122","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1622429690000},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1622429690000},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1622429690000},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1622429690000},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"9f755b0da1ea928dece32c2050d8a04b3a9fb13b","modified":1622429690000},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"46da1ee327b8af107335146bd8fc131eee6c9c4f","modified":1622429690000},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"41a319642da5af07d6cfb8525796aa610b721879","modified":1622429690000},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1622429690000},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"152538ceceb0fdef65c46470ebf0189f7b891c5b","modified":1622429690000},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1622429690000},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1622429690000},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"ee21c4e7ccac26ff2ab6d1d178447fd11fea4d7e","modified":1622429690000},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1622429690000},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1622429690000},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1622429690000},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1622429690000},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"14f2e7d4c1055ff6a5f5867dc0e9a9f6f4c28fe1","modified":1622429690000},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1622429690000},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1622429690000},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1622429690000},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1622429690000},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1622429690000},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1622429690000},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1622429690000},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1622429690000},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1622429690000},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1622429690000},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1622429690000},{"_id":"themes/pure/source/images/avatar.png","hash":"a728ae7e9cdfe0ae85c25c4c024d4eb9a3729afb","modified":1627205308000},{"_id":"themes/pure/source/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1622429690000},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1622429690000},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1622429690000},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1622429690000},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1622429690000},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1622429690000},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1622429690000},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1622429690000},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1622429690000},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"0a99c99992fb1e97bf5a57e05179f5680d69dcc8","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"95eabc0fe4033ec61b240a16eeaf7dc62a9e3da1","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1622429690000},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1622429690000},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1622429690000},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1622429690000},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"fb01f1631c3ae7fe6211dc03233506cb344229be","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1622429690000},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1622429690000},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1622429690000},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1622429690000},{"_id":"themes/pure/source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1622429690000},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1622429690000},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1622429690000},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1622429690000},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1622429690000},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1622429690000},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1622429690000},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1622429690000},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1622429690000},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1622429690000},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1622429690000},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1622429690000},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1622429690000},{"_id":"themes/pure/source/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1622429690000},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1622429690000},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1622429690000},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1622429690000},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1622429690000},{"_id":"public/atom.xml","hash":"58db1b69718bfca7039cadaacaeec02be95f348e","modified":1627206214687},{"_id":"public/baidusitemap.xml","hash":"4cb3d010f8b177afd13a3efaeda795f00a587ffa","modified":1627206214687},{"_id":"public/content.json","hash":"495bcbe6582ff7405f0656303f8c5225fe7978e4","modified":1627206214687},{"_id":"public/sitemap.xml","hash":"1e6378fd70d187a24332a798fad984a2e83d6f30","modified":1627206214687},{"_id":"public/categories/index.html","hash":"1d3a8ec83177ee340b0e2e0f1bca3fab565c6666","modified":1627206214687},{"_id":"public/links/index.html","hash":"2f9eebd8e9bef7ae7fc6b81e0bb7ce325bb72d8b","modified":1627206214687},{"_id":"public/repository/index.html","hash":"3ba702764138b22f3b1a480266aa179a1548bfc9","modified":1627206214687},{"_id":"public/tags/index.html","hash":"a64ed85c991bf4e7daa7b19037b2065f0d171dab","modified":1627206214687},{"_id":"public/archives/index.html","hash":"765b09ab647ed1bdee677ddcbf07110c79ebbf82","modified":1627206214687},{"_id":"public/archives/2021/index.html","hash":"b7a23cb9b763a7e910c163309d97d5298314ab18","modified":1627206214687},{"_id":"public/archives/2021/07/index.html","hash":"bbf5e9c21578236e99f8f4aa067182211ce38cb2","modified":1627206214687},{"_id":"public/index.html","hash":"35df4227c66d8586f1f8480ed812199546164c8e","modified":1627206214687},{"_id":"public/about/index.html","hash":"99bae62403245051331a54ad60418df1bb82462f","modified":1627206214687},{"_id":"public/books/index.html","hash":"f976188d37b3dddefcdbd157998e4cb3c3f1e5c2","modified":1627206214687},{"_id":"public/docs/tool/hexo-config.html","hash":"6438d3618f84ab9e3da39266bc30da7a3e0575f3","modified":1627206214687},{"_id":"public/docs/tool/hexo-install.html","hash":"92c06fc88e229bc9205a4f831e353478a488719e","modified":1627206214687},{"_id":"public/docs/algorithm/分布式算法/分布式raft算法.html","hash":"eb4c2f26a6972511b7e83a321ab41da239aa6c79","modified":1627206214687},{"_id":"public/docs/language/java/深入理解单例模式-静态内部类单例原理.html","hash":"54dff5604b1159cf808501407db0c2f486fd6399","modified":1627206214687},{"_id":"public/2021/07/25/language/java/深入理解单例模式-静态内部类单例原理/index.html","hash":"e11ba2bd5b5f636e5fb173fbc6eb6b90856945ae","modified":1627206214687},{"_id":"public/2021/07/25/algorithm/分布式算法/分布式raft算法/index.html","hash":"4fba76dea97f0567b9d9898cac4a5c1d22d514c4","modified":1627206214687},{"_id":"public/2021/07/25/tool/hexo-config/index.html","hash":"4f0ab0e2cb64491a16a69b9d99400d22082f5472","modified":1627206214687},{"_id":"public/2021/07/24/tool/hexo-install/index.html","hash":"678bc584cbd85c5113751470b81d797f92436529","modified":1627206214687},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1627206214687},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1627206214687},{"_id":"public/images/avatar.png","hash":"a728ae7e9cdfe0ae85c25c4c024d4eb9a3729afb","modified":1627206214687},{"_id":"public/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1627206214687},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1627206214687},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1627206214687},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1627206214687},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1627206214687},{"_id":"public/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1627206214687},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1627206214687},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1627206214687},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1627206214687},{"_id":"public/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1627206214687},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1627206214687},{"_id":"public/fonts/README.html","hash":"3b9daaf126709e3bbce5926e15d599f1fe877921","modified":1627206214687},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1627206214687},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1627206214687},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1627206214687},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1627206214687},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1627206214687},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1627206214687},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1627206214687},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1627206214687},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1627206214687},{"_id":"source/_posts/language/字节码/aspectj使用介绍.md","hash":"dd44e71f2657d1057d55f59e4350953a229eab35","modified":1627722348651},{"_id":"source/_posts/language/字节码/bytebuddy-替换类实现.md","hash":"76194e239f048aab5f8ecec3ec04a0b9d60ea0dc","modified":1627722272011},{"_id":"source/_posts/language/字节码/bytebuddy-code.md","hash":"f4459828f6ed7513507c391569928fd07e84bf38","modified":1627722272015},{"_id":"source/_posts/language/jvm/JVM优秀文章.md","hash":"b776a78f8a5681e06549b8e91e446a2b0a2b6f44","modified":1627722272033},{"_id":"source/_posts/language/字节码/bytebuddy-aop.md","hash":"8ef266a426acb1aec84cdeb354b593ea53ec111d","modified":1627721987000},{"_id":"source/_posts/language/字节码/java字节码增强.md","hash":"84040c9478f1af8dbc3d7634bf1c664ca0ac130e","modified":1627721922320},{"_id":"source/_posts/language/jvm/JVM内存与线程.md","hash":"083520ca32dae8f169246c7dc9d76b6e3fbf739f","modified":1627722272018},{"_id":"source/_posts/language/jvm/JVM内存模型.md","hash":"7d51981d2bec48f77e143618466ccfa319d61620","modified":1627722272026},{"_id":"source/_posts/language/jvm/JVM性能监控及故障分析工具.md","hash":"504d56c904c97cd59d740d461fcc67c1f7711a93","modified":1627722272022},{"_id":"source/_posts/language/jvm/JVM性能调优的6大步骤-关键调优参数详解.md","hash":"80064f33e0bc76b60767036cbb09fd6bce10378d","modified":1627722272004},{"_id":"source/_posts/language/jvm/JVM常见参数设置.md","hash":"dafeab48afad3686ba45e782b6457d301d07a3cb","modified":1627722272040},{"_id":"source/_posts/language/jvm/JVM类加载机制.md","hash":"7cdc3ae4bc1a8e40ed1b74197eeb4c931b205df3","modified":1627722272008},{"_id":"source/_posts/language/jvm/JVM垃圾回收.md","hash":"e28ce4d9ac5e730780cff9f0d638fe7d33668df3","modified":1627722272037},{"_id":"source/_posts/language/jvm/JVM软引用和弱引用.md","hash":"bff398915504a1096bc155af83ff68b9d0e2b8fe","modified":1627722272030}],"Category":[{"name":"java","_id":"ckrrjv2bp0002y2ukhwt65e56"}],"Data":[],"Page":[{"title":"关于","description":"个人简介","layout":"about","comments":0,"sidebar":"custom","_content":"个人详细介绍","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人简介\nlayout: about\ncomments: false\nsidebar: custom\n---\n个人详细介绍","date":"2021-07-25T09:33:21.663Z","updated":"2021-05-31T02:54:50.000Z","path":"about/index.html","_id":"ckrj0kf4a00001tuk5avb9aja","content":"<p>个人详细介绍</p>\n","site":{"data":{}},"excerpt":"","more":"<p>个人详细介绍</p>\n"},{"title":"书单","layout":"books","comments":0,"sidebar":"none","_content":"","source":"books/index.md","raw":"---\ntitle: 书单\nlayout: books\ncomments: false\nsidebar: none\n---","date":"2021-07-25T09:33:21.672Z","updated":"2021-05-31T02:54:50.000Z","path":"books/index.html","_id":"ckrj0kf4e00021tuk4ma42nfz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","layout":"categories","comments":0,"_content":"\n\n# 1.编程语言\n## 1.1.java\n## 1.1.c\n## 1.1.go\n\n# 2.技术中间件\n\n# 3.devops\n\n# 4.算法\n## 4.1.常见算法\n## 4.2.分布式算法\n\n# 5.计算机基础\n\n## 5.1.网络\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\nlayout: categories\ncomments: false\n---\n\n\n# 1.编程语言\n## 1.1.java\n## 1.1.c\n## 1.1.go\n\n# 2.技术中间件\n\n# 3.devops\n\n# 4.算法\n## 4.1.常见算法\n## 4.2.分布式算法\n\n# 5.计算机基础\n\n## 5.1.网络\n\n","date":"2021-07-25T09:42:30.753Z","updated":"2021-07-25T09:42:30.753Z","path":"categories/index.html","_id":"ckrj0kf4g00041tukhzdnaw6p","content":"<h1 id=\"1-编程语言\"><a href=\"#1-编程语言\" class=\"headerlink\" title=\"1.编程语言\"></a>1.编程语言</h1><h2 id=\"1-1-java\"><a href=\"#1-1-java\" class=\"headerlink\" title=\"1.1.java\"></a>1.1.java</h2><h2 id=\"1-1-c\"><a href=\"#1-1-c\" class=\"headerlink\" title=\"1.1.c\"></a>1.1.c</h2><h2 id=\"1-1-go\"><a href=\"#1-1-go\" class=\"headerlink\" title=\"1.1.go\"></a>1.1.go</h2><h1 id=\"2-技术中间件\"><a href=\"#2-技术中间件\" class=\"headerlink\" title=\"2.技术中间件\"></a>2.技术中间件</h1><h1 id=\"3-devops\"><a href=\"#3-devops\" class=\"headerlink\" title=\"3.devops\"></a>3.devops</h1><h1 id=\"4-算法\"><a href=\"#4-算法\" class=\"headerlink\" title=\"4.算法\"></a>4.算法</h1><h2 id=\"4-1-常见算法\"><a href=\"#4-1-常见算法\" class=\"headerlink\" title=\"4.1.常见算法\"></a>4.1.常见算法</h2><h2 id=\"4-2-分布式算法\"><a href=\"#4-2-分布式算法\" class=\"headerlink\" title=\"4.2.分布式算法\"></a>4.2.分布式算法</h2><h1 id=\"5-计算机基础\"><a href=\"#5-计算机基础\" class=\"headerlink\" title=\"5.计算机基础\"></a>5.计算机基础</h1><h2 id=\"5-1-网络\"><a href=\"#5-1-网络\" class=\"headerlink\" title=\"5.1.网络\"></a>5.1.网络</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-编程语言\"><a href=\"#1-编程语言\" class=\"headerlink\" title=\"1.编程语言\"></a>1.编程语言</h1><h2 id=\"1-1-java\"><a href=\"#1-1-java\" class=\"headerlink\" title=\"1.1.java\"></a>1.1.java</h2><h2 id=\"1-1-c\"><a href=\"#1-1-c\" class=\"headerlink\" title=\"1.1.c\"></a>1.1.c</h2><h2 id=\"1-1-go\"><a href=\"#1-1-go\" class=\"headerlink\" title=\"1.1.go\"></a>1.1.go</h2><h1 id=\"2-技术中间件\"><a href=\"#2-技术中间件\" class=\"headerlink\" title=\"2.技术中间件\"></a>2.技术中间件</h1><h1 id=\"3-devops\"><a href=\"#3-devops\" class=\"headerlink\" title=\"3.devops\"></a>3.devops</h1><h1 id=\"4-算法\"><a href=\"#4-算法\" class=\"headerlink\" title=\"4.算法\"></a>4.算法</h1><h2 id=\"4-1-常见算法\"><a href=\"#4-1-常见算法\" class=\"headerlink\" title=\"4.1.常见算法\"></a>4.1.常见算法</h2><h2 id=\"4-2-分布式算法\"><a href=\"#4-2-分布式算法\" class=\"headerlink\" title=\"4.2.分布式算法\"></a>4.2.分布式算法</h2><h1 id=\"5-计算机基础\"><a href=\"#5-计算机基础\" class=\"headerlink\" title=\"5.计算机基础\"></a>5.计算机基础</h1><h2 id=\"5-1-网络\"><a href=\"#5-1-网络\" class=\"headerlink\" title=\"5.1.网络\"></a>5.1.网络</h2>"},{"title":"友情链接","layout":"links","comments":1,"sidebar":"none","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\nlayout: links\ncomments: true\nsidebar: none\n---","date":"2021-07-25T09:33:21.690Z","updated":"2021-05-31T02:54:50.000Z","path":"links/index.html","_id":"ckrj0kf4i00061tuk2qpx5yxa","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"git仓库","layout":"repository","comments":0,"sidebar":"none","_content":"","source":"repository/index.md","raw":"---\ntitle: git仓库\nlayout: repository\ncomments: false\nsidebar: none\n---\n","date":"2021-07-25T09:33:57.438Z","updated":"2021-07-25T09:33:57.438Z","path":"repository/index.html","_id":"ckrj0kf4j00081tukgr5he703","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2021-07-25T09:33:21.712Z","updated":"2021-05-31T02:54:50.000Z","path":"tags/index.html","_id":"ckrj0kf4j00091tuk1vk9ax82","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"hexo配置详解","_content":"hexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","source":"docs/tool/hexo-config.md","raw":"---\ntitle: hexo配置详解\n---\nhexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","date":"2021-07-25T09:36:08.821Z","updated":"2021-07-23T17:15:03.000Z","path":"docs/tool/hexo-config.html","comments":1,"layout":"page","_id":"ckrj0kf4k000a1tukeywa9tql","content":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>"},{"title":"hexo-安装","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"docs/tool/hexo-install.md","raw":"---\ntitle: hexo-安装\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","date":"2021-07-25T09:36:08.825Z","updated":"2021-07-23T17:15:03.000Z","path":"docs/tool/hexo-install.html","comments":1,"layout":"page","_id":"ckrj0kf4l000b1tukeroa5n4k","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"分布式算法-raft","_content":"\nraft算法介绍\n\n### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","source":"docs/algorithm/分布式算法/分布式raft算法.md","raw":"---\ntitle: 分布式算法-raft\n---\n\nraft算法介绍\n\n### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","date":"2021-07-25T09:38:51.722Z","updated":"2021-07-25T09:38:19.000Z","path":"docs/algorithm/分布式算法/分布式raft算法.html","comments":1,"layout":"page","_id":"ckrj0kf4l000c1tuk1qg91r9d","content":"<p>raft算法介绍</p>\n<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>raft算法介绍</p>\n<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n"},{"title":"单例模式-静态内部类单例原理","_content":"\nraft算法介绍\n\n\n# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","source":"docs/language/java/深入理解单例模式-静态内部类单例原理.md","raw":"---\ntitle: 单例模式-静态内部类单例原理\n---\n\nraft算法介绍\n\n\n# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","date":"2021-07-25T09:39:03.820Z","updated":"2021-07-25T09:38:28.000Z","path":"docs/language/java/深入理解单例模式-静态内部类单例原理.html","comments":1,"layout":"page","_id":"ckrj0kf4l000d1tukeimx17pi","content":"<p>raft算法介绍</p>\n<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>raft算法介绍</p>\n<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n"}],"Post":[{"title":"hexo-配置","_content":"hexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","source":"_posts/tool/hexo-config.md","raw":"---\ntitle: hexo-配置\n---\nhexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","slug":"tool/hexo-config","published":1,"date":"2021-07-25T09:37:50.508Z","updated":"2021-07-25T09:37:50.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrj0kf4c00011tukcy00463w","content":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>"},{"title":"hexo-安装","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/tool/hexo-install.md","raw":"---\ntitle: hexo-安装\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"tool/hexo-install","published":1,"date":"2021-07-23T17:15:03.485Z","updated":"2021-07-23T17:15:03.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrj0kf4e00031tuk8vt13jbw","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"单例模式-静态内部类单例原理","_content":"\nraft算法介绍\n\n\n# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","source":"_posts/language/java/深入理解单例模式-静态内部类单例原理.md","raw":"---\ntitle: 单例模式-静态内部类单例原理\n---\n\nraft算法介绍\n\n\n# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","slug":"language/java/深入理解单例模式-静态内部类单例原理","published":1,"date":"2021-07-25T09:38:28.562Z","updated":"2021-07-25T09:38:28.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrj0kf4g00051tuk7bd7gyg7","content":"<p>raft算法介绍</p>\n<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>raft算法介绍</p>\n<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n"},{"title":"分布式算法-raft","_content":"\nraft算法介绍\n\n### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","source":"_posts/algorithm/分布式算法/分布式raft算法.md","raw":"---\ntitle: 分布式算法-raft\n---\n\nraft算法介绍\n\n### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","slug":"algorithm/分布式算法/分布式raft算法","published":1,"date":"2021-07-25T09:38:19.458Z","updated":"2021-07-25T09:38:19.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrj0kf4i00071tukfeeohnuu","content":"<p>raft算法介绍</p>\n<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>raft算法介绍</p>\n<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n"},{"title":"AspectJ使用介绍","_content":"\n## 1.AspectJ 使用介绍\n\nAspectJ 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为\n* compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件\n* post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法\n* load-time：在 JVM 进行类加载的时候进行织入\n\n### 1.1 编译插桩分类\n\n编译插桩技术具体可以分为两类，如下所示：\n* 1）、APT（Annotation Process Tools） ：用于生成 Java 代码。\n* 2）、AOP（Aspect Oriented Programming）：用于操作字节码。\n\n我们分别来详细介绍下它们的作用。\n\n* 1、APT（Annotation Process Tools）\n  总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。 \n  而 使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。\n  但是 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。\n  使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：\n\n  1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。\n  2）、大大减少了手工重复的工作量，降低了开发时出错的机率。\n\n*  2、AOP（Aspect Oriented Programming）\n   而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。\n   相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：\n\n    1）、应用场景更广。\n    2）、功能更加强大。\n    3）、使用复杂度较高。\n   \n## 2.依赖引入\n以gradle依赖为例\n\n```\nbuildscript {\n  repositories {\n    mavenLocal()\n    maven { url 'https://plugins.gradle.org/m2/' }\n\n  }\n  dependencies {\n    classpath group: 'io.freefair.gradle', name: 'aspectj-plugin', version: '5.3.3.3'\n\n  }\n}\napply plugin: \"io.freefair.aspectj\"\n\n\ndependencies {\n  compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.5'\n  compile group: 'org.aspectj', name: 'aspectjrt', version: '1.9.5'\n \n}\n\n\n```\n\n* aspectj底层依赖库\n    * net.bytebuddy:byte-buddy\n\n## 3.代码编写\n\n* 代码地址请参考：https://github.com/wuhaocn/jcode-simple.git\n\n* 注意下面操作类应放在\"src/main/aspectj\"包下面\n\n### 3.1.定义业务类\n* Account.java\n```\npublic class Account {\n\n    public int balance = 20;\n\n    public boolean pay(int amount) {\n        if (balance < amount) {\n            return false;\n        }\n        balance -= amount;\n        return true;\n    }\n}\n```\n### 3.2.定义注解类\n* AccountAspect.aj\n```\npublic aspect AccountAspect {\n\n    pointcut callPay(int amount, Account account):\n            call(boolean com.rcloud.Account.pay(int)) && args(amount) && target(account);\n\n    before(int amount, Account account): callPay(amount, account) {\n        System.out.println(\"[AccountAspect]付款前总金额: \" + account.balance);\n        System.out.println(\"[AccountAspect]需要付款: \" + amount);\n    }\n\n    boolean around(int amount, Account account): callPay(amount, account) {\n        if (account.balance < amount) {\n            System.out.println(\"[AccountAspect]拒绝付款!\");\n            return false;\n        }\n        return proceed(amount, account);\n    }\n\n    after(int amount, Account balance): callPay(amount, balance) {\n        System.out.println(\"[AccountAspect]付款后，剩余：\" + balance.balance);\n    }\n\n}\n```\n### 3.3.使用类\n* AccountDoWork.java\n```\npublic class AccountDoWork {\n    public static void pay() {\n        Account account = new Account();\n        account.pay(1);\n    }\n}\n\n```\n## 4.AspectJ 的优势与局限性\n最常用的字节码处理框架有 AspectJ、ASM 等等，它们的相同之处在于输入输出都是 Class 文件。\n并且，它们都是 在 Java 文件编译成 .class 文件之后，生成 Dalvik 字节码之前执行。\n而 AspectJ 作为 Java 中流行的 AOP（aspect-oriented programming） 编程扩展框架，\n其内部使用的是 BCEL框架 来完成其功能。下面，我们就来了解下 AspectJ 具备哪些优势。\n### 4.1.AspectJ 的优势\n   它的优势有两点：成熟稳定、使用非常简单。\n* 1、成熟稳定\n字节码的处理并不简单，特别是 针对于字节码的格式和各种指令规则，如果处理出错，\n就会导致程序编译或者运行过程中出现问题。而 AspectJ 作为从 2001 年发展至今的框架，\n它已经发展地非常成熟，通常不用考虑插入的字节码发生正确性相关的问题。\n* 2、使用非常简单\nAspectJ 的使用非常简单，并且它的功能非常强大，我们完全不需要理解任何 Java 字节码相关的知识，\n就可以在很多情况下对字节码进行操控。例如，它可以在如下五个位置插入自定义的代码：\n1）、在方法（包括构造方法）被调用的位置。\n2）、在方法体（包括构造方法）的内部。\n3）、在读写变量的位置。\n4）、在静态代码块内部。\n5）、在异常处理的位置的前后。\n此外，它也可以 直接将原位置的代码替换为自定义的代码。\n\n### 4.2.AspectJ 的缺陷\n而 AspectJ 的缺点可以归结为如下 三点：\n* 1、切入点固定\nAspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则很难实现，它\n无法针对一些特定规则的字节码序列做操作。\n* 2、正则表达式的局限性\nAspectJ 的匹配规则采用了类似正则表达式的规则，比如 匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到，这样匹配的正确性就无法满足。\n* 3、性能较低\nAspectJ 在实现时会包装自己一些特定的类，它并不会直接把 Trace 函数直接插入到代码中，而是经过一系列自己的封装。这样不仅生成的字节码比较大，而且对原函数的性能会有不小的影响。如果想对 App 中所有的函数都进行插桩，性能影响肯定会比较大。如果你只插桩一小部分函数，那么 AspectJ 带来的性能损耗几乎可以忽略不计。\n## 5.AspectJ 核心语法简介\nAspectJ 其实就是一种 AOP 框架，AOP 是实现程序功能统一维护的一种技术。\n利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，\n提高程序的可重用性，同时大大提高了开发效率。因此 AOP 的优势可总结为如下 两点：\n\n1）、无侵入性。\n2）、修改方便。\n\n此外，AOP 不同于 OOP 将问题划分到单个模块之中，它把 涉及到众多模块的同一类问题进行了统一处理。\n比如我们可以设计两个切面，一个是用于处理 App 中所有模块的日志输出功能，\n另外一个则是用于处理 App 中一些特殊函数调用的权限检查。\n下面👇，我们就来看看要掌握 AspectJ 的使用，我们需要了解的一些 核心概念。\n* 1、横切关注点\n对哪些方法进行拦截，拦截后怎么处理。\n* 2、切面（Aspect）\n类是对物体特征的抽象，切面就是对横切关注点的抽象。\n* 3、连接点（JoinPoint）\nJPoint 是一个程序的关键执行点，也是我们关注的重点。\n  它就是指被拦截到的点（如方法、字段、构造器等等）。\n* 4、切入点（PointCut）\n对 JoinPoint 进行拦截的定义。\nPointCut 的目的就是提供一种方法使得开发者能够选择自己感兴趣的 JoinPoint。\n* 5、通知（Advice）\n切入点仅用于捕捉连接点集合，但是，除了捕捉连接点集合以外什么事情都没有做。 \n事实上实现横切行为我们要使用通知。\n它 一般指拦截到 JoinPoint 后要执行的代码，分为 前置、后置、环绕 三种类型。\n这里，我们需要 注意 Advice Precedence（优先权） 的情况，\n比如我们对同一个切面方法同时使用了 @Before 和 @Around 时就会报错，\n此时会提示需要设置 Advice 的优先级。\nAspectJ 作为一种基于 Java 语言实现的一套面向切面程序设计规范。\n它向 Java 中加入了 连接点(Join Point) 这个新概念 ，\n其实它也只是现存的一个 Java 概 念的名称而已。它向 Java 语言中加入了少许新结构，\n譬如 切入点(pointcut)、通知(Advice)、类型间声明(Inter-type declaration) 和 切面(Aspect)。切入点和通知动态地影响程序流程，\n类型间声明则是静态的影响程序的类等级结构，而切面则是对所有这些新结构的封装。\n对于 AsepctJ 中的各个核心概念来说，其 连接点就恰如程序流中适当的一点。\n而切入点收集特定的连接点集合和在这些点中的值。\n一个通知则是当一个连接点到达时执行的代码，这些都是 AspectJ 的动态部分。\n其实连接点就好比是 程序中那一条一条的语句，\n而切入点就是特定一条语句处设置的一个断点，它收集了断点处程序栈的信息，\n而通知就是在这个断点前后想要加入的程序代码。\n此外，AspectJ 中也有许多不同种类的类型间声明，\n这就允许程序员修改程序的静态结构、名称、类的成员以及类之间的关系。 \nAspectJ 中的切面是横切关注点的模块单元。它们的行为与 Java 语言中的类很象，\n但是切面 还封装了切入点、通知以及类型间声明。\n\n\n## 6.小结\nAspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，\n需要专门找运维人员配置。 在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。\n大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。\n\n## 7.参考\n\nhttps://javadoop.com/post/aspectj\nhttps://juejin.cn/post/6844904112396615688\n\n","source":"_posts/language/字节码/aspectj使用介绍.md","raw":"---\ntitle: AspectJ使用介绍\ncategories:\n- java\n---\n\n## 1.AspectJ 使用介绍\n\nAspectJ 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为\n* compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件\n* post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法\n* load-time：在 JVM 进行类加载的时候进行织入\n\n### 1.1 编译插桩分类\n\n编译插桩技术具体可以分为两类，如下所示：\n* 1）、APT（Annotation Process Tools） ：用于生成 Java 代码。\n* 2）、AOP（Aspect Oriented Programming）：用于操作字节码。\n\n我们分别来详细介绍下它们的作用。\n\n* 1、APT（Annotation Process Tools）\n  总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。 \n  而 使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。\n  但是 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。\n  使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：\n\n  1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。\n  2）、大大减少了手工重复的工作量，降低了开发时出错的机率。\n\n*  2、AOP（Aspect Oriented Programming）\n   而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。\n   相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：\n\n    1）、应用场景更广。\n    2）、功能更加强大。\n    3）、使用复杂度较高。\n   \n## 2.依赖引入\n以gradle依赖为例\n\n```\nbuildscript {\n  repositories {\n    mavenLocal()\n    maven { url 'https://plugins.gradle.org/m2/' }\n\n  }\n  dependencies {\n    classpath group: 'io.freefair.gradle', name: 'aspectj-plugin', version: '5.3.3.3'\n\n  }\n}\napply plugin: \"io.freefair.aspectj\"\n\n\ndependencies {\n  compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.5'\n  compile group: 'org.aspectj', name: 'aspectjrt', version: '1.9.5'\n \n}\n\n\n```\n\n* aspectj底层依赖库\n    * net.bytebuddy:byte-buddy\n\n## 3.代码编写\n\n* 代码地址请参考：https://github.com/wuhaocn/jcode-simple.git\n\n* 注意下面操作类应放在\"src/main/aspectj\"包下面\n\n### 3.1.定义业务类\n* Account.java\n```\npublic class Account {\n\n    public int balance = 20;\n\n    public boolean pay(int amount) {\n        if (balance < amount) {\n            return false;\n        }\n        balance -= amount;\n        return true;\n    }\n}\n```\n### 3.2.定义注解类\n* AccountAspect.aj\n```\npublic aspect AccountAspect {\n\n    pointcut callPay(int amount, Account account):\n            call(boolean com.rcloud.Account.pay(int)) && args(amount) && target(account);\n\n    before(int amount, Account account): callPay(amount, account) {\n        System.out.println(\"[AccountAspect]付款前总金额: \" + account.balance);\n        System.out.println(\"[AccountAspect]需要付款: \" + amount);\n    }\n\n    boolean around(int amount, Account account): callPay(amount, account) {\n        if (account.balance < amount) {\n            System.out.println(\"[AccountAspect]拒绝付款!\");\n            return false;\n        }\n        return proceed(amount, account);\n    }\n\n    after(int amount, Account balance): callPay(amount, balance) {\n        System.out.println(\"[AccountAspect]付款后，剩余：\" + balance.balance);\n    }\n\n}\n```\n### 3.3.使用类\n* AccountDoWork.java\n```\npublic class AccountDoWork {\n    public static void pay() {\n        Account account = new Account();\n        account.pay(1);\n    }\n}\n\n```\n## 4.AspectJ 的优势与局限性\n最常用的字节码处理框架有 AspectJ、ASM 等等，它们的相同之处在于输入输出都是 Class 文件。\n并且，它们都是 在 Java 文件编译成 .class 文件之后，生成 Dalvik 字节码之前执行。\n而 AspectJ 作为 Java 中流行的 AOP（aspect-oriented programming） 编程扩展框架，\n其内部使用的是 BCEL框架 来完成其功能。下面，我们就来了解下 AspectJ 具备哪些优势。\n### 4.1.AspectJ 的优势\n   它的优势有两点：成熟稳定、使用非常简单。\n* 1、成熟稳定\n字节码的处理并不简单，特别是 针对于字节码的格式和各种指令规则，如果处理出错，\n就会导致程序编译或者运行过程中出现问题。而 AspectJ 作为从 2001 年发展至今的框架，\n它已经发展地非常成熟，通常不用考虑插入的字节码发生正确性相关的问题。\n* 2、使用非常简单\nAspectJ 的使用非常简单，并且它的功能非常强大，我们完全不需要理解任何 Java 字节码相关的知识，\n就可以在很多情况下对字节码进行操控。例如，它可以在如下五个位置插入自定义的代码：\n1）、在方法（包括构造方法）被调用的位置。\n2）、在方法体（包括构造方法）的内部。\n3）、在读写变量的位置。\n4）、在静态代码块内部。\n5）、在异常处理的位置的前后。\n此外，它也可以 直接将原位置的代码替换为自定义的代码。\n\n### 4.2.AspectJ 的缺陷\n而 AspectJ 的缺点可以归结为如下 三点：\n* 1、切入点固定\nAspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则很难实现，它\n无法针对一些特定规则的字节码序列做操作。\n* 2、正则表达式的局限性\nAspectJ 的匹配规则采用了类似正则表达式的规则，比如 匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到，这样匹配的正确性就无法满足。\n* 3、性能较低\nAspectJ 在实现时会包装自己一些特定的类，它并不会直接把 Trace 函数直接插入到代码中，而是经过一系列自己的封装。这样不仅生成的字节码比较大，而且对原函数的性能会有不小的影响。如果想对 App 中所有的函数都进行插桩，性能影响肯定会比较大。如果你只插桩一小部分函数，那么 AspectJ 带来的性能损耗几乎可以忽略不计。\n## 5.AspectJ 核心语法简介\nAspectJ 其实就是一种 AOP 框架，AOP 是实现程序功能统一维护的一种技术。\n利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，\n提高程序的可重用性，同时大大提高了开发效率。因此 AOP 的优势可总结为如下 两点：\n\n1）、无侵入性。\n2）、修改方便。\n\n此外，AOP 不同于 OOP 将问题划分到单个模块之中，它把 涉及到众多模块的同一类问题进行了统一处理。\n比如我们可以设计两个切面，一个是用于处理 App 中所有模块的日志输出功能，\n另外一个则是用于处理 App 中一些特殊函数调用的权限检查。\n下面👇，我们就来看看要掌握 AspectJ 的使用，我们需要了解的一些 核心概念。\n* 1、横切关注点\n对哪些方法进行拦截，拦截后怎么处理。\n* 2、切面（Aspect）\n类是对物体特征的抽象，切面就是对横切关注点的抽象。\n* 3、连接点（JoinPoint）\nJPoint 是一个程序的关键执行点，也是我们关注的重点。\n  它就是指被拦截到的点（如方法、字段、构造器等等）。\n* 4、切入点（PointCut）\n对 JoinPoint 进行拦截的定义。\nPointCut 的目的就是提供一种方法使得开发者能够选择自己感兴趣的 JoinPoint。\n* 5、通知（Advice）\n切入点仅用于捕捉连接点集合，但是，除了捕捉连接点集合以外什么事情都没有做。 \n事实上实现横切行为我们要使用通知。\n它 一般指拦截到 JoinPoint 后要执行的代码，分为 前置、后置、环绕 三种类型。\n这里，我们需要 注意 Advice Precedence（优先权） 的情况，\n比如我们对同一个切面方法同时使用了 @Before 和 @Around 时就会报错，\n此时会提示需要设置 Advice 的优先级。\nAspectJ 作为一种基于 Java 语言实现的一套面向切面程序设计规范。\n它向 Java 中加入了 连接点(Join Point) 这个新概念 ，\n其实它也只是现存的一个 Java 概 念的名称而已。它向 Java 语言中加入了少许新结构，\n譬如 切入点(pointcut)、通知(Advice)、类型间声明(Inter-type declaration) 和 切面(Aspect)。切入点和通知动态地影响程序流程，\n类型间声明则是静态的影响程序的类等级结构，而切面则是对所有这些新结构的封装。\n对于 AsepctJ 中的各个核心概念来说，其 连接点就恰如程序流中适当的一点。\n而切入点收集特定的连接点集合和在这些点中的值。\n一个通知则是当一个连接点到达时执行的代码，这些都是 AspectJ 的动态部分。\n其实连接点就好比是 程序中那一条一条的语句，\n而切入点就是特定一条语句处设置的一个断点，它收集了断点处程序栈的信息，\n而通知就是在这个断点前后想要加入的程序代码。\n此外，AspectJ 中也有许多不同种类的类型间声明，\n这就允许程序员修改程序的静态结构、名称、类的成员以及类之间的关系。 \nAspectJ 中的切面是横切关注点的模块单元。它们的行为与 Java 语言中的类很象，\n但是切面 还封装了切入点、通知以及类型间声明。\n\n\n## 6.小结\nAspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，\n需要专门找运维人员配置。 在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。\n大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。\n\n## 7.参考\n\nhttps://javadoop.com/post/aspectj\nhttps://juejin.cn/post/6844904112396615688\n\n","slug":"language/字节码/aspectj使用介绍","published":1,"date":"2021-07-31T09:05:48.651Z","updated":"2021-07-31T09:05:48.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bf0000y2ukdhi0ev7m","content":"<h2 id=\"1-AspectJ-使用介绍\"><a href=\"#1-AspectJ-使用介绍\" class=\"headerlink\" title=\"1.AspectJ 使用介绍\"></a>1.AspectJ 使用介绍</h2><p>AspectJ 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为</p>\n<ul>\n<li>compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件</li>\n<li>post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法</li>\n<li>load-time：在 JVM 进行类加载的时候进行织入</li>\n</ul>\n<h3 id=\"1-1-编译插桩分类\"><a href=\"#1-1-编译插桩分类\" class=\"headerlink\" title=\"1.1 编译插桩分类\"></a>1.1 编译插桩分类</h3><p>编译插桩技术具体可以分为两类，如下所示：</p>\n<ul>\n<li>1）、APT（Annotation Process Tools） ：用于生成 Java 代码。</li>\n<li>2）、AOP（Aspect Oriented Programming）：用于操作字节码。</li>\n</ul>\n<p>我们分别来详细介绍下它们的作用。</p>\n<ul>\n<li><p>1、APT（Annotation Process Tools）<br>总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。<br>而 使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。<br>但是 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。<br>使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：</p>\n<p>1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。<br>2）、大大减少了手工重复的工作量，降低了开发时出错的机率。</p>\n</li>\n<li><p>2、AOP（Aspect Oriented Programming）<br> 而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。<br> 相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：</p>\n<p>  1）、应用场景更广。<br>  2）、功能更加强大。<br>  3）、使用复杂度较高。</p>\n</li>\n</ul>\n<h2 id=\"2-依赖引入\"><a href=\"#2-依赖引入\" class=\"headerlink\" title=\"2.依赖引入\"></a>2.依赖引入</h2><p>以gradle依赖为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    maven &#123; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dependencies &#123;</span><br><span class=\"line\">    classpath group: &#x27;io.freefair.gradle&#x27;, name: &#x27;aspectj-plugin&#x27;, version: &#x27;5.3.3.3&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apply plugin: &quot;io.freefair.aspectj&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjweaver&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class=\"line\">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjrt&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>aspectj底层依赖库<ul>\n<li>net.bytebuddy:byte-buddy</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-代码编写\"><a href=\"#3-代码编写\" class=\"headerlink\" title=\"3.代码编写\"></a>3.代码编写</h2><ul>\n<li><p>代码地址请参考：<a href=\"https://github.com/wuhaocn/jcode-simple.git\">https://github.com/wuhaocn/jcode-simple.git</a></p>\n</li>\n<li><p>注意下面操作类应放在”src/main/aspectj”包下面</p>\n</li>\n</ul>\n<h3 id=\"3-1-定义业务类\"><a href=\"#3-1-定义业务类\" class=\"headerlink\" title=\"3.1.定义业务类\"></a>3.1.定义业务类</h3><ul>\n<li>Account.java<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Account &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int balance = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean pay(int amount) &#123;</span><br><span class=\"line\">        if (balance &lt; amount) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        balance -= amount;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-定义注解类\"><a href=\"#3-2-定义注解类\" class=\"headerlink\" title=\"3.2.定义注解类\"></a>3.2.定义注解类</h3></li>\n<li>AccountAspect.aj<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public aspect AccountAspect &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    pointcut callPay(int amount, Account account):</span><br><span class=\"line\">            call(boolean com.rcloud.Account.pay(int)) &amp;&amp; args(amount) &amp;&amp; target(account);</span><br><span class=\"line\"></span><br><span class=\"line\">    before(int amount, Account account): callPay(amount, account) &#123;</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]付款前总金额: &quot; + account.balance);</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]需要付款: &quot; + amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean around(int amount, Account account): callPay(amount, account) &#123;</span><br><span class=\"line\">        if (account.balance &lt; amount) &#123;</span><br><span class=\"line\">            System.out.println(&quot;[AccountAspect]拒绝付款!&quot;);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return proceed(amount, account);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    after(int amount, Account balance): callPay(amount, balance) &#123;</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]付款后，剩余：&quot; + balance.balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-使用类\"><a href=\"#3-3-使用类\" class=\"headerlink\" title=\"3.3.使用类\"></a>3.3.使用类</h3></li>\n<li>AccountDoWork.java<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccountDoWork &#123;</span><br><span class=\"line\">    public static void pay() &#123;</span><br><span class=\"line\">        Account account = new Account();</span><br><span class=\"line\">        account.pay(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-AspectJ-的优势与局限性\"><a href=\"#4-AspectJ-的优势与局限性\" class=\"headerlink\" title=\"4.AspectJ 的优势与局限性\"></a>4.AspectJ 的优势与局限性</h2>最常用的字节码处理框架有 AspectJ、ASM 等等，它们的相同之处在于输入输出都是 Class 文件。<br>并且，它们都是 在 Java 文件编译成 .class 文件之后，生成 Dalvik 字节码之前执行。<br>而 AspectJ 作为 Java 中流行的 AOP（aspect-oriented programming） 编程扩展框架，<br>其内部使用的是 BCEL框架 来完成其功能。下面，我们就来了解下 AspectJ 具备哪些优势。<h3 id=\"4-1-AspectJ-的优势\"><a href=\"#4-1-AspectJ-的优势\" class=\"headerlink\" title=\"4.1.AspectJ 的优势\"></a>4.1.AspectJ 的优势</h3> 它的优势有两点：成熟稳定、使用非常简单。</li>\n<li>1、成熟稳定<br>字节码的处理并不简单，特别是 针对于字节码的格式和各种指令规则，如果处理出错，<br>就会导致程序编译或者运行过程中出现问题。而 AspectJ 作为从 2001 年发展至今的框架，<br>它已经发展地非常成熟，通常不用考虑插入的字节码发生正确性相关的问题。</li>\n<li>2、使用非常简单<br>AspectJ 的使用非常简单，并且它的功能非常强大，我们完全不需要理解任何 Java 字节码相关的知识，<br>就可以在很多情况下对字节码进行操控。例如，它可以在如下五个位置插入自定义的代码：<br>1）、在方法（包括构造方法）被调用的位置。<br>2）、在方法体（包括构造方法）的内部。<br>3）、在读写变量的位置。<br>4）、在静态代码块内部。<br>5）、在异常处理的位置的前后。<br>此外，它也可以 直接将原位置的代码替换为自定义的代码。</li>\n</ul>\n<h3 id=\"4-2-AspectJ-的缺陷\"><a href=\"#4-2-AspectJ-的缺陷\" class=\"headerlink\" title=\"4.2.AspectJ 的缺陷\"></a>4.2.AspectJ 的缺陷</h3><p>而 AspectJ 的缺点可以归结为如下 三点：</p>\n<ul>\n<li>1、切入点固定<br>AspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则很难实现，它<br>无法针对一些特定规则的字节码序列做操作。</li>\n<li>2、正则表达式的局限性<br>AspectJ 的匹配规则采用了类似正则表达式的规则，比如 匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到，这样匹配的正确性就无法满足。</li>\n<li>3、性能较低<br>AspectJ 在实现时会包装自己一些特定的类，它并不会直接把 Trace 函数直接插入到代码中，而是经过一系列自己的封装。这样不仅生成的字节码比较大，而且对原函数的性能会有不小的影响。如果想对 App 中所有的函数都进行插桩，性能影响肯定会比较大。如果你只插桩一小部分函数，那么 AspectJ 带来的性能损耗几乎可以忽略不计。<h2 id=\"5-AspectJ-核心语法简介\"><a href=\"#5-AspectJ-核心语法简介\" class=\"headerlink\" title=\"5.AspectJ 核心语法简介\"></a>5.AspectJ 核心语法简介</h2>AspectJ 其实就是一种 AOP 框架，AOP 是实现程序功能统一维护的一种技术。<br>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，<br>提高程序的可重用性，同时大大提高了开发效率。因此 AOP 的优势可总结为如下 两点：</li>\n</ul>\n<p>1）、无侵入性。<br>2）、修改方便。</p>\n<p>此外，AOP 不同于 OOP 将问题划分到单个模块之中，它把 涉及到众多模块的同一类问题进行了统一处理。<br>比如我们可以设计两个切面，一个是用于处理 App 中所有模块的日志输出功能，<br>另外一个则是用于处理 App 中一些特殊函数调用的权限检查。<br>下面👇，我们就来看看要掌握 AspectJ 的使用，我们需要了解的一些 核心概念。</p>\n<ul>\n<li>1、横切关注点<br>对哪些方法进行拦截，拦截后怎么处理。</li>\n<li>2、切面（Aspect）<br>类是对物体特征的抽象，切面就是对横切关注点的抽象。</li>\n<li>3、连接点（JoinPoint）<br>JPoint 是一个程序的关键执行点，也是我们关注的重点。<br>它就是指被拦截到的点（如方法、字段、构造器等等）。</li>\n<li>4、切入点（PointCut）<br>对 JoinPoint 进行拦截的定义。<br>PointCut 的目的就是提供一种方法使得开发者能够选择自己感兴趣的 JoinPoint。</li>\n<li>5、通知（Advice）<br>切入点仅用于捕捉连接点集合，但是，除了捕捉连接点集合以外什么事情都没有做。<br>事实上实现横切行为我们要使用通知。<br>它 一般指拦截到 JoinPoint 后要执行的代码，分为 前置、后置、环绕 三种类型。<br>这里，我们需要 注意 Advice Precedence（优先权） 的情况，<br>比如我们对同一个切面方法同时使用了 @Before 和 @Around 时就会报错，<br>此时会提示需要设置 Advice 的优先级。<br>AspectJ 作为一种基于 Java 语言实现的一套面向切面程序设计规范。<br>它向 Java 中加入了 连接点(Join Point) 这个新概念 ，<br>其实它也只是现存的一个 Java 概 念的名称而已。它向 Java 语言中加入了少许新结构，<br>譬如 切入点(pointcut)、通知(Advice)、类型间声明(Inter-type declaration) 和 切面(Aspect)。切入点和通知动态地影响程序流程，<br>类型间声明则是静态的影响程序的类等级结构，而切面则是对所有这些新结构的封装。<br>对于 AsepctJ 中的各个核心概念来说，其 连接点就恰如程序流中适当的一点。<br>而切入点收集特定的连接点集合和在这些点中的值。<br>一个通知则是当一个连接点到达时执行的代码，这些都是 AspectJ 的动态部分。<br>其实连接点就好比是 程序中那一条一条的语句，<br>而切入点就是特定一条语句处设置的一个断点，它收集了断点处程序栈的信息，<br>而通知就是在这个断点前后想要加入的程序代码。<br>此外，AspectJ 中也有许多不同种类的类型间声明，<br>这就允许程序员修改程序的静态结构、名称、类的成员以及类之间的关系。<br>AspectJ 中的切面是横切关注点的模块单元。它们的行为与 Java 语言中的类很象，<br>但是切面 还封装了切入点、通知以及类型间声明。</li>\n</ul>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6.小结\"></a>6.小结</h2><p>AspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，<br>需要专门找运维人员配置。 在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。<br>大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。</p>\n<h2 id=\"7-参考\"><a href=\"#7-参考\" class=\"headerlink\" title=\"7.参考\"></a>7.参考</h2><p><a href=\"https://javadoop.com/post/aspectj\">https://javadoop.com/post/aspectj</a><br><a href=\"https://juejin.cn/post/6844904112396615688\">https://juejin.cn/post/6844904112396615688</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-AspectJ-使用介绍\"><a href=\"#1-AspectJ-使用介绍\" class=\"headerlink\" title=\"1.AspectJ 使用介绍\"></a>1.AspectJ 使用介绍</h2><p>AspectJ 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为</p>\n<ul>\n<li>compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件</li>\n<li>post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法</li>\n<li>load-time：在 JVM 进行类加载的时候进行织入</li>\n</ul>\n<h3 id=\"1-1-编译插桩分类\"><a href=\"#1-1-编译插桩分类\" class=\"headerlink\" title=\"1.1 编译插桩分类\"></a>1.1 编译插桩分类</h3><p>编译插桩技术具体可以分为两类，如下所示：</p>\n<ul>\n<li>1）、APT（Annotation Process Tools） ：用于生成 Java 代码。</li>\n<li>2）、AOP（Aspect Oriented Programming）：用于操作字节码。</li>\n</ul>\n<p>我们分别来详细介绍下它们的作用。</p>\n<ul>\n<li><p>1、APT（Annotation Process Tools）<br>总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。<br>而 使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。<br>但是 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。<br>使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：</p>\n<p>1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。<br>2）、大大减少了手工重复的工作量，降低了开发时出错的机率。</p>\n</li>\n<li><p>2、AOP（Aspect Oriented Programming）<br> 而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。<br> 相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：</p>\n<p>  1）、应用场景更广。<br>  2）、功能更加强大。<br>  3）、使用复杂度较高。</p>\n</li>\n</ul>\n<h2 id=\"2-依赖引入\"><a href=\"#2-依赖引入\" class=\"headerlink\" title=\"2.依赖引入\"></a>2.依赖引入</h2><p>以gradle依赖为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    maven &#123; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dependencies &#123;</span><br><span class=\"line\">    classpath group: &#x27;io.freefair.gradle&#x27;, name: &#x27;aspectj-plugin&#x27;, version: &#x27;5.3.3.3&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apply plugin: &quot;io.freefair.aspectj&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjweaver&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class=\"line\">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjrt&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>aspectj底层依赖库<ul>\n<li>net.bytebuddy:byte-buddy</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-代码编写\"><a href=\"#3-代码编写\" class=\"headerlink\" title=\"3.代码编写\"></a>3.代码编写</h2><ul>\n<li><p>代码地址请参考：<a href=\"https://github.com/wuhaocn/jcode-simple.git\">https://github.com/wuhaocn/jcode-simple.git</a></p>\n</li>\n<li><p>注意下面操作类应放在”src/main/aspectj”包下面</p>\n</li>\n</ul>\n<h3 id=\"3-1-定义业务类\"><a href=\"#3-1-定义业务类\" class=\"headerlink\" title=\"3.1.定义业务类\"></a>3.1.定义业务类</h3><ul>\n<li>Account.java<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Account &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int balance = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean pay(int amount) &#123;</span><br><span class=\"line\">        if (balance &lt; amount) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        balance -= amount;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-定义注解类\"><a href=\"#3-2-定义注解类\" class=\"headerlink\" title=\"3.2.定义注解类\"></a>3.2.定义注解类</h3></li>\n<li>AccountAspect.aj<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public aspect AccountAspect &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    pointcut callPay(int amount, Account account):</span><br><span class=\"line\">            call(boolean com.rcloud.Account.pay(int)) &amp;&amp; args(amount) &amp;&amp; target(account);</span><br><span class=\"line\"></span><br><span class=\"line\">    before(int amount, Account account): callPay(amount, account) &#123;</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]付款前总金额: &quot; + account.balance);</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]需要付款: &quot; + amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean around(int amount, Account account): callPay(amount, account) &#123;</span><br><span class=\"line\">        if (account.balance &lt; amount) &#123;</span><br><span class=\"line\">            System.out.println(&quot;[AccountAspect]拒绝付款!&quot;);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return proceed(amount, account);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    after(int amount, Account balance): callPay(amount, balance) &#123;</span><br><span class=\"line\">        System.out.println(&quot;[AccountAspect]付款后，剩余：&quot; + balance.balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-使用类\"><a href=\"#3-3-使用类\" class=\"headerlink\" title=\"3.3.使用类\"></a>3.3.使用类</h3></li>\n<li>AccountDoWork.java<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccountDoWork &#123;</span><br><span class=\"line\">    public static void pay() &#123;</span><br><span class=\"line\">        Account account = new Account();</span><br><span class=\"line\">        account.pay(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-AspectJ-的优势与局限性\"><a href=\"#4-AspectJ-的优势与局限性\" class=\"headerlink\" title=\"4.AspectJ 的优势与局限性\"></a>4.AspectJ 的优势与局限性</h2>最常用的字节码处理框架有 AspectJ、ASM 等等，它们的相同之处在于输入输出都是 Class 文件。<br>并且，它们都是 在 Java 文件编译成 .class 文件之后，生成 Dalvik 字节码之前执行。<br>而 AspectJ 作为 Java 中流行的 AOP（aspect-oriented programming） 编程扩展框架，<br>其内部使用的是 BCEL框架 来完成其功能。下面，我们就来了解下 AspectJ 具备哪些优势。<h3 id=\"4-1-AspectJ-的优势\"><a href=\"#4-1-AspectJ-的优势\" class=\"headerlink\" title=\"4.1.AspectJ 的优势\"></a>4.1.AspectJ 的优势</h3> 它的优势有两点：成熟稳定、使用非常简单。</li>\n<li>1、成熟稳定<br>字节码的处理并不简单，特别是 针对于字节码的格式和各种指令规则，如果处理出错，<br>就会导致程序编译或者运行过程中出现问题。而 AspectJ 作为从 2001 年发展至今的框架，<br>它已经发展地非常成熟，通常不用考虑插入的字节码发生正确性相关的问题。</li>\n<li>2、使用非常简单<br>AspectJ 的使用非常简单，并且它的功能非常强大，我们完全不需要理解任何 Java 字节码相关的知识，<br>就可以在很多情况下对字节码进行操控。例如，它可以在如下五个位置插入自定义的代码：<br>1）、在方法（包括构造方法）被调用的位置。<br>2）、在方法体（包括构造方法）的内部。<br>3）、在读写变量的位置。<br>4）、在静态代码块内部。<br>5）、在异常处理的位置的前后。<br>此外，它也可以 直接将原位置的代码替换为自定义的代码。</li>\n</ul>\n<h3 id=\"4-2-AspectJ-的缺陷\"><a href=\"#4-2-AspectJ-的缺陷\" class=\"headerlink\" title=\"4.2.AspectJ 的缺陷\"></a>4.2.AspectJ 的缺陷</h3><p>而 AspectJ 的缺点可以归结为如下 三点：</p>\n<ul>\n<li>1、切入点固定<br>AspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则很难实现，它<br>无法针对一些特定规则的字节码序列做操作。</li>\n<li>2、正则表达式的局限性<br>AspectJ 的匹配规则采用了类似正则表达式的规则，比如 匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到，这样匹配的正确性就无法满足。</li>\n<li>3、性能较低<br>AspectJ 在实现时会包装自己一些特定的类，它并不会直接把 Trace 函数直接插入到代码中，而是经过一系列自己的封装。这样不仅生成的字节码比较大，而且对原函数的性能会有不小的影响。如果想对 App 中所有的函数都进行插桩，性能影响肯定会比较大。如果你只插桩一小部分函数，那么 AspectJ 带来的性能损耗几乎可以忽略不计。<h2 id=\"5-AspectJ-核心语法简介\"><a href=\"#5-AspectJ-核心语法简介\" class=\"headerlink\" title=\"5.AspectJ 核心语法简介\"></a>5.AspectJ 核心语法简介</h2>AspectJ 其实就是一种 AOP 框架，AOP 是实现程序功能统一维护的一种技术。<br>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，<br>提高程序的可重用性，同时大大提高了开发效率。因此 AOP 的优势可总结为如下 两点：</li>\n</ul>\n<p>1）、无侵入性。<br>2）、修改方便。</p>\n<p>此外，AOP 不同于 OOP 将问题划分到单个模块之中，它把 涉及到众多模块的同一类问题进行了统一处理。<br>比如我们可以设计两个切面，一个是用于处理 App 中所有模块的日志输出功能，<br>另外一个则是用于处理 App 中一些特殊函数调用的权限检查。<br>下面👇，我们就来看看要掌握 AspectJ 的使用，我们需要了解的一些 核心概念。</p>\n<ul>\n<li>1、横切关注点<br>对哪些方法进行拦截，拦截后怎么处理。</li>\n<li>2、切面（Aspect）<br>类是对物体特征的抽象，切面就是对横切关注点的抽象。</li>\n<li>3、连接点（JoinPoint）<br>JPoint 是一个程序的关键执行点，也是我们关注的重点。<br>它就是指被拦截到的点（如方法、字段、构造器等等）。</li>\n<li>4、切入点（PointCut）<br>对 JoinPoint 进行拦截的定义。<br>PointCut 的目的就是提供一种方法使得开发者能够选择自己感兴趣的 JoinPoint。</li>\n<li>5、通知（Advice）<br>切入点仅用于捕捉连接点集合，但是，除了捕捉连接点集合以外什么事情都没有做。<br>事实上实现横切行为我们要使用通知。<br>它 一般指拦截到 JoinPoint 后要执行的代码，分为 前置、后置、环绕 三种类型。<br>这里，我们需要 注意 Advice Precedence（优先权） 的情况，<br>比如我们对同一个切面方法同时使用了 @Before 和 @Around 时就会报错，<br>此时会提示需要设置 Advice 的优先级。<br>AspectJ 作为一种基于 Java 语言实现的一套面向切面程序设计规范。<br>它向 Java 中加入了 连接点(Join Point) 这个新概念 ，<br>其实它也只是现存的一个 Java 概 念的名称而已。它向 Java 语言中加入了少许新结构，<br>譬如 切入点(pointcut)、通知(Advice)、类型间声明(Inter-type declaration) 和 切面(Aspect)。切入点和通知动态地影响程序流程，<br>类型间声明则是静态的影响程序的类等级结构，而切面则是对所有这些新结构的封装。<br>对于 AsepctJ 中的各个核心概念来说，其 连接点就恰如程序流中适当的一点。<br>而切入点收集特定的连接点集合和在这些点中的值。<br>一个通知则是当一个连接点到达时执行的代码，这些都是 AspectJ 的动态部分。<br>其实连接点就好比是 程序中那一条一条的语句，<br>而切入点就是特定一条语句处设置的一个断点，它收集了断点处程序栈的信息，<br>而通知就是在这个断点前后想要加入的程序代码。<br>此外，AspectJ 中也有许多不同种类的类型间声明，<br>这就允许程序员修改程序的静态结构、名称、类的成员以及类之间的关系。<br>AspectJ 中的切面是横切关注点的模块单元。它们的行为与 Java 语言中的类很象，<br>但是切面 还封装了切入点、通知以及类型间声明。</li>\n</ul>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6.小结\"></a>6.小结</h2><p>AspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，<br>需要专门找运维人员配置。 在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。<br>大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。</p>\n<h2 id=\"7-参考\"><a href=\"#7-参考\" class=\"headerlink\" title=\"7.参考\"></a>7.参考</h2><p><a href=\"https://javadoop.com/post/aspectj\">https://javadoop.com/post/aspectj</a><br><a href=\"https://juejin.cn/post/6844904112396615688\">https://juejin.cn/post/6844904112396615688</a></p>\n"},{"title":"bytebuddy介绍","_content":"\n\n# 字节码增强技术-Byte Buddy\n\n## 1.为什么需要在运行时生成代码？\n\nJava 是一个强类型语言系统，要求变量和对象都有一个确定的类型，不兼容类型赋值都会造成转换异常，通常情况下这种错误都会被编译器检查出来，\n如此严格的类型在大多数情况下是比较令人满意的，这对构建具有非常强可读性和稳定性的应用有很大的帮助，这也是 Java 能在企业编程中的普及的一个原因之一。\n然而，因为起强类型的检查，限制了其他领域语言应用范围。比如在编写一个框架是，通常我们并不知道应用程序定义的类型，因为当这个库被编译时， 我们还不知道这些类型，为了能在这种情况下能调用或者访问应用程序的方法或者变量，Java\n类库提供了一套反射 API。使用这套反射 API， 我们就可以反省为知类型，进而调用方法或者访问属性。但是，Java 反射有如下缺点：\n\n* 需要执行一个相当昂贵的方法查找来获取描述特定方法的对象，因此，相比硬编码的方法调用，使用 反射 API 非常慢。\n* 反射 API 能绕过类型安全检查，可能会因为使用不当照成意想不到的问题，这样就错失了 Java 编程语言的一大特性。\n\n## 2.简介\n\n正如官网说的：Byte Buddy 是一个代码生成和操作库，用于在Java应用程序运行时创建和修改Java类，而无需编译器的帮助。 除了Java类库附带的代码生成实用程序外，Byte\nBuddy还允许创建任意类，并且不限于实现用于创建运行时代理的接口。 此外，Byte Buddy提供了一种方便的API，可以使用Java代理或在构建过程中手动更改类。Byte Buddy 相比其他字节码操作库有如下优势：\n\n* 无需理解字节码格式，即可操作，简单易行的 API 能很容易操作字节码。\n* 支持 Java 任何版本，库轻量，仅取决于Java字节代码解析器库ASM的访问者API，它本身不需要任何其他依赖项。\n* 比起JDK动态代理、cglib、Javassist，Byte Buddy在性能上具有优势。\n\n### 3.性能\n\n在选择字节码操作库时，往往需要考虑库本身的性能。对于许多应用程序，生成代码的运行时特性更有可能确定最佳选择。而 在生成的代码本身的运行时间之外，用于创建动态类的运行时也是一个问题。官网对库进行了性能测试，给出以下结果图：\n\n![](https://user-gold-cdn.xitu.io/2019/10/13/16dc4ade119d5610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n图中的每一行分别为，类的创建、接口实现、方法调用、类型扩展、父类方法调用的性能结果。 从性能报告中可以看出，Byte Buddy 的主要侧重点在于以最少的运行时生成代码，需要注意的是，我们这些衡量 Java 代码性能的测试， 都由 Java\n虚拟机即时编译器优化过，如果你的代码只是偶尔运行，没有得到虚拟机的优化，可能性能会有所偏差。 所以我们在使用 Byte Buddy 开发时，我们希望监控这些指标，以避免在添加新功能时造成性能损失。\n\n## 4.Hello world代码\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\n\n        Object instance = dynamicType.newInstance();\n        String toString = instance.toString();\n        System.out.println(toString);\n        System.out.println(instance.getClass().getCanonicalName());\n```\n\n从例子中看到，操作创建一个类如此的简单。正如 ByteBuddy 说明的，ByteBuddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性简单易行的 API， 可能能让你在初次使用的过程中就能不需要查阅 API\n的前提下完成编码。这也真是 ByteBuddy 能完爆其他同类型库的一个原因。 上面的示例中使用的默认ByteBuddy配置会以最新版本的类文件格式创建Java类，该类文件格式可以被正在处理的Java虚拟机理解。 subclass\n指定了新创建的类的父类，同时 method 指定了 Object 的 toString 方法，intercept 拦截了 toString 方法并返回固定的 value ， 最后 make 方法生产字节码，有类加载器加载到虚拟机中。\n此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理， 该代理允许在任何 Java\n应用程序的运行期间进行代码转换，代理会在下篇单独写一篇文章讲解。\n\n## 5.创建一个类\n\n任何一个由 ByteBuddy 创建的类型都是通过 ByteBuddy 类的实例来完成的。通过简单地调用 new ByteBuddy() 就可以创建一个新实例。\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n    .subclass(Object.class)\n    .make();\n```\n\n上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的 。该列子没有命名动态生成的类型，但是在定义 Java\n类时却是必须的，所以很容易的你会想到，ByteBuddy 会有默认的策略给我们生成。 当然，你也可以很容易地明确地命名这个类型。\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n.subclass(Object.class)\n.name(\"example.Type\")\n.make();\n```\n\n那么默认的策略是如何做的呢？这个将与 ByteBuddy 与 约定大于配置息息相关，它提供了我们认为比较全面的默认配置。 至于类型命名，ByteBuddy 的默认配置提供了\nNamingStrategy，它基于动态类型的超类名称来随机生成类名。 此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 example.Foo， 那么生成的名称将会类似于\nexample.FooByteBuddy1376491271，这里的数字序列是随机的。\n\n此外，在一些需要指定类型的场景中，可以通过重写 NamingStrategy 的方法来实现，或者使用 ByteBuddy 内置的NamingStrategy.SuffixingRandom 来实现。\n\n同时需要注意的是，我们编码时需要遵守所谓的领域特定语言和不变性原则，这是说明意思呢？就是说在 ByteBuddy 中， 几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的。请看下面一个例子：\n\n```\nByteBuddy byteBuddy = new ByteBuddy();\nbyteBuddy.with(new NamingStrategy.SuffixingRandom(\"suffix\"));\nDynamicType.Unloaded<?> dynamicType1 = byteBuddy.subclass(Object.class).make();\n```\n\n上述例子你会发现类的命名策略还是默认的，其根本原因就是没有遵守上述原则导致的。所以在编码过程中要基于此原则进行。\n\n## 6.加载类\n\n上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码， 通过 DynamicType.Unloaded 中的 getBytes\n方法你可以获取到该字节码，在你的应用程序中， 你可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法， 可以将类存储在给定的文件夹中； inject(File)\n方法将类注入到现有的 Jar 文件中， 另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\nWRAPPER：创建一个新的Wrapping类加载器 CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类 INJECTION：利用反射机制注入动态类型 示例\n\n```\nClass<?> type = new ByteBuddy()\n.subclass(Object.class)\n.make()\n.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n.getLoaded()\n```\n\n这样我们创建并加载了一个类。我们使用 WRAPPER 策略来加载适合大多数情况的类。getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类。\n\n重新加载类 得益于JVM的HostSwap特性，已加载的类可以被重新定义：\n\n// 安装Byte Buddy的Agent，除了通过-javaagent静态安装，还可以：\n\n```\nByteBuddyAgent.install();\nFoo foo = new Foo();\n    new ByteBuddy()\n    .redefine(Bar.class)\n    .name(Foo.class.getName())\n    .make()\n    .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());\n    assertThat(foo.m(), is(\"bar\"));\n```\n\n可以看到，即使时已经存在的对象，也会受到类Reloading的影响。但是需要注意的是HostSwap具有限制：\n\n类再重新载入前后，必须具有相同的Schema，也就是方法、字段不能减少（可以增加） 不支持具有静态初始化块的类 修改类 redefine 重定义一个类时，Byte Buddy\n可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。新添加的方法，如果签名和原有方法一致，则原有方法会消失。\n\nrebase 类似于redefine，但是原有的方法不会消失，而是被重命名，添加后缀 $original，这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法，例如类：\n\n```\nclass Foo {\n    String bar() { return \"bar\"; }\n}\n```\n\nrebase 之后：\n\n```\nclass Foo {\n    String bar() { return \"foo\" + bar$original(); }\n    private String bar$original() { return \"bar\"; }\n}\n```\n\n## 7.方法拦截\n\n通过匹配模式拦截 ByteBuddy 提供了很多用于匹配方法的 DSL，如下例子：\n\n```\nFoo dynamicFoo = new ByteBuddy()\n    .subclass(Foo.class)\n    // 匹配由Foo.class声明的方法\n    .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n    // 匹配名为foo的方法\n    .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n    // 匹配名为foo，入参数量为1的方法\n    .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n    .make()\n    .load(getClass().getClassLoader())\n    .getLoaded()\n    .newInstance();\n```\n\nByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略。库本身提供的 Matcher 非常多。Uploading file...\n\n## 8.方法委托\n\n使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n    public String hello(String name) { return null; }\n}\n\nclass Target {\n    public static String hello(String name) {\n        return \"Hello \" + name + \"!\";\n    }\n}\n\nString helloWorld = new ByteBuddy()\n    .subclass(Source.class)\n    .method(named(\"hello\")).intercept(MethodDelegation.to(Target.class))\n    .make()\n    .load(getClass().getClassLoader())\n    .getLoaded()\n    .newInstance()\n    .hello(\"World\");\n```\n\n其中 Target 还可以如下实现：\n\n```\nclass Target {\n    public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n    public static String intercept(int i) { return Integer.toString(i); }\n    public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\nintercept(int)因为参数类型不匹配，直接Pass 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它 同时需要注意的是被拦截的方法需要声明为\npublic，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```\n@RuntimeType\npublic static Object intercept(@RuntimeType Object value) {\n    System.out.println(\"Invoked method with: \" + value);\n    return value;\n}\n```\n\n## 9.参数绑定\n\n可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如：\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)复制代码\n常用的注解如下表：\n```\n\n注解   | 描述\n----- | -----\n@Argument |    绑定单个参数\n@AllArguments     | 绑定所有参数的数组\n@This     | 当前被拦截的、动态生成的那个对象\n@DefaultCall |    调用默认方法而非super的方法\n@SuperCall |    用于调用父类版本的方法\n@RuntimeType |    可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n@Super |    当前被拦截的、动态生成的那个对象的父类对象\n@FieldValue |    注入被拦截对象的一个字段的值\n\n## 10.字段属性\n\n```\npublic class UserType {\n  public String doSomething() { return null; }\n}\n\npublic interface Interceptor {\n  String doSomethingElse();\n}\n\npublic interface InterceptionAccessor {\n  Interceptor getInterceptor();\n  void setInterceptor(Interceptor interceptor);\n}\n\npublic interface InstanceCreator {\n  Object makeInstance();\n}\n\npublic class HelloWorldInterceptor implements Interceptor {\n  @Override\n  public String doSomethingElse() {\n    return \"Hello World!\";\n  }\n}\n\nClass<? extends UserType> dynamicUserType = new ByteBuddy()\n  .subclass(UserType.class)\n    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法\n    .intercept(MethodDelegation.toField(\"interceptor\")) // 拦截委托给属性字段 interceptor\n  .defineField(\"interceptor\", Interceptor.class, Visibility.PRIVATE) // 定义一个属性字段\n  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty()) // 实现 InterceptionAccessor 接口\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded();\n    \nInstanceCreator factory = new ByteBuddy()\n  .subclass(InstanceCreator.class)\n    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法\n    .intercept(MethodDelegation.toConstructor(dynamicUserType)) // 委托拦截的方法来调用提供的类型的构造函数\n  .make()\n  .load(dynamicUserType.getClassLoader())\n  .getLoaded().newInstance();\n\nUserType userType = (UserType) factory.makeInstance();\n((InterceptionAccessor) userType).setInterceptor(new HelloWorldInterceptor());\nString s = userType.doSomething();\nSystem.out.println(s); // Hello World!\n```\n\n上述例子将 UserType 类实现了 InterceptionAccessor 接口，同时使用 MethodDelegation.toField 可以使拦截的方法可以委托给新增的字段。\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 11.参考\n\nhttps://juejin.cn/post/6844903965553852423\nhttps://www.cnblogs.com/yungyu16/p/13167240.html","source":"_posts/language/字节码/bytebuddy-code.md","raw":"---\ntitle: bytebuddy介绍\ncategories:\n- java\n---\n\n\n# 字节码增强技术-Byte Buddy\n\n## 1.为什么需要在运行时生成代码？\n\nJava 是一个强类型语言系统，要求变量和对象都有一个确定的类型，不兼容类型赋值都会造成转换异常，通常情况下这种错误都会被编译器检查出来，\n如此严格的类型在大多数情况下是比较令人满意的，这对构建具有非常强可读性和稳定性的应用有很大的帮助，这也是 Java 能在企业编程中的普及的一个原因之一。\n然而，因为起强类型的检查，限制了其他领域语言应用范围。比如在编写一个框架是，通常我们并不知道应用程序定义的类型，因为当这个库被编译时， 我们还不知道这些类型，为了能在这种情况下能调用或者访问应用程序的方法或者变量，Java\n类库提供了一套反射 API。使用这套反射 API， 我们就可以反省为知类型，进而调用方法或者访问属性。但是，Java 反射有如下缺点：\n\n* 需要执行一个相当昂贵的方法查找来获取描述特定方法的对象，因此，相比硬编码的方法调用，使用 反射 API 非常慢。\n* 反射 API 能绕过类型安全检查，可能会因为使用不当照成意想不到的问题，这样就错失了 Java 编程语言的一大特性。\n\n## 2.简介\n\n正如官网说的：Byte Buddy 是一个代码生成和操作库，用于在Java应用程序运行时创建和修改Java类，而无需编译器的帮助。 除了Java类库附带的代码生成实用程序外，Byte\nBuddy还允许创建任意类，并且不限于实现用于创建运行时代理的接口。 此外，Byte Buddy提供了一种方便的API，可以使用Java代理或在构建过程中手动更改类。Byte Buddy 相比其他字节码操作库有如下优势：\n\n* 无需理解字节码格式，即可操作，简单易行的 API 能很容易操作字节码。\n* 支持 Java 任何版本，库轻量，仅取决于Java字节代码解析器库ASM的访问者API，它本身不需要任何其他依赖项。\n* 比起JDK动态代理、cglib、Javassist，Byte Buddy在性能上具有优势。\n\n### 3.性能\n\n在选择字节码操作库时，往往需要考虑库本身的性能。对于许多应用程序，生成代码的运行时特性更有可能确定最佳选择。而 在生成的代码本身的运行时间之外，用于创建动态类的运行时也是一个问题。官网对库进行了性能测试，给出以下结果图：\n\n![](https://user-gold-cdn.xitu.io/2019/10/13/16dc4ade119d5610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n图中的每一行分别为，类的创建、接口实现、方法调用、类型扩展、父类方法调用的性能结果。 从性能报告中可以看出，Byte Buddy 的主要侧重点在于以最少的运行时生成代码，需要注意的是，我们这些衡量 Java 代码性能的测试， 都由 Java\n虚拟机即时编译器优化过，如果你的代码只是偶尔运行，没有得到虚拟机的优化，可能性能会有所偏差。 所以我们在使用 Byte Buddy 开发时，我们希望监控这些指标，以避免在添加新功能时造成性能损失。\n\n## 4.Hello world代码\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\n\n        Object instance = dynamicType.newInstance();\n        String toString = instance.toString();\n        System.out.println(toString);\n        System.out.println(instance.getClass().getCanonicalName());\n```\n\n从例子中看到，操作创建一个类如此的简单。正如 ByteBuddy 说明的，ByteBuddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性简单易行的 API， 可能能让你在初次使用的过程中就能不需要查阅 API\n的前提下完成编码。这也真是 ByteBuddy 能完爆其他同类型库的一个原因。 上面的示例中使用的默认ByteBuddy配置会以最新版本的类文件格式创建Java类，该类文件格式可以被正在处理的Java虚拟机理解。 subclass\n指定了新创建的类的父类，同时 method 指定了 Object 的 toString 方法，intercept 拦截了 toString 方法并返回固定的 value ， 最后 make 方法生产字节码，有类加载器加载到虚拟机中。\n此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理， 该代理允许在任何 Java\n应用程序的运行期间进行代码转换，代理会在下篇单独写一篇文章讲解。\n\n## 5.创建一个类\n\n任何一个由 ByteBuddy 创建的类型都是通过 ByteBuddy 类的实例来完成的。通过简单地调用 new ByteBuddy() 就可以创建一个新实例。\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n    .subclass(Object.class)\n    .make();\n```\n\n上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的 。该列子没有命名动态生成的类型，但是在定义 Java\n类时却是必须的，所以很容易的你会想到，ByteBuddy 会有默认的策略给我们生成。 当然，你也可以很容易地明确地命名这个类型。\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n.subclass(Object.class)\n.name(\"example.Type\")\n.make();\n```\n\n那么默认的策略是如何做的呢？这个将与 ByteBuddy 与 约定大于配置息息相关，它提供了我们认为比较全面的默认配置。 至于类型命名，ByteBuddy 的默认配置提供了\nNamingStrategy，它基于动态类型的超类名称来随机生成类名。 此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 example.Foo， 那么生成的名称将会类似于\nexample.FooByteBuddy1376491271，这里的数字序列是随机的。\n\n此外，在一些需要指定类型的场景中，可以通过重写 NamingStrategy 的方法来实现，或者使用 ByteBuddy 内置的NamingStrategy.SuffixingRandom 来实现。\n\n同时需要注意的是，我们编码时需要遵守所谓的领域特定语言和不变性原则，这是说明意思呢？就是说在 ByteBuddy 中， 几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的。请看下面一个例子：\n\n```\nByteBuddy byteBuddy = new ByteBuddy();\nbyteBuddy.with(new NamingStrategy.SuffixingRandom(\"suffix\"));\nDynamicType.Unloaded<?> dynamicType1 = byteBuddy.subclass(Object.class).make();\n```\n\n上述例子你会发现类的命名策略还是默认的，其根本原因就是没有遵守上述原则导致的。所以在编码过程中要基于此原则进行。\n\n## 6.加载类\n\n上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码， 通过 DynamicType.Unloaded 中的 getBytes\n方法你可以获取到该字节码，在你的应用程序中， 你可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法， 可以将类存储在给定的文件夹中； inject(File)\n方法将类注入到现有的 Jar 文件中， 另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\nWRAPPER：创建一个新的Wrapping类加载器 CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类 INJECTION：利用反射机制注入动态类型 示例\n\n```\nClass<?> type = new ByteBuddy()\n.subclass(Object.class)\n.make()\n.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n.getLoaded()\n```\n\n这样我们创建并加载了一个类。我们使用 WRAPPER 策略来加载适合大多数情况的类。getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类。\n\n重新加载类 得益于JVM的HostSwap特性，已加载的类可以被重新定义：\n\n// 安装Byte Buddy的Agent，除了通过-javaagent静态安装，还可以：\n\n```\nByteBuddyAgent.install();\nFoo foo = new Foo();\n    new ByteBuddy()\n    .redefine(Bar.class)\n    .name(Foo.class.getName())\n    .make()\n    .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());\n    assertThat(foo.m(), is(\"bar\"));\n```\n\n可以看到，即使时已经存在的对象，也会受到类Reloading的影响。但是需要注意的是HostSwap具有限制：\n\n类再重新载入前后，必须具有相同的Schema，也就是方法、字段不能减少（可以增加） 不支持具有静态初始化块的类 修改类 redefine 重定义一个类时，Byte Buddy\n可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。新添加的方法，如果签名和原有方法一致，则原有方法会消失。\n\nrebase 类似于redefine，但是原有的方法不会消失，而是被重命名，添加后缀 $original，这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法，例如类：\n\n```\nclass Foo {\n    String bar() { return \"bar\"; }\n}\n```\n\nrebase 之后：\n\n```\nclass Foo {\n    String bar() { return \"foo\" + bar$original(); }\n    private String bar$original() { return \"bar\"; }\n}\n```\n\n## 7.方法拦截\n\n通过匹配模式拦截 ByteBuddy 提供了很多用于匹配方法的 DSL，如下例子：\n\n```\nFoo dynamicFoo = new ByteBuddy()\n    .subclass(Foo.class)\n    // 匹配由Foo.class声明的方法\n    .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n    // 匹配名为foo的方法\n    .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n    // 匹配名为foo，入参数量为1的方法\n    .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n    .make()\n    .load(getClass().getClassLoader())\n    .getLoaded()\n    .newInstance();\n```\n\nByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略。库本身提供的 Matcher 非常多。Uploading file...\n\n## 8.方法委托\n\n使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n    public String hello(String name) { return null; }\n}\n\nclass Target {\n    public static String hello(String name) {\n        return \"Hello \" + name + \"!\";\n    }\n}\n\nString helloWorld = new ByteBuddy()\n    .subclass(Source.class)\n    .method(named(\"hello\")).intercept(MethodDelegation.to(Target.class))\n    .make()\n    .load(getClass().getClassLoader())\n    .getLoaded()\n    .newInstance()\n    .hello(\"World\");\n```\n\n其中 Target 还可以如下实现：\n\n```\nclass Target {\n    public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n    public static String intercept(int i) { return Integer.toString(i); }\n    public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\nintercept(int)因为参数类型不匹配，直接Pass 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它 同时需要注意的是被拦截的方法需要声明为\npublic，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```\n@RuntimeType\npublic static Object intercept(@RuntimeType Object value) {\n    System.out.println(\"Invoked method with: \" + value);\n    return value;\n}\n```\n\n## 9.参数绑定\n\n可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如：\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)复制代码\n常用的注解如下表：\n```\n\n注解   | 描述\n----- | -----\n@Argument |    绑定单个参数\n@AllArguments     | 绑定所有参数的数组\n@This     | 当前被拦截的、动态生成的那个对象\n@DefaultCall |    调用默认方法而非super的方法\n@SuperCall |    用于调用父类版本的方法\n@RuntimeType |    可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n@Super |    当前被拦截的、动态生成的那个对象的父类对象\n@FieldValue |    注入被拦截对象的一个字段的值\n\n## 10.字段属性\n\n```\npublic class UserType {\n  public String doSomething() { return null; }\n}\n\npublic interface Interceptor {\n  String doSomethingElse();\n}\n\npublic interface InterceptionAccessor {\n  Interceptor getInterceptor();\n  void setInterceptor(Interceptor interceptor);\n}\n\npublic interface InstanceCreator {\n  Object makeInstance();\n}\n\npublic class HelloWorldInterceptor implements Interceptor {\n  @Override\n  public String doSomethingElse() {\n    return \"Hello World!\";\n  }\n}\n\nClass<? extends UserType> dynamicUserType = new ByteBuddy()\n  .subclass(UserType.class)\n    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法\n    .intercept(MethodDelegation.toField(\"interceptor\")) // 拦截委托给属性字段 interceptor\n  .defineField(\"interceptor\", Interceptor.class, Visibility.PRIVATE) // 定义一个属性字段\n  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty()) // 实现 InterceptionAccessor 接口\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded();\n    \nInstanceCreator factory = new ByteBuddy()\n  .subclass(InstanceCreator.class)\n    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法\n    .intercept(MethodDelegation.toConstructor(dynamicUserType)) // 委托拦截的方法来调用提供的类型的构造函数\n  .make()\n  .load(dynamicUserType.getClassLoader())\n  .getLoaded().newInstance();\n\nUserType userType = (UserType) factory.makeInstance();\n((InterceptionAccessor) userType).setInterceptor(new HelloWorldInterceptor());\nString s = userType.doSomething();\nSystem.out.println(s); // Hello World!\n```\n\n上述例子将 UserType 类实现了 InterceptionAccessor 接口，同时使用 MethodDelegation.toField 可以使拦截的方法可以委托给新增的字段。\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 11.参考\n\nhttps://juejin.cn/post/6844903965553852423\nhttps://www.cnblogs.com/yungyu16/p/13167240.html","slug":"language/字节码/bytebuddy-code","published":1,"date":"2021-07-31T09:07:14.737Z","updated":"2021-07-31T09:07:14.738Z","_id":"ckrrjv2bn0001y2ukf6b6216j","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"字节码增强技术-Byte-Buddy\"><a href=\"#字节码增强技术-Byte-Buddy\" class=\"headerlink\" title=\"字节码增强技术-Byte Buddy\"></a>字节码增强技术-Byte Buddy</h1><h2 id=\"1-为什么需要在运行时生成代码？\"><a href=\"#1-为什么需要在运行时生成代码？\" class=\"headerlink\" title=\"1.为什么需要在运行时生成代码？\"></a>1.为什么需要在运行时生成代码？</h2><p>Java 是一个强类型语言系统，要求变量和对象都有一个确定的类型，不兼容类型赋值都会造成转换异常，通常情况下这种错误都会被编译器检查出来，<br>如此严格的类型在大多数情况下是比较令人满意的，这对构建具有非常强可读性和稳定性的应用有很大的帮助，这也是 Java 能在企业编程中的普及的一个原因之一。<br>然而，因为起强类型的检查，限制了其他领域语言应用范围。比如在编写一个框架是，通常我们并不知道应用程序定义的类型，因为当这个库被编译时， 我们还不知道这些类型，为了能在这种情况下能调用或者访问应用程序的方法或者变量，Java<br>类库提供了一套反射 API。使用这套反射 API， 我们就可以反省为知类型，进而调用方法或者访问属性。但是，Java 反射有如下缺点：</p>\n<ul>\n<li>需要执行一个相当昂贵的方法查找来获取描述特定方法的对象，因此，相比硬编码的方法调用，使用 反射 API 非常慢。</li>\n<li>反射 API 能绕过类型安全检查，可能会因为使用不当照成意想不到的问题，这样就错失了 Java 编程语言的一大特性。</li>\n</ul>\n<h2 id=\"2-简介\"><a href=\"#2-简介\" class=\"headerlink\" title=\"2.简介\"></a>2.简介</h2><p>正如官网说的：Byte Buddy 是一个代码生成和操作库，用于在Java应用程序运行时创建和修改Java类，而无需编译器的帮助。 除了Java类库附带的代码生成实用程序外，Byte<br>Buddy还允许创建任意类，并且不限于实现用于创建运行时代理的接口。 此外，Byte Buddy提供了一种方便的API，可以使用Java代理或在构建过程中手动更改类。Byte Buddy 相比其他字节码操作库有如下优势：</p>\n<ul>\n<li>无需理解字节码格式，即可操作，简单易行的 API 能很容易操作字节码。</li>\n<li>支持 Java 任何版本，库轻量，仅取决于Java字节代码解析器库ASM的访问者API，它本身不需要任何其他依赖项。</li>\n<li>比起JDK动态代理、cglib、Javassist，Byte Buddy在性能上具有优势。</li>\n</ul>\n<h3 id=\"3-性能\"><a href=\"#3-性能\" class=\"headerlink\" title=\"3.性能\"></a>3.性能</h3><p>在选择字节码操作库时，往往需要考虑库本身的性能。对于许多应用程序，生成代码的运行时特性更有可能确定最佳选择。而 在生成的代码本身的运行时间之外，用于创建动态类的运行时也是一个问题。官网对库进行了性能测试，给出以下结果图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/10/13/16dc4ade119d5610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"></p>\n<p>图中的每一行分别为，类的创建、接口实现、方法调用、类型扩展、父类方法调用的性能结果。 从性能报告中可以看出，Byte Buddy 的主要侧重点在于以最少的运行时生成代码，需要注意的是，我们这些衡量 Java 代码性能的测试， 都由 Java<br>虚拟机即时编译器优化过，如果你的代码只是偶尔运行，没有得到虚拟机的优化，可能性能会有所偏差。 所以我们在使用 Byte Buddy 开发时，我们希望监控这些指标，以避免在添加新功能时造成性能损失。</p>\n<h2 id=\"4-Hello-world代码\"><a href=\"#4-Hello-world代码\" class=\"headerlink\" title=\"4.Hello world代码\"></a>4.Hello world代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\"></span><br><span class=\"line\">        Object instance = dynamicType.newInstance();</span><br><span class=\"line\">        String toString = instance.toString();</span><br><span class=\"line\">        System.out.println(toString);</span><br><span class=\"line\">        System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n\n<p>从例子中看到，操作创建一个类如此的简单。正如 ByteBuddy 说明的，ByteBuddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性简单易行的 API， 可能能让你在初次使用的过程中就能不需要查阅 API<br>的前提下完成编码。这也真是 ByteBuddy 能完爆其他同类型库的一个原因。 上面的示例中使用的默认ByteBuddy配置会以最新版本的类文件格式创建Java类，该类文件格式可以被正在处理的Java虚拟机理解。 subclass<br>指定了新创建的类的父类，同时 method 指定了 Object 的 toString 方法，intercept 拦截了 toString 方法并返回固定的 value ， 最后 make 方法生产字节码，有类加载器加载到虚拟机中。<br>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理， 该代理允许在任何 Java<br>应用程序的运行期间进行代码转换，代理会在下篇单独写一篇文章讲解。</p>\n<h2 id=\"5-创建一个类\"><a href=\"#5-创建一个类\" class=\"headerlink\" title=\"5.创建一个类\"></a>5.创建一个类</h2><p>任何一个由 ByteBuddy 创建的类型都是通过 ByteBuddy 类的实例来完成的。通过简单地调用 new ByteBuddy() 就可以创建一个新实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Object.class)</span><br><span class=\"line\">    .make();</span><br></pre></td></tr></table></figure>\n\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的 。该列子没有命名动态生成的类型，但是在定义 Java<br>类时却是必须的，所以很容易的你会想到，ByteBuddy 会有默认的策略给我们生成。 当然，你也可以很容易地明确地命名这个类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">.subclass(Object.class)</span><br><span class=\"line\">.name(&quot;example.Type&quot;)</span><br><span class=\"line\">.make();</span><br></pre></td></tr></table></figure>\n\n<p>那么默认的策略是如何做的呢？这个将与 ByteBuddy 与 约定大于配置息息相关，它提供了我们认为比较全面的默认配置。 至于类型命名，ByteBuddy 的默认配置提供了<br>NamingStrategy，它基于动态类型的超类名称来随机生成类名。 此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 example.Foo， 那么生成的名称将会类似于<br>example.FooByteBuddy1376491271，这里的数字序列是随机的。</p>\n<p>此外，在一些需要指定类型的场景中，可以通过重写 NamingStrategy 的方法来实现，或者使用 ByteBuddy 内置的NamingStrategy.SuffixingRandom 来实现。</p>\n<p>同时需要注意的是，我们编码时需要遵守所谓的领域特定语言和不变性原则，这是说明意思呢？就是说在 ByteBuddy 中， 几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的。请看下面一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class=\"line\">byteBuddy.with(new NamingStrategy.SuffixingRandom(&quot;suffix&quot;));</span><br><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType1 = byteBuddy.subclass(Object.class).make();</span><br></pre></td></tr></table></figure>\n\n<p>上述例子你会发现类的命名策略还是默认的，其根本原因就是没有遵守上述原则导致的。所以在编码过程中要基于此原则进行。</p>\n<h2 id=\"6-加载类\"><a href=\"#6-加载类\" class=\"headerlink\" title=\"6.加载类\"></a>6.加载类</h2><p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码， 通过 DynamicType.Unloaded 中的 getBytes<br>方法你可以获取到该字节码，在你的应用程序中， 你可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法， 可以将类存储在给定的文件夹中； inject(File)<br>方法将类注入到现有的 Jar 文件中， 另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<p>WRAPPER：创建一个新的Wrapping类加载器 CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类 INJECTION：利用反射机制注入动态类型 示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; type = new ByteBuddy()</span><br><span class=\"line\">.subclass(Object.class)</span><br><span class=\"line\">.make()</span><br><span class=\"line\">.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">.getLoaded()</span><br></pre></td></tr></table></figure>\n\n<p>这样我们创建并加载了一个类。我们使用 WRAPPER 策略来加载适合大多数情况的类。getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类。</p>\n<p>重新加载类 得益于JVM的HostSwap特性，已加载的类可以被重新定义：</p>\n<p>// 安装Byte Buddy的Agent，除了通过-javaagent静态安装，还可以：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddyAgent.install();</span><br><span class=\"line\">Foo foo = new Foo();</span><br><span class=\"line\">    new ByteBuddy()</span><br><span class=\"line\">    .redefine(Bar.class)</span><br><span class=\"line\">    .name(Foo.class.getName())</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class=\"line\">    assertThat(foo.m(), is(&quot;bar&quot;));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，即使时已经存在的对象，也会受到类Reloading的影响。但是需要注意的是HostSwap具有限制：</p>\n<p>类再重新载入前后，必须具有相同的Schema，也就是方法、字段不能减少（可以增加） 不支持具有静态初始化块的类 修改类 redefine 重定义一个类时，Byte Buddy<br>可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。新添加的方法，如果签名和原有方法一致，则原有方法会消失。</p>\n<p>rebase 类似于redefine，但是原有的方法不会消失，而是被重命名，添加后缀 $original，这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法，例如类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    String bar() &#123; return &quot;bar&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rebase 之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    String bar() &#123; return &quot;foo&quot; + bar$original(); &#125;</span><br><span class=\"line\">    private String bar$original() &#123; return &quot;bar&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-方法拦截\"><a href=\"#7-方法拦截\" class=\"headerlink\" title=\"7.方法拦截\"></a>7.方法拦截</h2><p>通过匹配模式拦截 ByteBuddy 提供了很多用于匹配方法的 DSL，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Foo.class)</span><br><span class=\"line\">    // 匹配由Foo.class声明的方法</span><br><span class=\"line\">    .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">    // 匹配名为foo的方法</span><br><span class=\"line\">    .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">    // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">    .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(getClass().getClassLoader())</span><br><span class=\"line\">    .getLoaded()</span><br><span class=\"line\">    .newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略。库本身提供的 Matcher 非常多。Uploading file…</p>\n<h2 id=\"8-方法委托\"><a href=\"#8-方法委托\" class=\"headerlink\" title=\"8.方法委托\"></a>8.方法委托</h2><p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">    public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\">    public static String hello(String name) &#123;</span><br><span class=\"line\">        return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Source.class)</span><br><span class=\"line\">    .method(named(&quot;hello&quot;)).intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(getClass().getClassLoader())</span><br><span class=\"line\">    .getLoaded()</span><br><span class=\"line\">    .newInstance()</span><br><span class=\"line\">    .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">    public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">    public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">    public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<p>intercept(int)因为参数类型不匹配，直接Pass 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它 同时需要注意的是被拦截的方法需要声明为<br>public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RuntimeType</span><br><span class=\"line\">public static Object intercept(@RuntimeType Object value) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Invoked method with: &quot; + value);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-参数绑定\"><a href=\"#9-参数绑定\" class=\"headerlink\" title=\"9.参数绑定\"></a>9.参数绑定</h2><p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)复制代码</span><br><span class=\"line\">常用的注解如下表：</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Argument</td>\n<td>绑定单个参数</td>\n</tr>\n<tr>\n<td>@AllArguments</td>\n<td>绑定所有参数的数组</td>\n</tr>\n<tr>\n<td>@This</td>\n<td>当前被拦截的、动态生成的那个对象</td>\n</tr>\n<tr>\n<td>@DefaultCall</td>\n<td>调用默认方法而非super的方法</td>\n</tr>\n<tr>\n<td>@SuperCall</td>\n<td>用于调用父类版本的方法</td>\n</tr>\n<tr>\n<td>@RuntimeType</td>\n<td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>当前被拦截的、动态生成的那个对象的父类对象</td>\n</tr>\n<tr>\n<td>@FieldValue</td>\n<td>注入被拦截对象的一个字段的值</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-字段属性\"><a href=\"#10-字段属性\" class=\"headerlink\" title=\"10.字段属性\"></a>10.字段属性</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserType &#123;</span><br><span class=\"line\">  public String doSomething() &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface Interceptor &#123;</span><br><span class=\"line\">  String doSomethingElse();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface InterceptionAccessor &#123;</span><br><span class=\"line\">  Interceptor getInterceptor();</span><br><span class=\"line\">  void setInterceptor(Interceptor interceptor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface InstanceCreator &#123;</span><br><span class=\"line\">  Object makeInstance();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HelloWorldInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public String doSomethingElse() &#123;</span><br><span class=\"line\">    return &quot;Hello World!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class&lt;? extends UserType&gt; dynamicUserType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(UserType.class)</span><br><span class=\"line\">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class=\"line\">    .intercept(MethodDelegation.toField(&quot;interceptor&quot;)) // 拦截委托给属性字段 interceptor</span><br><span class=\"line\">  .defineField(&quot;interceptor&quot;, Interceptor.class, Visibility.PRIVATE) // 定义一个属性字段</span><br><span class=\"line\">  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty()) // 实现 InterceptionAccessor 接口</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded();</span><br><span class=\"line\">    </span><br><span class=\"line\">InstanceCreator factory = new ByteBuddy()</span><br><span class=\"line\">  .subclass(InstanceCreator.class)</span><br><span class=\"line\">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class=\"line\">    .intercept(MethodDelegation.toConstructor(dynamicUserType)) // 委托拦截的方法来调用提供的类型的构造函数</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(dynamicUserType.getClassLoader())</span><br><span class=\"line\">  .getLoaded().newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">UserType userType = (UserType) factory.makeInstance();</span><br><span class=\"line\">((InterceptionAccessor) userType).setInterceptor(new HelloWorldInterceptor());</span><br><span class=\"line\">String s = userType.doSomething();</span><br><span class=\"line\">System.out.println(s); // Hello World!</span><br></pre></td></tr></table></figure>\n\n<p>上述例子将 UserType 类实现了 InterceptionAccessor 接口，同时使用 MethodDelegation.toField 可以使拦截的方法可以委托给新增的字段。</p>\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"11-参考\"><a href=\"#11-参考\" class=\"headerlink\" title=\"11.参考\"></a>11.参考</h2><p><a href=\"https://juejin.cn/post/6844903965553852423\">https://juejin.cn/post/6844903965553852423</a><br><a href=\"https://www.cnblogs.com/yungyu16/p/13167240.html\">https://www.cnblogs.com/yungyu16/p/13167240.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字节码增强技术-Byte-Buddy\"><a href=\"#字节码增强技术-Byte-Buddy\" class=\"headerlink\" title=\"字节码增强技术-Byte Buddy\"></a>字节码增强技术-Byte Buddy</h1><h2 id=\"1-为什么需要在运行时生成代码？\"><a href=\"#1-为什么需要在运行时生成代码？\" class=\"headerlink\" title=\"1.为什么需要在运行时生成代码？\"></a>1.为什么需要在运行时生成代码？</h2><p>Java 是一个强类型语言系统，要求变量和对象都有一个确定的类型，不兼容类型赋值都会造成转换异常，通常情况下这种错误都会被编译器检查出来，<br>如此严格的类型在大多数情况下是比较令人满意的，这对构建具有非常强可读性和稳定性的应用有很大的帮助，这也是 Java 能在企业编程中的普及的一个原因之一。<br>然而，因为起强类型的检查，限制了其他领域语言应用范围。比如在编写一个框架是，通常我们并不知道应用程序定义的类型，因为当这个库被编译时， 我们还不知道这些类型，为了能在这种情况下能调用或者访问应用程序的方法或者变量，Java<br>类库提供了一套反射 API。使用这套反射 API， 我们就可以反省为知类型，进而调用方法或者访问属性。但是，Java 反射有如下缺点：</p>\n<ul>\n<li>需要执行一个相当昂贵的方法查找来获取描述特定方法的对象，因此，相比硬编码的方法调用，使用 反射 API 非常慢。</li>\n<li>反射 API 能绕过类型安全检查，可能会因为使用不当照成意想不到的问题，这样就错失了 Java 编程语言的一大特性。</li>\n</ul>\n<h2 id=\"2-简介\"><a href=\"#2-简介\" class=\"headerlink\" title=\"2.简介\"></a>2.简介</h2><p>正如官网说的：Byte Buddy 是一个代码生成和操作库，用于在Java应用程序运行时创建和修改Java类，而无需编译器的帮助。 除了Java类库附带的代码生成实用程序外，Byte<br>Buddy还允许创建任意类，并且不限于实现用于创建运行时代理的接口。 此外，Byte Buddy提供了一种方便的API，可以使用Java代理或在构建过程中手动更改类。Byte Buddy 相比其他字节码操作库有如下优势：</p>\n<ul>\n<li>无需理解字节码格式，即可操作，简单易行的 API 能很容易操作字节码。</li>\n<li>支持 Java 任何版本，库轻量，仅取决于Java字节代码解析器库ASM的访问者API，它本身不需要任何其他依赖项。</li>\n<li>比起JDK动态代理、cglib、Javassist，Byte Buddy在性能上具有优势。</li>\n</ul>\n<h3 id=\"3-性能\"><a href=\"#3-性能\" class=\"headerlink\" title=\"3.性能\"></a>3.性能</h3><p>在选择字节码操作库时，往往需要考虑库本身的性能。对于许多应用程序，生成代码的运行时特性更有可能确定最佳选择。而 在生成的代码本身的运行时间之外，用于创建动态类的运行时也是一个问题。官网对库进行了性能测试，给出以下结果图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/10/13/16dc4ade119d5610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"></p>\n<p>图中的每一行分别为，类的创建、接口实现、方法调用、类型扩展、父类方法调用的性能结果。 从性能报告中可以看出，Byte Buddy 的主要侧重点在于以最少的运行时生成代码，需要注意的是，我们这些衡量 Java 代码性能的测试， 都由 Java<br>虚拟机即时编译器优化过，如果你的代码只是偶尔运行，没有得到虚拟机的优化，可能性能会有所偏差。 所以我们在使用 Byte Buddy 开发时，我们希望监控这些指标，以避免在添加新功能时造成性能损失。</p>\n<h2 id=\"4-Hello-world代码\"><a href=\"#4-Hello-world代码\" class=\"headerlink\" title=\"4.Hello world代码\"></a>4.Hello world代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\"></span><br><span class=\"line\">        Object instance = dynamicType.newInstance();</span><br><span class=\"line\">        String toString = instance.toString();</span><br><span class=\"line\">        System.out.println(toString);</span><br><span class=\"line\">        System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n\n<p>从例子中看到，操作创建一个类如此的简单。正如 ByteBuddy 说明的，ByteBuddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性简单易行的 API， 可能能让你在初次使用的过程中就能不需要查阅 API<br>的前提下完成编码。这也真是 ByteBuddy 能完爆其他同类型库的一个原因。 上面的示例中使用的默认ByteBuddy配置会以最新版本的类文件格式创建Java类，该类文件格式可以被正在处理的Java虚拟机理解。 subclass<br>指定了新创建的类的父类，同时 method 指定了 Object 的 toString 方法，intercept 拦截了 toString 方法并返回固定的 value ， 最后 make 方法生产字节码，有类加载器加载到虚拟机中。<br>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理， 该代理允许在任何 Java<br>应用程序的运行期间进行代码转换，代理会在下篇单独写一篇文章讲解。</p>\n<h2 id=\"5-创建一个类\"><a href=\"#5-创建一个类\" class=\"headerlink\" title=\"5.创建一个类\"></a>5.创建一个类</h2><p>任何一个由 ByteBuddy 创建的类型都是通过 ByteBuddy 类的实例来完成的。通过简单地调用 new ByteBuddy() 就可以创建一个新实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Object.class)</span><br><span class=\"line\">    .make();</span><br></pre></td></tr></table></figure>\n\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的 。该列子没有命名动态生成的类型，但是在定义 Java<br>类时却是必须的，所以很容易的你会想到，ByteBuddy 会有默认的策略给我们生成。 当然，你也可以很容易地明确地命名这个类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">.subclass(Object.class)</span><br><span class=\"line\">.name(&quot;example.Type&quot;)</span><br><span class=\"line\">.make();</span><br></pre></td></tr></table></figure>\n\n<p>那么默认的策略是如何做的呢？这个将与 ByteBuddy 与 约定大于配置息息相关，它提供了我们认为比较全面的默认配置。 至于类型命名，ByteBuddy 的默认配置提供了<br>NamingStrategy，它基于动态类型的超类名称来随机生成类名。 此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 example.Foo， 那么生成的名称将会类似于<br>example.FooByteBuddy1376491271，这里的数字序列是随机的。</p>\n<p>此外，在一些需要指定类型的场景中，可以通过重写 NamingStrategy 的方法来实现，或者使用 ByteBuddy 内置的NamingStrategy.SuffixingRandom 来实现。</p>\n<p>同时需要注意的是，我们编码时需要遵守所谓的领域特定语言和不变性原则，这是说明意思呢？就是说在 ByteBuddy 中， 几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的。请看下面一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class=\"line\">byteBuddy.with(new NamingStrategy.SuffixingRandom(&quot;suffix&quot;));</span><br><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType1 = byteBuddy.subclass(Object.class).make();</span><br></pre></td></tr></table></figure>\n\n<p>上述例子你会发现类的命名策略还是默认的，其根本原因就是没有遵守上述原则导致的。所以在编码过程中要基于此原则进行。</p>\n<h2 id=\"6-加载类\"><a href=\"#6-加载类\" class=\"headerlink\" title=\"6.加载类\"></a>6.加载类</h2><p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码， 通过 DynamicType.Unloaded 中的 getBytes<br>方法你可以获取到该字节码，在你的应用程序中， 你可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法， 可以将类存储在给定的文件夹中； inject(File)<br>方法将类注入到现有的 Jar 文件中， 另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<p>WRAPPER：创建一个新的Wrapping类加载器 CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类 INJECTION：利用反射机制注入动态类型 示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; type = new ByteBuddy()</span><br><span class=\"line\">.subclass(Object.class)</span><br><span class=\"line\">.make()</span><br><span class=\"line\">.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">.getLoaded()</span><br></pre></td></tr></table></figure>\n\n<p>这样我们创建并加载了一个类。我们使用 WRAPPER 策略来加载适合大多数情况的类。getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类。</p>\n<p>重新加载类 得益于JVM的HostSwap特性，已加载的类可以被重新定义：</p>\n<p>// 安装Byte Buddy的Agent，除了通过-javaagent静态安装，还可以：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddyAgent.install();</span><br><span class=\"line\">Foo foo = new Foo();</span><br><span class=\"line\">    new ByteBuddy()</span><br><span class=\"line\">    .redefine(Bar.class)</span><br><span class=\"line\">    .name(Foo.class.getName())</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class=\"line\">    assertThat(foo.m(), is(&quot;bar&quot;));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，即使时已经存在的对象，也会受到类Reloading的影响。但是需要注意的是HostSwap具有限制：</p>\n<p>类再重新载入前后，必须具有相同的Schema，也就是方法、字段不能减少（可以增加） 不支持具有静态初始化块的类 修改类 redefine 重定义一个类时，Byte Buddy<br>可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。新添加的方法，如果签名和原有方法一致，则原有方法会消失。</p>\n<p>rebase 类似于redefine，但是原有的方法不会消失，而是被重命名，添加后缀 $original，这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法，例如类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    String bar() &#123; return &quot;bar&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rebase 之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    String bar() &#123; return &quot;foo&quot; + bar$original(); &#125;</span><br><span class=\"line\">    private String bar$original() &#123; return &quot;bar&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-方法拦截\"><a href=\"#7-方法拦截\" class=\"headerlink\" title=\"7.方法拦截\"></a>7.方法拦截</h2><p>通过匹配模式拦截 ByteBuddy 提供了很多用于匹配方法的 DSL，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Foo.class)</span><br><span class=\"line\">    // 匹配由Foo.class声明的方法</span><br><span class=\"line\">    .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">    // 匹配名为foo的方法</span><br><span class=\"line\">    .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">    // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">    .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(getClass().getClassLoader())</span><br><span class=\"line\">    .getLoaded()</span><br><span class=\"line\">    .newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略。库本身提供的 Matcher 非常多。Uploading file…</p>\n<h2 id=\"8-方法委托\"><a href=\"#8-方法委托\" class=\"headerlink\" title=\"8.方法委托\"></a>8.方法委托</h2><p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">    public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\">    public static String hello(String name) &#123;</span><br><span class=\"line\">        return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">    .subclass(Source.class)</span><br><span class=\"line\">    .method(named(&quot;hello&quot;)).intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">    .make()</span><br><span class=\"line\">    .load(getClass().getClassLoader())</span><br><span class=\"line\">    .getLoaded()</span><br><span class=\"line\">    .newInstance()</span><br><span class=\"line\">    .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">    public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">    public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">    public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<p>intercept(int)因为参数类型不匹配，直接Pass 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它 同时需要注意的是被拦截的方法需要声明为<br>public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RuntimeType</span><br><span class=\"line\">public static Object intercept(@RuntimeType Object value) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Invoked method with: &quot; + value);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-参数绑定\"><a href=\"#9-参数绑定\" class=\"headerlink\" title=\"9.参数绑定\"></a>9.参数绑定</h2><p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)复制代码</span><br><span class=\"line\">常用的注解如下表：</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Argument</td>\n<td>绑定单个参数</td>\n</tr>\n<tr>\n<td>@AllArguments</td>\n<td>绑定所有参数的数组</td>\n</tr>\n<tr>\n<td>@This</td>\n<td>当前被拦截的、动态生成的那个对象</td>\n</tr>\n<tr>\n<td>@DefaultCall</td>\n<td>调用默认方法而非super的方法</td>\n</tr>\n<tr>\n<td>@SuperCall</td>\n<td>用于调用父类版本的方法</td>\n</tr>\n<tr>\n<td>@RuntimeType</td>\n<td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>当前被拦截的、动态生成的那个对象的父类对象</td>\n</tr>\n<tr>\n<td>@FieldValue</td>\n<td>注入被拦截对象的一个字段的值</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-字段属性\"><a href=\"#10-字段属性\" class=\"headerlink\" title=\"10.字段属性\"></a>10.字段属性</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserType &#123;</span><br><span class=\"line\">  public String doSomething() &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface Interceptor &#123;</span><br><span class=\"line\">  String doSomethingElse();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface InterceptionAccessor &#123;</span><br><span class=\"line\">  Interceptor getInterceptor();</span><br><span class=\"line\">  void setInterceptor(Interceptor interceptor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface InstanceCreator &#123;</span><br><span class=\"line\">  Object makeInstance();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HelloWorldInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public String doSomethingElse() &#123;</span><br><span class=\"line\">    return &quot;Hello World!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class&lt;? extends UserType&gt; dynamicUserType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(UserType.class)</span><br><span class=\"line\">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class=\"line\">    .intercept(MethodDelegation.toField(&quot;interceptor&quot;)) // 拦截委托给属性字段 interceptor</span><br><span class=\"line\">  .defineField(&quot;interceptor&quot;, Interceptor.class, Visibility.PRIVATE) // 定义一个属性字段</span><br><span class=\"line\">  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty()) // 实现 InterceptionAccessor 接口</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded();</span><br><span class=\"line\">    </span><br><span class=\"line\">InstanceCreator factory = new ByteBuddy()</span><br><span class=\"line\">  .subclass(InstanceCreator.class)</span><br><span class=\"line\">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class=\"line\">    .intercept(MethodDelegation.toConstructor(dynamicUserType)) // 委托拦截的方法来调用提供的类型的构造函数</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(dynamicUserType.getClassLoader())</span><br><span class=\"line\">  .getLoaded().newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">UserType userType = (UserType) factory.makeInstance();</span><br><span class=\"line\">((InterceptionAccessor) userType).setInterceptor(new HelloWorldInterceptor());</span><br><span class=\"line\">String s = userType.doSomething();</span><br><span class=\"line\">System.out.println(s); // Hello World!</span><br></pre></td></tr></table></figure>\n\n<p>上述例子将 UserType 类实现了 InterceptionAccessor 接口，同时使用 MethodDelegation.toField 可以使拦截的方法可以委托给新增的字段。</p>\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"11-参考\"><a href=\"#11-参考\" class=\"headerlink\" title=\"11.参考\"></a>11.参考</h2><p><a href=\"https://juejin.cn/post/6844903965553852423\">https://juejin.cn/post/6844903965553852423</a><br><a href=\"https://www.cnblogs.com/yungyu16/p/13167240.html\">https://www.cnblogs.com/yungyu16/p/13167240.html</a></p>\n"},{"title":"bytebuddy实现aop","_content":"\n## 1.背景\n最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，\n网上找了一下bytebuddy相关资料，不少大佬写的不错的帖子就直接拿过来了，下方备注参考连接\n\n本文主要介绍 bytebuddy-aop相关操作\n\n## 2.ByteBuddy简介\n\nByte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。\n除了Java 类库附带的代码生成实用程序，Byte Buddy 允许创建任意类，并且不限于实现用于创建运行时代理的接口。\n此外，Byte Buddy 提供了一个方便的 API，用于手动、使用 Java 代理或在构建期间更改类。\n\n简单来说，ByteBuddy是一个可以在运行时动态生成java class的类库。在这篇文章中，\n我们将会使用ByteBuddy这个框架操作已经存在的类，创建指定的新类，甚至拦截方法调用。\n\n官网：https://bytebuddy.net/#/\n\n* 代码地址参考：https://github.com/wuhaocn/jcode-simple.git\n\n## 3.AOP注解实现\n### 3.1 依赖引入\n 依赖byte-buddy、byte-buddy-agent相关类\n\n```\ndependencies {\n  implementation group: 'net.bytebuddy', name: 'byte-buddy', version: '1.11.8'\n}\n\n```\n\n### 3.2 定义相关类\n定义 注解类、业务类、监听类;\n\n* 注解类\n\n```\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Monitor {\n}\n```\n\n* 业务类\n此处定义监控方法并加上Monitor注解\n```\npublic class BizAnnotationService {\n\t@Monitor\n    public int foo(int value) {\n        System.out.println(\"foo: \" + value);\n        return value;\n    }\n\n    public int bar(int value) {\n        System.out.println(\"bar: \" + value);\n        return value;\n    }\n}\n```\n* 监听类\n 实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务\n```\nclass MonitorAnnotationAdvisor {\n    @Advice.OnMethodEnter\n    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) {\n\t\tif (method.getAnnotation(Monitor.class) != null) {\n\t\t\tSystem.out.println(\"onMethodEnter \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n\t\t}\n    }\n\n    @Advice.OnMethodExit\n    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) {\n\t\tif (method.getAnnotation(Monitor.class) != null) {\n\t\t\tSystem.out.println(\"onMethodExit \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n\t\t}\n    }\n}\n```\n  \n* 测试类\n\n测试注解生效\n\n```\npublic class BizAnnotationTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBizAnnotationService service = new ByteBuddy()\n\t\t\t\t.subclass(BizAnnotationService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(Advice.to(MonitorAnnotationAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(BizAnnotationService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.bar(11111);\n\t\tservice.foo(99999);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:BizAnnotationTest.main()\nbar: 11111\nonMethodEnter foo with arguments: [99999]\nfoo: 99999\nonMethodExit foo with arguments: [99999]\n\n```\n\n\n## 4.AOP监听第三方组件\n### 4.1 定义相关类\n\n定义 业务类、监听类、测试类;\n\n主要原因是调用代码无法增加注解\n\n* 业务类\n  此处定义监控方法并加上未添加注解\n```\npublic class BizService {\n    public int foo(int value) {\n        System.out.println(\"foo: \" + value);\n        return value;\n    }\n\n    public int bar(int value) {\n        System.out.println(\"bar: \" + value);\n        return value;\n    }\n}\n```\n* 监听类\n  实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务\n```\nclass MonitorAdvisor {\n    @Advice.OnMethodEnter\n    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) {\n\t\tSystem.out.println(\"onMethodEnter \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n    }\n\n    @Advice.OnMethodExit\n    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) {\n\t\tSystem.out.println(\"onMethodExit \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments) + \" return: \" + ret);\n    }\n}\n```\n\n* 测试类\n\n测试不添加注解验证\n\n```\npublic class BizServiceTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBizService service = new ByteBuddy()\n\t\t\t\t.subclass(BizService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(Advice.to(MonitorAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(BizService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.bar(00000);\n\t\tservice.foo(99999);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:BizServiceTest.main()\nonMethodEnter bar with arguments: [11111]\nbar: 11111\nonMethodExit bar with arguments: [11111] return: 11111\nonMethodEnter foo with arguments: [99999]\nfoo: 99999\nonMethodExit foo with arguments: [99999] return: 99999\n```\n\n## 5.监控耗时\n### 5.1 定义相关类\n* 业务类\n耗时处理\n```\npublic class CostService {\n    public int play(int value) throws Exception {\n        System.out.println(\"foo: \" + value);\n        Thread.sleep(1000);\n        return value;\n    }\n\n}\n```\n\n* 监控类\n实现\t@RuntimeType通过 Object intercept(@SuperCall Callable<?> callable)返回处理结果\n```\npublic class CostMonitorAdvisor {\n\t@RuntimeType\n\tpublic static Object intercept(@SuperCall Callable<?> callable) throws Exception {\n\t\tlong start = System.currentTimeMillis();\n\t\ttry {\n\t\t\treturn callable.call();\n\t\t} finally {\n\t\t\tSystem.out.println(\"方法耗时：\" + (System.currentTimeMillis() - start) + \"ms\");\n\t\t}\n\t}\n}\n```\n\n* 测试类\n\n通过方法委托实现 ByteBuddy#intercept(MethodDelegation.to(CostMonitorAdvisor.class))\n\n```\npublic class CostServiceTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tCostService service = new ByteBuddy()\n\t\t\t\t.subclass(CostService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(MethodDelegation.to(CostMonitorAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(CostService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.play(11111);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:CostServiceTest.main()\nplay: 11111\n方法耗时：35ms\n\n```\n\n* 带参传递\n部分构造函数携带参数，这里以redis为例简单写了下带参数传递的类\n```\nByteBuddy byteBuddy = new ByteBuddy();\nClass aClass = byteBuddy.subclass(Jedis.class)\n        .method(ElementMatchers.any())\n        .intercept(MethodDelegation.to(RedisMonitorAdvisor.class))\n        .make()\n        .load(Jedis.class.getClassLoader())\n        .getLoaded();\nClass[] p = {String.class, int.class};\nConstructor<Jedis> classDeclaredConstructor = aClass.getDeclaredConstructor(p);\nJedis jedis = classDeclaredConstructor.newInstance(\"10.3.4.111\", 6379);\n        \n```\n\n\n\n## 6.总结\n\n* 通过ByteBuddy创建实例，并注入切面可实现横切\n    * 可执行onMethodEnter onMethodExit相关操作\n    * RuntimeType监听方法耗时\n* 对象创建需要通过ByteBuddy创建，自己创建类无法实现\n\n* 无法监控静态对象\n\n## 7.注解含义\n\n 注解 |\t说明\n-----|-----\n@Argument\t| 绑定单个参数\n@AllArguments |\t绑定所有参数的数组\n@This\t| 当前被拦截的、动态生成的那个对象\n@Super\t| 当前被拦截的、动态生成的那个对象的父类对象\n@Origin\t| 可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String 动态类的toString()的返回值 int 动态方法的修饰符\n@DefaultCall  |\t调用默认方法而非super的方法\n@SuperCall  |\t用于调用父类版本的方法\n@Super  |\t注入父类型对象，可以是接口，从而调用它的任何方法\n@RuntimeType  |\t可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n@Empty  |\t注入参数的类型的默认值\n@StubValue  |\t注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0\n@FieldValue  |\t注入被拦截对象的一个字段的值\n@Morph |\t类似于@SuperCall，但是允许指定调用参数\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 8.参考\n\nhttps://zhuanlan.zhihu.com/p/151843984\nhttps://bytebuddy.net/#/\nhttps://www.jianshu.com/p/be2efc2b0e4c\nhttps://blog.csdn.net/generalfu/article/details/106086475","source":"_posts/language/字节码/bytebuddy-aop.md","raw":"---\ntitle: bytebuddy实现aop\ncategories:\n- java\n---\n\n## 1.背景\n最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，\n网上找了一下bytebuddy相关资料，不少大佬写的不错的帖子就直接拿过来了，下方备注参考连接\n\n本文主要介绍 bytebuddy-aop相关操作\n\n## 2.ByteBuddy简介\n\nByte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。\n除了Java 类库附带的代码生成实用程序，Byte Buddy 允许创建任意类，并且不限于实现用于创建运行时代理的接口。\n此外，Byte Buddy 提供了一个方便的 API，用于手动、使用 Java 代理或在构建期间更改类。\n\n简单来说，ByteBuddy是一个可以在运行时动态生成java class的类库。在这篇文章中，\n我们将会使用ByteBuddy这个框架操作已经存在的类，创建指定的新类，甚至拦截方法调用。\n\n官网：https://bytebuddy.net/#/\n\n* 代码地址参考：https://github.com/wuhaocn/jcode-simple.git\n\n## 3.AOP注解实现\n### 3.1 依赖引入\n 依赖byte-buddy、byte-buddy-agent相关类\n\n```\ndependencies {\n  implementation group: 'net.bytebuddy', name: 'byte-buddy', version: '1.11.8'\n}\n\n```\n\n### 3.2 定义相关类\n定义 注解类、业务类、监听类;\n\n* 注解类\n\n```\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Monitor {\n}\n```\n\n* 业务类\n此处定义监控方法并加上Monitor注解\n```\npublic class BizAnnotationService {\n\t@Monitor\n    public int foo(int value) {\n        System.out.println(\"foo: \" + value);\n        return value;\n    }\n\n    public int bar(int value) {\n        System.out.println(\"bar: \" + value);\n        return value;\n    }\n}\n```\n* 监听类\n 实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务\n```\nclass MonitorAnnotationAdvisor {\n    @Advice.OnMethodEnter\n    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) {\n\t\tif (method.getAnnotation(Monitor.class) != null) {\n\t\t\tSystem.out.println(\"onMethodEnter \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n\t\t}\n    }\n\n    @Advice.OnMethodExit\n    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) {\n\t\tif (method.getAnnotation(Monitor.class) != null) {\n\t\t\tSystem.out.println(\"onMethodExit \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n\t\t}\n    }\n}\n```\n  \n* 测试类\n\n测试注解生效\n\n```\npublic class BizAnnotationTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBizAnnotationService service = new ByteBuddy()\n\t\t\t\t.subclass(BizAnnotationService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(Advice.to(MonitorAnnotationAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(BizAnnotationService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.bar(11111);\n\t\tservice.foo(99999);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:BizAnnotationTest.main()\nbar: 11111\nonMethodEnter foo with arguments: [99999]\nfoo: 99999\nonMethodExit foo with arguments: [99999]\n\n```\n\n\n## 4.AOP监听第三方组件\n### 4.1 定义相关类\n\n定义 业务类、监听类、测试类;\n\n主要原因是调用代码无法增加注解\n\n* 业务类\n  此处定义监控方法并加上未添加注解\n```\npublic class BizService {\n    public int foo(int value) {\n        System.out.println(\"foo: \" + value);\n        return value;\n    }\n\n    public int bar(int value) {\n        System.out.println(\"bar: \" + value);\n        return value;\n    }\n}\n```\n* 监听类\n  实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务\n```\nclass MonitorAdvisor {\n    @Advice.OnMethodEnter\n    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) {\n\t\tSystem.out.println(\"onMethodEnter \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments));\n    }\n\n    @Advice.OnMethodExit\n    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) {\n\t\tSystem.out.println(\"onMethodExit \" + method.getName() + \" with arguments: \" + Arrays.toString(arguments) + \" return: \" + ret);\n    }\n}\n```\n\n* 测试类\n\n测试不添加注解验证\n\n```\npublic class BizServiceTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBizService service = new ByteBuddy()\n\t\t\t\t.subclass(BizService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(Advice.to(MonitorAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(BizService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.bar(00000);\n\t\tservice.foo(99999);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:BizServiceTest.main()\nonMethodEnter bar with arguments: [11111]\nbar: 11111\nonMethodExit bar with arguments: [11111] return: 11111\nonMethodEnter foo with arguments: [99999]\nfoo: 99999\nonMethodExit foo with arguments: [99999] return: 99999\n```\n\n## 5.监控耗时\n### 5.1 定义相关类\n* 业务类\n耗时处理\n```\npublic class CostService {\n    public int play(int value) throws Exception {\n        System.out.println(\"foo: \" + value);\n        Thread.sleep(1000);\n        return value;\n    }\n\n}\n```\n\n* 监控类\n实现\t@RuntimeType通过 Object intercept(@SuperCall Callable<?> callable)返回处理结果\n```\npublic class CostMonitorAdvisor {\n\t@RuntimeType\n\tpublic static Object intercept(@SuperCall Callable<?> callable) throws Exception {\n\t\tlong start = System.currentTimeMillis();\n\t\ttry {\n\t\t\treturn callable.call();\n\t\t} finally {\n\t\t\tSystem.out.println(\"方法耗时：\" + (System.currentTimeMillis() - start) + \"ms\");\n\t\t}\n\t}\n}\n```\n\n* 测试类\n\n通过方法委托实现 ByteBuddy#intercept(MethodDelegation.to(CostMonitorAdvisor.class))\n\n```\npublic class CostServiceTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tCostService service = new ByteBuddy()\n\t\t\t\t.subclass(CostService.class)\n\t\t\t\t.method(ElementMatchers.any())\n\t\t\t\t.intercept(MethodDelegation.to(CostMonitorAdvisor.class))\n\t\t\t\t.make()\n\t\t\t\t.load(CostService.class.getClassLoader())\n\t\t\t\t.getLoaded()\n\t\t\t\t.newInstance();\n\t\tservice.play(11111);\n\t}\n\n}\n```\n\n* 结果输出\n\n```\n> Task :code-gen:bytebuddy:CostServiceTest.main()\nplay: 11111\n方法耗时：35ms\n\n```\n\n* 带参传递\n部分构造函数携带参数，这里以redis为例简单写了下带参数传递的类\n```\nByteBuddy byteBuddy = new ByteBuddy();\nClass aClass = byteBuddy.subclass(Jedis.class)\n        .method(ElementMatchers.any())\n        .intercept(MethodDelegation.to(RedisMonitorAdvisor.class))\n        .make()\n        .load(Jedis.class.getClassLoader())\n        .getLoaded();\nClass[] p = {String.class, int.class};\nConstructor<Jedis> classDeclaredConstructor = aClass.getDeclaredConstructor(p);\nJedis jedis = classDeclaredConstructor.newInstance(\"10.3.4.111\", 6379);\n        \n```\n\n\n\n## 6.总结\n\n* 通过ByteBuddy创建实例，并注入切面可实现横切\n    * 可执行onMethodEnter onMethodExit相关操作\n    * RuntimeType监听方法耗时\n* 对象创建需要通过ByteBuddy创建，自己创建类无法实现\n\n* 无法监控静态对象\n\n## 7.注解含义\n\n 注解 |\t说明\n-----|-----\n@Argument\t| 绑定单个参数\n@AllArguments |\t绑定所有参数的数组\n@This\t| 当前被拦截的、动态生成的那个对象\n@Super\t| 当前被拦截的、动态生成的那个对象的父类对象\n@Origin\t| 可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String 动态类的toString()的返回值 int 动态方法的修饰符\n@DefaultCall  |\t调用默认方法而非super的方法\n@SuperCall  |\t用于调用父类版本的方法\n@Super  |\t注入父类型对象，可以是接口，从而调用它的任何方法\n@RuntimeType  |\t可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n@Empty  |\t注入参数的类型的默认值\n@StubValue  |\t注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0\n@FieldValue  |\t注入被拦截对象的一个字段的值\n@Morph |\t类似于@SuperCall，但是允许指定调用参数\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 8.参考\n\nhttps://zhuanlan.zhihu.com/p/151843984\nhttps://bytebuddy.net/#/\nhttps://www.jianshu.com/p/be2efc2b0e4c\nhttps://blog.csdn.net/generalfu/article/details/106086475","slug":"language/字节码/bytebuddy-aop","published":1,"date":"2021-07-31T08:59:47.000Z","updated":"2021-07-31T08:59:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2br0003y2ukec922snv","content":"<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1.背景\"></a>1.背景</h2><p>最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，<br>网上找了一下bytebuddy相关资料，不少大佬写的不错的帖子就直接拿过来了，下方备注参考连接</p>\n<p>本文主要介绍 bytebuddy-aop相关操作</p>\n<h2 id=\"2-ByteBuddy简介\"><a href=\"#2-ByteBuddy简介\" class=\"headerlink\" title=\"2.ByteBuddy简介\"></a>2.ByteBuddy简介</h2><p>Byte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。<br>除了Java 类库附带的代码生成实用程序，Byte Buddy 允许创建任意类，并且不限于实现用于创建运行时代理的接口。<br>此外，Byte Buddy 提供了一个方便的 API，用于手动、使用 Java 代理或在构建期间更改类。</p>\n<p>简单来说，ByteBuddy是一个可以在运行时动态生成java class的类库。在这篇文章中，<br>我们将会使用ByteBuddy这个框架操作已经存在的类，创建指定的新类，甚至拦截方法调用。</p>\n<p>官网：<a href=\"https://bytebuddy.net/#/\">https://bytebuddy.net/#/</a></p>\n<ul>\n<li>代码地址参考：<a href=\"https://github.com/wuhaocn/jcode-simple.git\">https://github.com/wuhaocn/jcode-simple.git</a></li>\n</ul>\n<h2 id=\"3-AOP注解实现\"><a href=\"#3-AOP注解实现\" class=\"headerlink\" title=\"3.AOP注解实现\"></a>3.AOP注解实现</h2><h3 id=\"3-1-依赖引入\"><a href=\"#3-1-依赖引入\" class=\"headerlink\" title=\"3.1 依赖引入\"></a>3.1 依赖引入</h3><p> 依赖byte-buddy、byte-buddy-agent相关类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-定义相关类\"><a href=\"#3-2-定义相关类\" class=\"headerlink\" title=\"3.2 定义相关类\"></a>3.2 定义相关类</h3><p>定义 注解类、业务类、监听类;</p>\n<ul>\n<li>注解类</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface Monitor &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>业务类<br>此处定义监控方法并加上Monitor注解<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizAnnotationService &#123;</span><br><span class=\"line\">\t@Monitor</span><br><span class=\"line\">    public int foo(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int bar(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;bar: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MonitorAnnotationAdvisor &#123;</span><br><span class=\"line\">    @Advice.OnMethodEnter</span><br><span class=\"line\">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class=\"line\">\t\tif (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Advice.OnMethodExit</span><br><span class=\"line\">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class=\"line\">\t\tif (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>测试类</li>\n</ul>\n<p>测试注解生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizAnnotationTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tBizAnnotationService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(BizAnnotationService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(Advice.to(MonitorAnnotationAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(BizAnnotationService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.bar(11111);</span><br><span class=\"line\">\t\tservice.foo(99999);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:BizAnnotationTest.main()</span><br><span class=\"line\">bar: 11111</span><br><span class=\"line\">onMethodEnter foo with arguments: [99999]</span><br><span class=\"line\">foo: 99999</span><br><span class=\"line\">onMethodExit foo with arguments: [99999]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-AOP监听第三方组件\"><a href=\"#4-AOP监听第三方组件\" class=\"headerlink\" title=\"4.AOP监听第三方组件\"></a>4.AOP监听第三方组件</h2><h3 id=\"4-1-定义相关类\"><a href=\"#4-1-定义相关类\" class=\"headerlink\" title=\"4.1 定义相关类\"></a>4.1 定义相关类</h3><p>定义 业务类、监听类、测试类;</p>\n<p>主要原因是调用代码无法增加注解</p>\n<ul>\n<li><p>业务类<br>此处定义监控方法并加上未添加注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizService &#123;</span><br><span class=\"line\">    public int foo(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int bar(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;bar: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MonitorAdvisor &#123;</span><br><span class=\"line\">    @Advice.OnMethodEnter</span><br><span class=\"line\">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Advice.OnMethodExit</span><br><span class=\"line\">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments) + &quot; return: &quot; + ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>测试类</p>\n</li>\n</ul>\n<p>测试不添加注解验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizServiceTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tBizService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(BizService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(Advice.to(MonitorAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(BizService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.bar(00000);</span><br><span class=\"line\">\t\tservice.foo(99999);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:BizServiceTest.main()</span><br><span class=\"line\">onMethodEnter bar with arguments: [11111]</span><br><span class=\"line\">bar: 11111</span><br><span class=\"line\">onMethodExit bar with arguments: [11111] return: 11111</span><br><span class=\"line\">onMethodEnter foo with arguments: [99999]</span><br><span class=\"line\">foo: 99999</span><br><span class=\"line\">onMethodExit foo with arguments: [99999] return: 99999</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-监控耗时\"><a href=\"#5-监控耗时\" class=\"headerlink\" title=\"5.监控耗时\"></a>5.监控耗时</h2><h3 id=\"5-1-定义相关类\"><a href=\"#5-1-定义相关类\" class=\"headerlink\" title=\"5.1 定义相关类\"></a>5.1 定义相关类</h3><ul>\n<li><p>业务类<br>耗时处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostService &#123;</span><br><span class=\"line\">    public int play(int value) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>监控类<br>实现    @RuntimeType通过 Object intercept(@SuperCall Callable&lt;?&gt; callable)返回处理结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostMonitorAdvisor &#123;</span><br><span class=\"line\">\t@RuntimeType</span><br><span class=\"line\">\tpublic static Object intercept(@SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn callable.call();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;方法耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>测试类</p>\n</li>\n</ul>\n<p>通过方法委托实现 ByteBuddy#intercept(MethodDelegation.to(CostMonitorAdvisor.class))</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostServiceTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tCostService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(CostService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(MethodDelegation.to(CostMonitorAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(CostService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.play(11111);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:CostServiceTest.main()</span><br><span class=\"line\">play: 11111</span><br><span class=\"line\">方法耗时：35ms</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>带参传递<br>部分构造函数携带参数，这里以redis为例简单写了下带参数传递的类<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class=\"line\">Class aClass = byteBuddy.subclass(Jedis.class)</span><br><span class=\"line\">        .method(ElementMatchers.any())</span><br><span class=\"line\">        .intercept(MethodDelegation.to(RedisMonitorAdvisor.class))</span><br><span class=\"line\">        .make()</span><br><span class=\"line\">        .load(Jedis.class.getClassLoader())</span><br><span class=\"line\">        .getLoaded();</span><br><span class=\"line\">Class[] p = &#123;String.class, int.class&#125;;</span><br><span class=\"line\">Constructor&lt;Jedis&gt; classDeclaredConstructor = aClass.getDeclaredConstructor(p);</span><br><span class=\"line\">Jedis jedis = classDeclaredConstructor.newInstance(&quot;10.3.4.111&quot;, 6379);</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h2><ul>\n<li><p>通过ByteBuddy创建实例，并注入切面可实现横切</p>\n<ul>\n<li>可执行onMethodEnter onMethodExit相关操作</li>\n<li>RuntimeType监听方法耗时</li>\n</ul>\n</li>\n<li><p>对象创建需要通过ByteBuddy创建，自己创建类无法实现</p>\n</li>\n<li><p>无法监控静态对象</p>\n</li>\n</ul>\n<h2 id=\"7-注解含义\"><a href=\"#7-注解含义\" class=\"headerlink\" title=\"7.注解含义\"></a>7.注解含义</h2><table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Argument</td>\n<td>绑定单个参数</td>\n</tr>\n<tr>\n<td>@AllArguments</td>\n<td>绑定所有参数的数组</td>\n</tr>\n<tr>\n<td>@This</td>\n<td>当前被拦截的、动态生成的那个对象</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>当前被拦截的、动态生成的那个对象的父类对象</td>\n</tr>\n<tr>\n<td>@Origin</td>\n<td>可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String 动态类的toString()的返回值 int 动态方法的修饰符</td>\n</tr>\n<tr>\n<td>@DefaultCall</td>\n<td>调用默认方法而非super的方法</td>\n</tr>\n<tr>\n<td>@SuperCall</td>\n<td>用于调用父类版本的方法</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>注入父类型对象，可以是接口，从而调用它的任何方法</td>\n</tr>\n<tr>\n<td>@RuntimeType</td>\n<td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td>\n</tr>\n<tr>\n<td>@Empty</td>\n<td>注入参数的类型的默认值</td>\n</tr>\n<tr>\n<td>@StubValue</td>\n<td>注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0</td>\n</tr>\n<tr>\n<td>@FieldValue</td>\n<td>注入被拦截对象的一个字段的值</td>\n</tr>\n<tr>\n<td>@Morph</td>\n<td>类似于@SuperCall，但是允许指定调用参数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"8-参考\"><a href=\"#8-参考\" class=\"headerlink\" title=\"8.参考\"></a>8.参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/151843984\">https://zhuanlan.zhihu.com/p/151843984</a><br><a href=\"https://bytebuddy.net/#/\">https://bytebuddy.net/#/</a><br><a href=\"https://www.jianshu.com/p/be2efc2b0e4c\">https://www.jianshu.com/p/be2efc2b0e4c</a><br><a href=\"https://blog.csdn.net/generalfu/article/details/106086475\">https://blog.csdn.net/generalfu/article/details/106086475</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1.背景\"></a>1.背景</h2><p>最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，<br>网上找了一下bytebuddy相关资料，不少大佬写的不错的帖子就直接拿过来了，下方备注参考连接</p>\n<p>本文主要介绍 bytebuddy-aop相关操作</p>\n<h2 id=\"2-ByteBuddy简介\"><a href=\"#2-ByteBuddy简介\" class=\"headerlink\" title=\"2.ByteBuddy简介\"></a>2.ByteBuddy简介</h2><p>Byte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。<br>除了Java 类库附带的代码生成实用程序，Byte Buddy 允许创建任意类，并且不限于实现用于创建运行时代理的接口。<br>此外，Byte Buddy 提供了一个方便的 API，用于手动、使用 Java 代理或在构建期间更改类。</p>\n<p>简单来说，ByteBuddy是一个可以在运行时动态生成java class的类库。在这篇文章中，<br>我们将会使用ByteBuddy这个框架操作已经存在的类，创建指定的新类，甚至拦截方法调用。</p>\n<p>官网：<a href=\"https://bytebuddy.net/#/\">https://bytebuddy.net/#/</a></p>\n<ul>\n<li>代码地址参考：<a href=\"https://github.com/wuhaocn/jcode-simple.git\">https://github.com/wuhaocn/jcode-simple.git</a></li>\n</ul>\n<h2 id=\"3-AOP注解实现\"><a href=\"#3-AOP注解实现\" class=\"headerlink\" title=\"3.AOP注解实现\"></a>3.AOP注解实现</h2><h3 id=\"3-1-依赖引入\"><a href=\"#3-1-依赖引入\" class=\"headerlink\" title=\"3.1 依赖引入\"></a>3.1 依赖引入</h3><p> 依赖byte-buddy、byte-buddy-agent相关类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-定义相关类\"><a href=\"#3-2-定义相关类\" class=\"headerlink\" title=\"3.2 定义相关类\"></a>3.2 定义相关类</h3><p>定义 注解类、业务类、监听类;</p>\n<ul>\n<li>注解类</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface Monitor &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>业务类<br>此处定义监控方法并加上Monitor注解<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizAnnotationService &#123;</span><br><span class=\"line\">\t@Monitor</span><br><span class=\"line\">    public int foo(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int bar(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;bar: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MonitorAnnotationAdvisor &#123;</span><br><span class=\"line\">    @Advice.OnMethodEnter</span><br><span class=\"line\">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class=\"line\">\t\tif (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Advice.OnMethodExit</span><br><span class=\"line\">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class=\"line\">\t\tif (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>测试类</li>\n</ul>\n<p>测试注解生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizAnnotationTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tBizAnnotationService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(BizAnnotationService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(Advice.to(MonitorAnnotationAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(BizAnnotationService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.bar(11111);</span><br><span class=\"line\">\t\tservice.foo(99999);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:BizAnnotationTest.main()</span><br><span class=\"line\">bar: 11111</span><br><span class=\"line\">onMethodEnter foo with arguments: [99999]</span><br><span class=\"line\">foo: 99999</span><br><span class=\"line\">onMethodExit foo with arguments: [99999]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-AOP监听第三方组件\"><a href=\"#4-AOP监听第三方组件\" class=\"headerlink\" title=\"4.AOP监听第三方组件\"></a>4.AOP监听第三方组件</h2><h3 id=\"4-1-定义相关类\"><a href=\"#4-1-定义相关类\" class=\"headerlink\" title=\"4.1 定义相关类\"></a>4.1 定义相关类</h3><p>定义 业务类、监听类、测试类;</p>\n<p>主要原因是调用代码无法增加注解</p>\n<ul>\n<li><p>业务类<br>此处定义监控方法并加上未添加注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizService &#123;</span><br><span class=\"line\">    public int foo(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int bar(int value) &#123;</span><br><span class=\"line\">        System.out.println(&quot;bar: &quot; + value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MonitorAdvisor &#123;</span><br><span class=\"line\">    @Advice.OnMethodEnter</span><br><span class=\"line\">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Advice.OnMethodExit</span><br><span class=\"line\">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments) + &quot; return: &quot; + ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>测试类</p>\n</li>\n</ul>\n<p>测试不添加注解验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BizServiceTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tBizService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(BizService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(Advice.to(MonitorAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(BizService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.bar(00000);</span><br><span class=\"line\">\t\tservice.foo(99999);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:BizServiceTest.main()</span><br><span class=\"line\">onMethodEnter bar with arguments: [11111]</span><br><span class=\"line\">bar: 11111</span><br><span class=\"line\">onMethodExit bar with arguments: [11111] return: 11111</span><br><span class=\"line\">onMethodEnter foo with arguments: [99999]</span><br><span class=\"line\">foo: 99999</span><br><span class=\"line\">onMethodExit foo with arguments: [99999] return: 99999</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-监控耗时\"><a href=\"#5-监控耗时\" class=\"headerlink\" title=\"5.监控耗时\"></a>5.监控耗时</h2><h3 id=\"5-1-定义相关类\"><a href=\"#5-1-定义相关类\" class=\"headerlink\" title=\"5.1 定义相关类\"></a>5.1 定义相关类</h3><ul>\n<li><p>业务类<br>耗时处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostService &#123;</span><br><span class=\"line\">    public int play(int value) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;foo: &quot; + value);</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>监控类<br>实现    @RuntimeType通过 Object intercept(@SuperCall Callable&lt;?&gt; callable)返回处理结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostMonitorAdvisor &#123;</span><br><span class=\"line\">\t@RuntimeType</span><br><span class=\"line\">\tpublic static Object intercept(@SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn callable.call();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;方法耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>测试类</p>\n</li>\n</ul>\n<p>通过方法委托实现 ByteBuddy#intercept(MethodDelegation.to(CostMonitorAdvisor.class))</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CostServiceTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tCostService service = new ByteBuddy()</span><br><span class=\"line\">\t\t\t\t.subclass(CostService.class)</span><br><span class=\"line\">\t\t\t\t.method(ElementMatchers.any())</span><br><span class=\"line\">\t\t\t\t.intercept(MethodDelegation.to(CostMonitorAdvisor.class))</span><br><span class=\"line\">\t\t\t\t.make()</span><br><span class=\"line\">\t\t\t\t.load(CostService.class.getClassLoader())</span><br><span class=\"line\">\t\t\t\t.getLoaded()</span><br><span class=\"line\">\t\t\t\t.newInstance();</span><br><span class=\"line\">\t\tservice.play(11111);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Task :code-gen:bytebuddy:CostServiceTest.main()</span><br><span class=\"line\">play: 11111</span><br><span class=\"line\">方法耗时：35ms</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>带参传递<br>部分构造函数携带参数，这里以redis为例简单写了下带参数传递的类<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class=\"line\">Class aClass = byteBuddy.subclass(Jedis.class)</span><br><span class=\"line\">        .method(ElementMatchers.any())</span><br><span class=\"line\">        .intercept(MethodDelegation.to(RedisMonitorAdvisor.class))</span><br><span class=\"line\">        .make()</span><br><span class=\"line\">        .load(Jedis.class.getClassLoader())</span><br><span class=\"line\">        .getLoaded();</span><br><span class=\"line\">Class[] p = &#123;String.class, int.class&#125;;</span><br><span class=\"line\">Constructor&lt;Jedis&gt; classDeclaredConstructor = aClass.getDeclaredConstructor(p);</span><br><span class=\"line\">Jedis jedis = classDeclaredConstructor.newInstance(&quot;10.3.4.111&quot;, 6379);</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h2><ul>\n<li><p>通过ByteBuddy创建实例，并注入切面可实现横切</p>\n<ul>\n<li>可执行onMethodEnter onMethodExit相关操作</li>\n<li>RuntimeType监听方法耗时</li>\n</ul>\n</li>\n<li><p>对象创建需要通过ByteBuddy创建，自己创建类无法实现</p>\n</li>\n<li><p>无法监控静态对象</p>\n</li>\n</ul>\n<h2 id=\"7-注解含义\"><a href=\"#7-注解含义\" class=\"headerlink\" title=\"7.注解含义\"></a>7.注解含义</h2><table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Argument</td>\n<td>绑定单个参数</td>\n</tr>\n<tr>\n<td>@AllArguments</td>\n<td>绑定所有参数的数组</td>\n</tr>\n<tr>\n<td>@This</td>\n<td>当前被拦截的、动态生成的那个对象</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>当前被拦截的、动态生成的那个对象的父类对象</td>\n</tr>\n<tr>\n<td>@Origin</td>\n<td>可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String 动态类的toString()的返回值 int 动态方法的修饰符</td>\n</tr>\n<tr>\n<td>@DefaultCall</td>\n<td>调用默认方法而非super的方法</td>\n</tr>\n<tr>\n<td>@SuperCall</td>\n<td>用于调用父类版本的方法</td>\n</tr>\n<tr>\n<td>@Super</td>\n<td>注入父类型对象，可以是接口，从而调用它的任何方法</td>\n</tr>\n<tr>\n<td>@RuntimeType</td>\n<td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td>\n</tr>\n<tr>\n<td>@Empty</td>\n<td>注入参数的类型的默认值</td>\n</tr>\n<tr>\n<td>@StubValue</td>\n<td>注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0</td>\n</tr>\n<tr>\n<td>@FieldValue</td>\n<td>注入被拦截对象的一个字段的值</td>\n</tr>\n<tr>\n<td>@Morph</td>\n<td>类似于@SuperCall，但是允许指定调用参数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"8-参考\"><a href=\"#8-参考\" class=\"headerlink\" title=\"8.参考\"></a>8.参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/151843984\">https://zhuanlan.zhihu.com/p/151843984</a><br><a href=\"https://bytebuddy.net/#/\">https://bytebuddy.net/#/</a><br><a href=\"https://www.jianshu.com/p/be2efc2b0e4c\">https://www.jianshu.com/p/be2efc2b0e4c</a><br><a href=\"https://blog.csdn.net/generalfu/article/details/106086475\">https://blog.csdn.net/generalfu/article/details/106086475</a></p>\n"},{"title":"java字节码增强","_content":"\n## Java 字节码增强探秘\n\n### 1.字节码\n\n#### 1.1 什么是字节码？\n\nJava 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，\n都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。因此，也可以看出字节码对于 Java 生态的重要性。\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。\n在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如图 1 所示。\n![](https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXqfPalgmiaaEZfk4KZOLicKFDrLKCYe5sPz3eKut7ryeKrerKgBPLaFQamge0TibUBpIjicibpucrO5Lg/640)\n\n\n对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。\n另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，\n只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，\n可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。\n本文重点着眼于字节码增强技术，从字节码开始逐层向上，由 JVM 字节码操作集合到 Java 中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。\n\n## 参考\n","source":"_posts/language/字节码/java字节码增强.md","raw":"---\ntitle: java字节码增强\ncategories:\n- java\n---\n\n## Java 字节码增强探秘\n\n### 1.字节码\n\n#### 1.1 什么是字节码？\n\nJava 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，\n都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。因此，也可以看出字节码对于 Java 生态的重要性。\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。\n在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如图 1 所示。\n![](https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXqfPalgmiaaEZfk4KZOLicKFDrLKCYe5sPz3eKut7ryeKrerKgBPLaFQamge0TibUBpIjicibpucrO5Lg/640)\n\n\n对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。\n另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，\n只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，\n可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。\n本文重点着眼于字节码增强技术，从字节码开始逐层向上，由 JVM 字节码操作集合到 Java 中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。\n\n## 参考\n","slug":"language/字节码/java字节码增强","published":1,"date":"2021-07-31T09:06:30.833Z","updated":"2021-07-31T09:06:30.833Z","_id":"ckrrjv2bs0004y2uk0fi83apj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Java-字节码增强探秘\"><a href=\"#Java-字节码增强探秘\" class=\"headerlink\" title=\"Java 字节码增强探秘\"></a>Java 字节码增强探秘</h2><h3 id=\"1-字节码\"><a href=\"#1-字节码\" class=\"headerlink\" title=\"1.字节码\"></a>1.字节码</h3><h4 id=\"1-1-什么是字节码？\"><a href=\"#1-1-什么是字节码？\" class=\"headerlink\" title=\"1.1 什么是字节码？\"></a>1.1 什么是字节码？</h4><p>Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，<br>都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。因此，也可以看出字节码对于 Java 生态的重要性。<br>之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。<br>在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如图 1 所示。<br><img src=\"https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXqfPalgmiaaEZfk4KZOLicKFDrLKCYe5sPz3eKut7ryeKrerKgBPLaFQamge0TibUBpIjicibpucrO5Lg/640\"></p>\n<p>对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。<br>另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，<br>只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，<br>可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。<br>本文重点着眼于字节码增强技术，从字节码开始逐层向上，由 JVM 字节码操作集合到 Java 中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java-字节码增强探秘\"><a href=\"#Java-字节码增强探秘\" class=\"headerlink\" title=\"Java 字节码增强探秘\"></a>Java 字节码增强探秘</h2><h3 id=\"1-字节码\"><a href=\"#1-字节码\" class=\"headerlink\" title=\"1.字节码\"></a>1.字节码</h3><h4 id=\"1-1-什么是字节码？\"><a href=\"#1-1-什么是字节码？\" class=\"headerlink\" title=\"1.1 什么是字节码？\"></a>1.1 什么是字节码？</h4><p>Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，<br>都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。因此，也可以看出字节码对于 Java 生态的重要性。<br>之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。<br>在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如图 1 所示。<br><img src=\"https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXqfPalgmiaaEZfk4KZOLicKFDrLKCYe5sPz3eKut7ryeKrerKgBPLaFQamge0TibUBpIjicibpucrO5Lg/640\"></p>\n<p>对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。<br>另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，<br>只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，<br>可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。<br>本文重点着眼于字节码增强技术，从字节码开始逐层向上，由 JVM 字节码操作集合到 Java 中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>"},{"title":"JVM优秀文章","_content":"\n\n# JVM G1 算法系列\n\n- [G1 垃圾收集器介绍](https://www.jianshu.com/p/0f1f5adffdc1)\n- [G1 垃圾收集器之 RSet](https://www.jianshu.com/p/870abddaba41)\n- [G1 垃圾收集器之 SATB](https://www.jianshu.com/p/9e70097807ba)\n- [G1 垃圾收集器之对象分配过程](https://www.jianshu.com/p/a0efa489b99f)\n\n# ZGC 系列\n\n- [ZGC，一个超乎想象的垃圾收集器](https://www.jianshu.com/p/6f89fd5842bf)\n- [ZGC 什么时候进行垃圾回收](https://www.jianshu.com/p/b5fb06ffbb90)\n\n# JVM 源码分析系列\n\n- [深入分析 Object.finalize 方法的实现原理](https://www.jianshu.com/p/9d2788fffd5f)\n- [JVM 源码分析之 Object.wait/notify 实现](https://www.jianshu.com/p/f4454164c017)\n- [JVM 源码分析之 java 对象头实现](https://www.jianshu.com/p/9c19eb0ea4d8)\n- [JVM 源码分析之 synchronized 实现](https://www.jianshu.com/p/c5058b6fe8e5)\n- [JVM 源码分析之 Java 类的加载过程](https://www.jianshu.com/p/252e27863822)\n- [JVM 源码分析之 Java 对象的创建过程](https://www.jianshu.com/p/0009aaac16ed)\n- [JVM 源码分析之 JVM 启动流程](https://www.jianshu.com/p/b91258bc08ac)\n- [JVM 源码分析之堆内存的初始化](https://www.jianshu.com/p/0f7bed2df952)\n- [JVM 源码分析之 Java 对象的内存分配](https://www.jianshu.com/p/e56c808b6c8a)\n- [JVM 源码分析之如何触发并执行 GC 线程](https://www.jianshu.com/p/1544d3011ddb)\n- [JVM 源码分析之垃圾收集的执行过程](https://www.jianshu.com/p/04eff13f3707)\n- [JVM 源码分析之新生代 DefNewGeneration 的实现](https://www.jianshu.com/p/2b64294fa1bd)\n- [JVM 源码分析之老年代 TenuredGeneration 的垃圾回收算法实现](https://www.jianshu.com/p/29c20f0684d0)\n- [JVM 源码分析之安全点 safepoint](https://www.jianshu.com/p/c79c5e02ebe6)\n  [JVM 源码分析之线程局部缓存 TLAB](https://www.jianshu.com/p/cd85098cca39)\n- [JVM 源码分析之不要被 GC 日志的表面现象迷惑](https://www.jianshu.com/p/1f2fd54808e2)\n- [JVM 源码分析之 YGC 的来龙去脉](https://www.jianshu.com/p/9af1a63a33c3)\n- [JVM 源码分析之跨代引用 CardTable](https://www.jianshu.com/p/5037459097ee)\n- [JVM 源码分析之 System.gc()](https://www.jianshu.com/p/be8740726cef)\n- [JVM 源码分析之 GC locker 深度分析](https://www.jianshu.com/p/6d664f026508)\n- [JVM 源码分析之由 JNI 操作引起的迷惑性 GC](https://www.jianshu.com/p/94bd5864f89c)\n- [从 JVM 角度看看 Java 的 clone 操作](https://www.jianshu.com/p/309f80f33190)\n\n\n# JVM学习目录\n\n<p>1. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5204694.html\">【JVM】JVM系列之JVM体系（一）</a></p>\n<p>2. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5218594.html\">【JVM】JVM系列之垃圾回收（二）</a></p>\n<p>3. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5263764.html\">【JVM】JVM系列之Class文件（三）</a></p>\n<p>4. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5269545.html\">【JVM】JVM系列之类加载机制（四）</a></p>\n<p>5. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5275189.html\">【JVM】JVM系列之执行引擎（五）</a></p>\n<p>6. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5291484.html\">【JVM】JVM系列之内存模型（六）</a></p>\n</div>","source":"_posts/language/jvm/JVM优秀文章.md","raw":"---\ntitle: JVM优秀文章\ncategories:\n- java\n---\n\n\n# JVM G1 算法系列\n\n- [G1 垃圾收集器介绍](https://www.jianshu.com/p/0f1f5adffdc1)\n- [G1 垃圾收集器之 RSet](https://www.jianshu.com/p/870abddaba41)\n- [G1 垃圾收集器之 SATB](https://www.jianshu.com/p/9e70097807ba)\n- [G1 垃圾收集器之对象分配过程](https://www.jianshu.com/p/a0efa489b99f)\n\n# ZGC 系列\n\n- [ZGC，一个超乎想象的垃圾收集器](https://www.jianshu.com/p/6f89fd5842bf)\n- [ZGC 什么时候进行垃圾回收](https://www.jianshu.com/p/b5fb06ffbb90)\n\n# JVM 源码分析系列\n\n- [深入分析 Object.finalize 方法的实现原理](https://www.jianshu.com/p/9d2788fffd5f)\n- [JVM 源码分析之 Object.wait/notify 实现](https://www.jianshu.com/p/f4454164c017)\n- [JVM 源码分析之 java 对象头实现](https://www.jianshu.com/p/9c19eb0ea4d8)\n- [JVM 源码分析之 synchronized 实现](https://www.jianshu.com/p/c5058b6fe8e5)\n- [JVM 源码分析之 Java 类的加载过程](https://www.jianshu.com/p/252e27863822)\n- [JVM 源码分析之 Java 对象的创建过程](https://www.jianshu.com/p/0009aaac16ed)\n- [JVM 源码分析之 JVM 启动流程](https://www.jianshu.com/p/b91258bc08ac)\n- [JVM 源码分析之堆内存的初始化](https://www.jianshu.com/p/0f7bed2df952)\n- [JVM 源码分析之 Java 对象的内存分配](https://www.jianshu.com/p/e56c808b6c8a)\n- [JVM 源码分析之如何触发并执行 GC 线程](https://www.jianshu.com/p/1544d3011ddb)\n- [JVM 源码分析之垃圾收集的执行过程](https://www.jianshu.com/p/04eff13f3707)\n- [JVM 源码分析之新生代 DefNewGeneration 的实现](https://www.jianshu.com/p/2b64294fa1bd)\n- [JVM 源码分析之老年代 TenuredGeneration 的垃圾回收算法实现](https://www.jianshu.com/p/29c20f0684d0)\n- [JVM 源码分析之安全点 safepoint](https://www.jianshu.com/p/c79c5e02ebe6)\n  [JVM 源码分析之线程局部缓存 TLAB](https://www.jianshu.com/p/cd85098cca39)\n- [JVM 源码分析之不要被 GC 日志的表面现象迷惑](https://www.jianshu.com/p/1f2fd54808e2)\n- [JVM 源码分析之 YGC 的来龙去脉](https://www.jianshu.com/p/9af1a63a33c3)\n- [JVM 源码分析之跨代引用 CardTable](https://www.jianshu.com/p/5037459097ee)\n- [JVM 源码分析之 System.gc()](https://www.jianshu.com/p/be8740726cef)\n- [JVM 源码分析之 GC locker 深度分析](https://www.jianshu.com/p/6d664f026508)\n- [JVM 源码分析之由 JNI 操作引起的迷惑性 GC](https://www.jianshu.com/p/94bd5864f89c)\n- [从 JVM 角度看看 Java 的 clone 操作](https://www.jianshu.com/p/309f80f33190)\n\n\n# JVM学习目录\n\n<p>1. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5204694.html\">【JVM】JVM系列之JVM体系（一）</a></p>\n<p>2. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5218594.html\">【JVM】JVM系列之垃圾回收（二）</a></p>\n<p>3. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5263764.html\">【JVM】JVM系列之Class文件（三）</a></p>\n<p>4. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5269545.html\">【JVM】JVM系列之类加载机制（四）</a></p>\n<p>5. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5275189.html\">【JVM】JVM系列之执行引擎（五）</a></p>\n<p>6. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5291484.html\">【JVM】JVM系列之内存模型（六）</a></p>\n</div>","slug":"language/jvm/JVM优秀文章","published":1,"date":"2021-07-31T09:04:32.033Z","updated":"2021-07-31T09:04:32.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bt0005y2uk7tk51izw","content":"<h1 id=\"JVM-G1-算法系列\"><a href=\"#JVM-G1-算法系列\" class=\"headerlink\" title=\"JVM G1 算法系列\"></a>JVM G1 算法系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/0f1f5adffdc1\">G1 垃圾收集器介绍</a></li>\n<li><a href=\"https://www.jianshu.com/p/870abddaba41\">G1 垃圾收集器之 RSet</a></li>\n<li><a href=\"https://www.jianshu.com/p/9e70097807ba\">G1 垃圾收集器之 SATB</a></li>\n<li><a href=\"https://www.jianshu.com/p/a0efa489b99f\">G1 垃圾收集器之对象分配过程</a></li>\n</ul>\n<h1 id=\"ZGC-系列\"><a href=\"#ZGC-系列\" class=\"headerlink\" title=\"ZGC 系列\"></a>ZGC 系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/6f89fd5842bf\">ZGC，一个超乎想象的垃圾收集器</a></li>\n<li><a href=\"https://www.jianshu.com/p/b5fb06ffbb90\">ZGC 什么时候进行垃圾回收</a></li>\n</ul>\n<h1 id=\"JVM-源码分析系列\"><a href=\"#JVM-源码分析系列\" class=\"headerlink\" title=\"JVM 源码分析系列\"></a>JVM 源码分析系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/9d2788fffd5f\">深入分析 Object.finalize 方法的实现原理</a></li>\n<li><a href=\"https://www.jianshu.com/p/f4454164c017\">JVM 源码分析之 Object.wait/notify 实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/9c19eb0ea4d8\">JVM 源码分析之 java 对象头实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/c5058b6fe8e5\">JVM 源码分析之 synchronized 实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/252e27863822\">JVM 源码分析之 Java 类的加载过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/0009aaac16ed\">JVM 源码分析之 Java 对象的创建过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/b91258bc08ac\">JVM 源码分析之 JVM 启动流程</a></li>\n<li><a href=\"https://www.jianshu.com/p/0f7bed2df952\">JVM 源码分析之堆内存的初始化</a></li>\n<li><a href=\"https://www.jianshu.com/p/e56c808b6c8a\">JVM 源码分析之 Java 对象的内存分配</a></li>\n<li><a href=\"https://www.jianshu.com/p/1544d3011ddb\">JVM 源码分析之如何触发并执行 GC 线程</a></li>\n<li><a href=\"https://www.jianshu.com/p/04eff13f3707\">JVM 源码分析之垃圾收集的执行过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/2b64294fa1bd\">JVM 源码分析之新生代 DefNewGeneration 的实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/29c20f0684d0\">JVM 源码分析之老年代 TenuredGeneration 的垃圾回收算法实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/c79c5e02ebe6\">JVM 源码分析之安全点 safepoint</a><br><a href=\"https://www.jianshu.com/p/cd85098cca39\">JVM 源码分析之线程局部缓存 TLAB</a></li>\n<li><a href=\"https://www.jianshu.com/p/1f2fd54808e2\">JVM 源码分析之不要被 GC 日志的表面现象迷惑</a></li>\n<li><a href=\"https://www.jianshu.com/p/9af1a63a33c3\">JVM 源码分析之 YGC 的来龙去脉</a></li>\n<li><a href=\"https://www.jianshu.com/p/5037459097ee\">JVM 源码分析之跨代引用 CardTable</a></li>\n<li><a href=\"https://www.jianshu.com/p/be8740726cef\">JVM 源码分析之 System.gc()</a></li>\n<li><a href=\"https://www.jianshu.com/p/6d664f026508\">JVM 源码分析之 GC locker 深度分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/94bd5864f89c\">JVM 源码分析之由 JNI 操作引起的迷惑性 GC</a></li>\n<li><a href=\"https://www.jianshu.com/p/309f80f33190\">从 JVM 角度看看 Java 的 clone 操作</a></li>\n</ul>\n<h1 id=\"JVM学习目录\"><a href=\"#JVM学习目录\" class=\"headerlink\" title=\"JVM学习目录\"></a>JVM学习目录</h1><p>1. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5204694.html\">【JVM】JVM系列之JVM体系（一）</a></p>\n<p>2. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5218594.html\">【JVM】JVM系列之垃圾回收（二）</a></p>\n<p>3. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5263764.html\">【JVM】JVM系列之Class文件（三）</a></p>\n<p>4. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5269545.html\">【JVM】JVM系列之类加载机制（四）</a></p>\n<p>5. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5275189.html\">【JVM】JVM系列之执行引擎（五）</a></p>\n<p>6. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5291484.html\">【JVM】JVM系列之内存模型（六）</a></p>\n</div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JVM-G1-算法系列\"><a href=\"#JVM-G1-算法系列\" class=\"headerlink\" title=\"JVM G1 算法系列\"></a>JVM G1 算法系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/0f1f5adffdc1\">G1 垃圾收集器介绍</a></li>\n<li><a href=\"https://www.jianshu.com/p/870abddaba41\">G1 垃圾收集器之 RSet</a></li>\n<li><a href=\"https://www.jianshu.com/p/9e70097807ba\">G1 垃圾收集器之 SATB</a></li>\n<li><a href=\"https://www.jianshu.com/p/a0efa489b99f\">G1 垃圾收集器之对象分配过程</a></li>\n</ul>\n<h1 id=\"ZGC-系列\"><a href=\"#ZGC-系列\" class=\"headerlink\" title=\"ZGC 系列\"></a>ZGC 系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/6f89fd5842bf\">ZGC，一个超乎想象的垃圾收集器</a></li>\n<li><a href=\"https://www.jianshu.com/p/b5fb06ffbb90\">ZGC 什么时候进行垃圾回收</a></li>\n</ul>\n<h1 id=\"JVM-源码分析系列\"><a href=\"#JVM-源码分析系列\" class=\"headerlink\" title=\"JVM 源码分析系列\"></a>JVM 源码分析系列</h1><ul>\n<li><a href=\"https://www.jianshu.com/p/9d2788fffd5f\">深入分析 Object.finalize 方法的实现原理</a></li>\n<li><a href=\"https://www.jianshu.com/p/f4454164c017\">JVM 源码分析之 Object.wait/notify 实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/9c19eb0ea4d8\">JVM 源码分析之 java 对象头实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/c5058b6fe8e5\">JVM 源码分析之 synchronized 实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/252e27863822\">JVM 源码分析之 Java 类的加载过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/0009aaac16ed\">JVM 源码分析之 Java 对象的创建过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/b91258bc08ac\">JVM 源码分析之 JVM 启动流程</a></li>\n<li><a href=\"https://www.jianshu.com/p/0f7bed2df952\">JVM 源码分析之堆内存的初始化</a></li>\n<li><a href=\"https://www.jianshu.com/p/e56c808b6c8a\">JVM 源码分析之 Java 对象的内存分配</a></li>\n<li><a href=\"https://www.jianshu.com/p/1544d3011ddb\">JVM 源码分析之如何触发并执行 GC 线程</a></li>\n<li><a href=\"https://www.jianshu.com/p/04eff13f3707\">JVM 源码分析之垃圾收集的执行过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/2b64294fa1bd\">JVM 源码分析之新生代 DefNewGeneration 的实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/29c20f0684d0\">JVM 源码分析之老年代 TenuredGeneration 的垃圾回收算法实现</a></li>\n<li><a href=\"https://www.jianshu.com/p/c79c5e02ebe6\">JVM 源码分析之安全点 safepoint</a><br><a href=\"https://www.jianshu.com/p/cd85098cca39\">JVM 源码分析之线程局部缓存 TLAB</a></li>\n<li><a href=\"https://www.jianshu.com/p/1f2fd54808e2\">JVM 源码分析之不要被 GC 日志的表面现象迷惑</a></li>\n<li><a href=\"https://www.jianshu.com/p/9af1a63a33c3\">JVM 源码分析之 YGC 的来龙去脉</a></li>\n<li><a href=\"https://www.jianshu.com/p/5037459097ee\">JVM 源码分析之跨代引用 CardTable</a></li>\n<li><a href=\"https://www.jianshu.com/p/be8740726cef\">JVM 源码分析之 System.gc()</a></li>\n<li><a href=\"https://www.jianshu.com/p/6d664f026508\">JVM 源码分析之 GC locker 深度分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/94bd5864f89c\">JVM 源码分析之由 JNI 操作引起的迷惑性 GC</a></li>\n<li><a href=\"https://www.jianshu.com/p/309f80f33190\">从 JVM 角度看看 Java 的 clone 操作</a></li>\n</ul>\n<h1 id=\"JVM学习目录\"><a href=\"#JVM学习目录\" class=\"headerlink\" title=\"JVM学习目录\"></a>JVM学习目录</h1><p>1. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5204694.html\">【JVM】JVM系列之JVM体系（一）</a></p>\n<p>2. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5218594.html\">【JVM】JVM系列之垃圾回收（二）</a></p>\n<p>3. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5263764.html\">【JVM】JVM系列之Class文件（三）</a></p>\n<p>4. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5269545.html\">【JVM】JVM系列之类加载机制（四）</a></p>\n<p>5. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5275189.html\">【JVM】JVM系列之执行引擎（五）</a></p>\n<p>6. <a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"http://www.cnblogs.com/leesf456/p/5291484.html\">【JVM】JVM系列之内存模型（六）</a></p>\n</div>"},{"title":"bytebuddy替换类实现","_content":"\n\n## bytebuddy-替换类实现\n\n## 1.依赖\n\n```\ndependencies {\n  implementation group: 'net.bytebuddy', name: 'byte-buddy', version: '1.11.8'\n  implementation group: 'net.bytebuddy', name: 'byte-buddy-agent', version: '1.11.8'\n}\n```\n\n## 2.测试类被替换类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\npublic class Log {\n\n    public static void log(String a) {\n\n        System.out.println(\"Log: \" + a);\n    }\n\n}\n```\n\n## 3.测试类替换目的类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\npublic class Log4j {\n\n    /**\n     * 注意代理类要和原实现类的方法声明保持一致\n     * @param a\n     */\n    public static void log(String a) {\n        System.err.println(\"Log4j: \" + a);\n    }\n\n}\n```\n\n## 4.测试验证类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.agent.ByteBuddyAgent;\nimport net.bytebuddy.dynamic.loading.ClassReloadingStrategy;\nimport net.bytebuddy.implementation.MethodDelegation;\nimport net.bytebuddy.matcher.ElementMatchers;\n\npublic class LogMain {\n\n    public static void main(String[] args) {\n        // 替换\n        ByteBuddyAgent.install();\n        new ByteBuddy().redefine(Log.class)\n                .method(ElementMatchers.named(\"log\"))\n                .intercept(MethodDelegation.to(Log4j.class))\n                .make()\n                .load(Thread.currentThread().getContextClassLoader(), ClassReloadingStrategy.fromInstalledAgent());\n\n        // 调用\n        Log.log(\"hello\");\n    }\n\n}\n```\n\n```\nLog4j: hello\n```\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 5.参考\n\nhttps://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace","source":"_posts/language/字节码/bytebuddy-替换类实现.md","raw":"---\ntitle: bytebuddy替换类实现\ncategories:\n- java\n---\n\n\n## bytebuddy-替换类实现\n\n## 1.依赖\n\n```\ndependencies {\n  implementation group: 'net.bytebuddy', name: 'byte-buddy', version: '1.11.8'\n  implementation group: 'net.bytebuddy', name: 'byte-buddy-agent', version: '1.11.8'\n}\n```\n\n## 2.测试类被替换类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\npublic class Log {\n\n    public static void log(String a) {\n\n        System.out.println(\"Log: \" + a);\n    }\n\n}\n```\n\n## 3.测试类替换目的类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\npublic class Log4j {\n\n    /**\n     * 注意代理类要和原实现类的方法声明保持一致\n     * @param a\n     */\n    public static void log(String a) {\n        System.err.println(\"Log4j: \" + a);\n    }\n\n}\n```\n\n## 4.测试验证类\n\n```\npackage org.coral.jcode.simple.bytebuddy.reload;\n\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.agent.ByteBuddyAgent;\nimport net.bytebuddy.dynamic.loading.ClassReloadingStrategy;\nimport net.bytebuddy.implementation.MethodDelegation;\nimport net.bytebuddy.matcher.ElementMatchers;\n\npublic class LogMain {\n\n    public static void main(String[] args) {\n        // 替换\n        ByteBuddyAgent.install();\n        new ByteBuddy().redefine(Log.class)\n                .method(ElementMatchers.named(\"log\"))\n                .intercept(MethodDelegation.to(Log4j.class))\n                .make()\n                .load(Thread.currentThread().getContextClassLoader(), ClassReloadingStrategy.fromInstalledAgent());\n\n        // 调用\n        Log.log(\"hello\");\n    }\n\n}\n```\n\n```\nLog4j: hello\n```\n\n* 代码参考:\n  https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\n  \n## 5.参考\n\nhttps://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace","slug":"language/字节码/bytebuddy-替换类实现","published":1,"date":"2021-07-31T09:04:32.011Z","updated":"2021-07-31T09:04:32.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bv0007y2uk585xbxab","content":"<h2 id=\"bytebuddy-替换类实现\"><a href=\"#bytebuddy-替换类实现\" class=\"headerlink\" title=\"bytebuddy-替换类实现\"></a>bytebuddy-替换类实现</h2><h2 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy-agent&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-测试类被替换类\"><a href=\"#2-测试类被替换类\" class=\"headerlink\" title=\"2.测试类被替换类\"></a>2.测试类被替换类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Log &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void log(String a) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;Log: &quot; + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-测试类替换目的类\"><a href=\"#3-测试类替换目的类\" class=\"headerlink\" title=\"3.测试类替换目的类\"></a>3.测试类替换目的类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Log4j &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 注意代理类要和原实现类的方法声明保持一致</span><br><span class=\"line\">     * @param a</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void log(String a) &#123;</span><br><span class=\"line\">        System.err.println(&quot;Log4j: &quot; + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-测试验证类\"><a href=\"#4-测试验证类\" class=\"headerlink\" title=\"4.测试验证类\"></a>4.测试验证类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">import net.bytebuddy.ByteBuddy;</span><br><span class=\"line\">import net.bytebuddy.agent.ByteBuddyAgent;</span><br><span class=\"line\">import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;</span><br><span class=\"line\">import net.bytebuddy.implementation.MethodDelegation;</span><br><span class=\"line\">import net.bytebuddy.matcher.ElementMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">public class LogMain &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 替换</span><br><span class=\"line\">        ByteBuddyAgent.install();</span><br><span class=\"line\">        new ByteBuddy().redefine(Log.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;log&quot;))</span><br><span class=\"line\">                .intercept(MethodDelegation.to(Log4j.class))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(Thread.currentThread().getContextClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用</span><br><span class=\"line\">        Log.log(&quot;hello&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log4j: hello</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5.参考\"></a>5.参考</h2><p><a href=\"https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace\">https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"bytebuddy-替换类实现\"><a href=\"#bytebuddy-替换类实现\" class=\"headerlink\" title=\"bytebuddy-替换类实现\"></a>bytebuddy-替换类实现</h2><h2 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy-agent&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-测试类被替换类\"><a href=\"#2-测试类被替换类\" class=\"headerlink\" title=\"2.测试类被替换类\"></a>2.测试类被替换类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Log &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void log(String a) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;Log: &quot; + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-测试类替换目的类\"><a href=\"#3-测试类替换目的类\" class=\"headerlink\" title=\"3.测试类替换目的类\"></a>3.测试类替换目的类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Log4j &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 注意代理类要和原实现类的方法声明保持一致</span><br><span class=\"line\">     * @param a</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void log(String a) &#123;</span><br><span class=\"line\">        System.err.println(&quot;Log4j: &quot; + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-测试验证类\"><a href=\"#4-测试验证类\" class=\"headerlink\" title=\"4.测试验证类\"></a>4.测试验证类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class=\"line\"></span><br><span class=\"line\">import net.bytebuddy.ByteBuddy;</span><br><span class=\"line\">import net.bytebuddy.agent.ByteBuddyAgent;</span><br><span class=\"line\">import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;</span><br><span class=\"line\">import net.bytebuddy.implementation.MethodDelegation;</span><br><span class=\"line\">import net.bytebuddy.matcher.ElementMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">public class LogMain &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 替换</span><br><span class=\"line\">        ByteBuddyAgent.install();</span><br><span class=\"line\">        new ByteBuddy().redefine(Log.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;log&quot;))</span><br><span class=\"line\">                .intercept(MethodDelegation.to(Log4j.class))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(Thread.currentThread().getContextClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用</span><br><span class=\"line\">        Log.log(&quot;hello&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log4j: hello</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>代码参考:<br><a href=\"https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy\">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li>\n</ul>\n<h2 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5.参考\"></a>5.参考</h2><p><a href=\"https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace\">https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace</a></p>\n"},{"title":"JVM常见参数设置","_content":"\n## 1. 查看\n**-XX:+PrintFlagsFinal**\n\n- 查看堆的默认值，使用下面的代码。\n其中 InitialHeapSize 为最开始的堆的大小，MaxHeapSize 为堆的最大值。\n```\n$ java -XX:+PrintFlagsFinal -version | grep HeapSize\n    uintx ErgoHeapSizeLimit                         = 0                                   {product}\n    uintx HeapSizePerGCThread                       = 87241520                            {product}\n    uintx InitialHeapSize                          := 134217728                           {product}\n    uintx LargePageHeapSizeThreshold                = 134217728                           {product}\n    uintx MaxHeapSize                              := 2147483648                          {product}\njava version \"1.8.0_25\"\nJava(TM) SE Runtime Environment (build 1.8.0_25-b17)\nJava HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)\n\n```\n\n- 查看栈的默认值, 其中 ThreadStackSize 为栈内存的大小。\n```\n$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize\n intx CompilerThreadStackSize                   = 0                                   {pd product}\n intx ThreadStackSize                           = 1024                                {pd product}\n intx VMThreadStackSize                         = 1024                                {pd product}\njava version \"1.8.0_25\"\nJava(TM) SE Runtime Environment (build 1.8.0_25-b17)\nJava HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)\n\n```\n## 2. 堆\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/804884/1627721065789-f0943cfd-fbc6-4efd-847f-5661628e8a9e.png#clientId=ud7a2e44c-082c-4&from=paste&id=uac2b358e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=593&originalType=url&ratio=1&size=88416&status=done&style=none&taskId=u6a74a41e-6989-4ec2-b966-583063cd2d7)\n\n- -Xmx：初始堆的大小\n- -Xms：最大堆大小，建议这两个参数大小保持一致，为物理内存的 1/4\n- -Xmn：指定新生代的大小（Eden + Survior from + Survior to）的大小，增大新生代的大小，老年代的大小将被减小，sun 官方推荐 新生代的大小：堆 = 3 : 8\n- -XX:NewSize：设置新生代大小\n- -XX:MaxNewSize：设置新生代的最大值-Xmn 相当于设同时设置 NewSize=MaxNewSize\n- -XX:NewRation：老年代：新生代 = 4，即 old：(Eden + Survivor from + Survivor to) ，则说明新生代为整个堆区的 1/5\n- -XX:SurvivorRation：设置 Eden 区和 Survivor。\n默认值为8；即：Eden：Survivor=8:1 ==> Eden：Survivor from：Survivor to = 8:1:1\n若值为3，即：Eden：Survivor=8:1 ==> Eden：Survivor from：Survivor to = 3:1:1\n## 3. 方法区（非堆）\n\n- -XX:PermSize：设置方法区大小\n- -XX:MaxPermSize： 设置方法区的最大值\n- 1.8 之前可以理解为 永久区（PerSize，MaxPerSize）。\n- 1.8 之后使用 元数据区 取代。（MaxMetaspaceSize）。\n## 4. 栈\n\n- -Xss：栈内存的大小\n## 5. 详细参数\n### 5.1.基础参数\n| **参数名称** | **含义** | **默认值** |   |\n| --- | --- | --- | --- |\n| -Xms | 初始堆大小 | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. |\n| -Xmx | 最大堆大小 | 物理内存的1/4(<1GB) | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 |\n| -Xmn | 年轻代大小(1.4or lator) |   | **注意**：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。\n整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.\n增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |\n| -XX:NewSize | 设置年轻代大小(for 1.3/1.4) |   |   |\n| -XX:MaxNewSize | 年轻代最大值(for 1.3/1.4) |   |   |\n| -XX:PermSize | 设置持久代(perm gen)初始值 | 物理内存的1/64 |   |\n| -XX:MaxPermSize | 设置持久代最大值 | 物理内存的1/4 |   |\n| -Xss | 每个线程的堆栈大小 |   | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右\n一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。\n和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”. 一般设置128k或者256k这个值就可以了。 |\n| -_XX:ThreadStackSize_ | Thread Stack Size |   | (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.] |\n| -XX:NewRatio | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) |   | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5\nXms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 |\n| -XX:SurvivorRatio | Eden区与Survivor区的大小比值 |   | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 |\n| -XX:LargePageSizeInBytes | 内存页的大小不可设置过大， 会影响Perm的大小 |   | =128m |\n| -XX:+UseFastAccessorMethods | 原始类型的快速优化 |   |   |\n| -XX:+DisableExplicitGC | 关闭System.gc() |   | 这个参数需要严格的测试 |\n| -XX:MaxTenuringThreshold | 垃圾最大年龄 |   | 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率\n该参数只有在串行GC时才有效. |\n| -XX:+AggressiveOpts | 加快编译 |   |   |\n| -XX:+UseBiasedLocking | 锁机制的性能改善 |   |   |\n| -Xnoclassgc | 禁用垃圾回收 |   |   |\n| -XX:SoftRefLRUPolicyMSPerMB | 每兆堆空闲空间中SoftReference的存活时间 | 1s | softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap |\n| -XX:PretenureSizeThreshold | 对象超过多大是直接在旧生代分配 | 0 | 单位字节 新生代采用Parallel Scavenge GC时无效\n另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. |\n| -XX:TLABWasteTargetPercent | TLAB占eden区的百分比 | 1% |   |\n| -XX:+_CollectGen0First_ | FullGC时是否先YGC | false |   |\n\n### 5.2 并行收集器相关参数\n| -XX:+UseParallelGC | Full GC采用parallel MSC\n(此项待验证) |   | 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) |\n| --- | --- | --- | --- |\n| -XX:+UseParNewGC | 设置年轻代为并行收集 |   | 可与CMS收集同时使用\nJDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 |\n| -XX:ParallelGCThreads | 并行收集器的线程数 |   | 此值最好配置与处理器数目相等 同样适用于CMS |\n| -XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) |   | 这个是JAVA 6出现的参数选项 |\n| -XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) |   | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. |\n| -XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 |   | 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. |\n| -XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 |   | 公式为1/(1+n) |\n| -XX:+_ScavengeBeforeFullGC_ | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.) |\n\n### 5.3 CMS相关参数\n| -XX:+UseConcMarkSweepGC | 使用CMS内存收集 |   | 测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.??? |\n| --- | --- | --- | --- |\n| -XX:+AggressiveHeap |   |   | 试图是使用大量的物理内存\n长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）\n至少需要256MB内存\n大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） |\n| -XX:CMSFullGCsBeforeCompaction | 多少次后进行内存压缩 |   | 由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生\"碎片\",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理. |\n| -XX:+CMSParallelRemarkEnabled | 降低标记停顿 |   |   |\n| -XX+UseCMSCompactAtFullCollection | 在FULL GC的时候， 对年老代的压缩 |   | CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。\n可能会影响性能,但是可以消除碎片 |\n| -XX:+UseCMSInitiatingOccupancyOnly | 使用手动定义初始化定义开始CMS收集 |   | 禁止hostspot自行触发CMS GC |\n| -XX:CMSInitiatingOccupancyFraction=70 | 使用cms作为垃圾回收\n使用70％后开始CMS收集 | 92 | 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式[CMSInitiatingOccupancyFraction计算公式](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value) |\n| -XX:CMSInitiatingPermOccupancyFraction | 设置Perm Gen使用到达多少比率时触发 | 92 |   |\n| -XX:+CMSIncrementalMode | 设置为增量模式 |   | 用于单CPU情况 |\n| -XX:+CMSClassUnloadingEnabled |   |   |   |\n\n### 5.4 辅助信息\n| -XX:+PrintGC |   |   | 输出形式:\n[GC 118250K->113543K(130112K), 0.0094143 secs]\n[Full GC 121376K->10414K(130112K), 0.0650971 secs] |\n| --- | --- | --- | --- |\n| -XX:+PrintGCDetails |   |   | 输出形式:[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs]\n[GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs] |\n| -XX:+PrintGCTimeStamps |   |   |   |\n| -XX:+PrintGC:PrintGCTimeStamps |   |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用\n输出形式:11.851: [GC 98328K->93620K(130112K), 0.0082960 secs] |\n| -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用 |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |\n| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 |   | 输出形式:Application time: 0.5291524 seconds |\n| -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息 |   |   |\n| -Xloggc:filename | 把相关日志信息记录到文件以便分析.\n与上面几个配合使用 |   |   |\n| -XX:+PrintClassHistogram | garbage collects before printing the histogram. |   |   |\n| -XX:+PrintTLAB | 查看TLAB空间的使用情况 |   |   |\n| XX:+PrintTenuringDistribution | 查看每次minor GC后新的存活周期的阈值 |   | Desired survivor size 1048576 bytes, new threshold 7 (max 15)\nnew threshold 7即标识新的存活周期的阈值为7。 |\n\n## 6.参考\n[https://juejin.cn/post/6844903740848242695](https://juejin.cn/post/6844903740848242695)\n[http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html](http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html)\n","source":"_posts/language/jvm/JVM常见参数设置.md","raw":"---\ntitle: JVM常见参数设置\ncategories:\n- java\n---\n\n## 1. 查看\n**-XX:+PrintFlagsFinal**\n\n- 查看堆的默认值，使用下面的代码。\n其中 InitialHeapSize 为最开始的堆的大小，MaxHeapSize 为堆的最大值。\n```\n$ java -XX:+PrintFlagsFinal -version | grep HeapSize\n    uintx ErgoHeapSizeLimit                         = 0                                   {product}\n    uintx HeapSizePerGCThread                       = 87241520                            {product}\n    uintx InitialHeapSize                          := 134217728                           {product}\n    uintx LargePageHeapSizeThreshold                = 134217728                           {product}\n    uintx MaxHeapSize                              := 2147483648                          {product}\njava version \"1.8.0_25\"\nJava(TM) SE Runtime Environment (build 1.8.0_25-b17)\nJava HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)\n\n```\n\n- 查看栈的默认值, 其中 ThreadStackSize 为栈内存的大小。\n```\n$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize\n intx CompilerThreadStackSize                   = 0                                   {pd product}\n intx ThreadStackSize                           = 1024                                {pd product}\n intx VMThreadStackSize                         = 1024                                {pd product}\njava version \"1.8.0_25\"\nJava(TM) SE Runtime Environment (build 1.8.0_25-b17)\nJava HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)\n\n```\n## 2. 堆\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/804884/1627721065789-f0943cfd-fbc6-4efd-847f-5661628e8a9e.png#clientId=ud7a2e44c-082c-4&from=paste&id=uac2b358e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=593&originalType=url&ratio=1&size=88416&status=done&style=none&taskId=u6a74a41e-6989-4ec2-b966-583063cd2d7)\n\n- -Xmx：初始堆的大小\n- -Xms：最大堆大小，建议这两个参数大小保持一致，为物理内存的 1/4\n- -Xmn：指定新生代的大小（Eden + Survior from + Survior to）的大小，增大新生代的大小，老年代的大小将被减小，sun 官方推荐 新生代的大小：堆 = 3 : 8\n- -XX:NewSize：设置新生代大小\n- -XX:MaxNewSize：设置新生代的最大值-Xmn 相当于设同时设置 NewSize=MaxNewSize\n- -XX:NewRation：老年代：新生代 = 4，即 old：(Eden + Survivor from + Survivor to) ，则说明新生代为整个堆区的 1/5\n- -XX:SurvivorRation：设置 Eden 区和 Survivor。\n默认值为8；即：Eden：Survivor=8:1 ==> Eden：Survivor from：Survivor to = 8:1:1\n若值为3，即：Eden：Survivor=8:1 ==> Eden：Survivor from：Survivor to = 3:1:1\n## 3. 方法区（非堆）\n\n- -XX:PermSize：设置方法区大小\n- -XX:MaxPermSize： 设置方法区的最大值\n- 1.8 之前可以理解为 永久区（PerSize，MaxPerSize）。\n- 1.8 之后使用 元数据区 取代。（MaxMetaspaceSize）。\n## 4. 栈\n\n- -Xss：栈内存的大小\n## 5. 详细参数\n### 5.1.基础参数\n| **参数名称** | **含义** | **默认值** |   |\n| --- | --- | --- | --- |\n| -Xms | 初始堆大小 | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. |\n| -Xmx | 最大堆大小 | 物理内存的1/4(<1GB) | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 |\n| -Xmn | 年轻代大小(1.4or lator) |   | **注意**：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。\n整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.\n增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |\n| -XX:NewSize | 设置年轻代大小(for 1.3/1.4) |   |   |\n| -XX:MaxNewSize | 年轻代最大值(for 1.3/1.4) |   |   |\n| -XX:PermSize | 设置持久代(perm gen)初始值 | 物理内存的1/64 |   |\n| -XX:MaxPermSize | 设置持久代最大值 | 物理内存的1/4 |   |\n| -Xss | 每个线程的堆栈大小 |   | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右\n一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。\n和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”. 一般设置128k或者256k这个值就可以了。 |\n| -_XX:ThreadStackSize_ | Thread Stack Size |   | (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.] |\n| -XX:NewRatio | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) |   | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5\nXms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 |\n| -XX:SurvivorRatio | Eden区与Survivor区的大小比值 |   | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 |\n| -XX:LargePageSizeInBytes | 内存页的大小不可设置过大， 会影响Perm的大小 |   | =128m |\n| -XX:+UseFastAccessorMethods | 原始类型的快速优化 |   |   |\n| -XX:+DisableExplicitGC | 关闭System.gc() |   | 这个参数需要严格的测试 |\n| -XX:MaxTenuringThreshold | 垃圾最大年龄 |   | 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率\n该参数只有在串行GC时才有效. |\n| -XX:+AggressiveOpts | 加快编译 |   |   |\n| -XX:+UseBiasedLocking | 锁机制的性能改善 |   |   |\n| -Xnoclassgc | 禁用垃圾回收 |   |   |\n| -XX:SoftRefLRUPolicyMSPerMB | 每兆堆空闲空间中SoftReference的存活时间 | 1s | softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap |\n| -XX:PretenureSizeThreshold | 对象超过多大是直接在旧生代分配 | 0 | 单位字节 新生代采用Parallel Scavenge GC时无效\n另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. |\n| -XX:TLABWasteTargetPercent | TLAB占eden区的百分比 | 1% |   |\n| -XX:+_CollectGen0First_ | FullGC时是否先YGC | false |   |\n\n### 5.2 并行收集器相关参数\n| -XX:+UseParallelGC | Full GC采用parallel MSC\n(此项待验证) |   | 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) |\n| --- | --- | --- | --- |\n| -XX:+UseParNewGC | 设置年轻代为并行收集 |   | 可与CMS收集同时使用\nJDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 |\n| -XX:ParallelGCThreads | 并行收集器的线程数 |   | 此值最好配置与处理器数目相等 同样适用于CMS |\n| -XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) |   | 这个是JAVA 6出现的参数选项 |\n| -XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) |   | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. |\n| -XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 |   | 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. |\n| -XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 |   | 公式为1/(1+n) |\n| -XX:+_ScavengeBeforeFullGC_ | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.) |\n\n### 5.3 CMS相关参数\n| -XX:+UseConcMarkSweepGC | 使用CMS内存收集 |   | 测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.??? |\n| --- | --- | --- | --- |\n| -XX:+AggressiveHeap |   |   | 试图是使用大量的物理内存\n长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）\n至少需要256MB内存\n大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） |\n| -XX:CMSFullGCsBeforeCompaction | 多少次后进行内存压缩 |   | 由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生\"碎片\",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理. |\n| -XX:+CMSParallelRemarkEnabled | 降低标记停顿 |   |   |\n| -XX+UseCMSCompactAtFullCollection | 在FULL GC的时候， 对年老代的压缩 |   | CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。\n可能会影响性能,但是可以消除碎片 |\n| -XX:+UseCMSInitiatingOccupancyOnly | 使用手动定义初始化定义开始CMS收集 |   | 禁止hostspot自行触发CMS GC |\n| -XX:CMSInitiatingOccupancyFraction=70 | 使用cms作为垃圾回收\n使用70％后开始CMS收集 | 92 | 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式[CMSInitiatingOccupancyFraction计算公式](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value) |\n| -XX:CMSInitiatingPermOccupancyFraction | 设置Perm Gen使用到达多少比率时触发 | 92 |   |\n| -XX:+CMSIncrementalMode | 设置为增量模式 |   | 用于单CPU情况 |\n| -XX:+CMSClassUnloadingEnabled |   |   |   |\n\n### 5.4 辅助信息\n| -XX:+PrintGC |   |   | 输出形式:\n[GC 118250K->113543K(130112K), 0.0094143 secs]\n[Full GC 121376K->10414K(130112K), 0.0650971 secs] |\n| --- | --- | --- | --- |\n| -XX:+PrintGCDetails |   |   | 输出形式:[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs]\n[GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs] |\n| -XX:+PrintGCTimeStamps |   |   |   |\n| -XX:+PrintGC:PrintGCTimeStamps |   |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用\n输出形式:11.851: [GC 98328K->93620K(130112K), 0.0082960 secs] |\n| -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用 |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |\n| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 |   | 输出形式:Application time: 0.5291524 seconds |\n| -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息 |   |   |\n| -Xloggc:filename | 把相关日志信息记录到文件以便分析.\n与上面几个配合使用 |   |   |\n| -XX:+PrintClassHistogram | garbage collects before printing the histogram. |   |   |\n| -XX:+PrintTLAB | 查看TLAB空间的使用情况 |   |   |\n| XX:+PrintTenuringDistribution | 查看每次minor GC后新的存活周期的阈值 |   | Desired survivor size 1048576 bytes, new threshold 7 (max 15)\nnew threshold 7即标识新的存活周期的阈值为7。 |\n\n## 6.参考\n[https://juejin.cn/post/6844903740848242695](https://juejin.cn/post/6844903740848242695)\n[http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html](http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html)\n","slug":"language/jvm/JVM常见参数设置","published":1,"date":"2021-07-31T09:04:32.040Z","updated":"2021-07-31T09:04:32.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bv0008y2ukcxhk7of0","content":"<h2 id=\"1-查看\"><a href=\"#1-查看\" class=\"headerlink\" title=\"1. 查看\"></a>1. 查看</h2><p><strong>-XX:+PrintFlagsFinal</strong></p>\n<ul>\n<li><p>查看堆的默认值，使用下面的代码。<br>其中 InitialHeapSize 为最开始的堆的大小，MaxHeapSize 为堆的最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class=\"line\">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class=\"line\">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class=\"line\">    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;</span><br><span class=\"line\">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class=\"line\">    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;</span><br><span class=\"line\">java version &quot;1.8.0_25&quot;</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>查看栈的默认值, 其中 ThreadStackSize 为栈内存的大小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</span><br><span class=\"line\"> intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class=\"line\"> intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class=\"line\"> intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class=\"line\">java version &quot;1.8.0_25&quot;</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-堆\"><a href=\"#2-堆\" class=\"headerlink\" title=\"2. 堆\"></a>2. 堆</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/804884/1627721065789-f0943cfd-fbc6-4efd-847f-5661628e8a9e.png#clientId=ud7a2e44c-082c-4&from=paste&id=uac2b358e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=593&originalType=url&ratio=1&size=88416&status=done&style=none&taskId=u6a74a41e-6989-4ec2-b966-583063cd2d7\" alt=\"image.png\"></p>\n</li>\n<li><p>-Xmx：初始堆的大小</p>\n</li>\n<li><p>-Xms：最大堆大小，建议这两个参数大小保持一致，为物理内存的 1/4</p>\n</li>\n<li><p>-Xmn：指定新生代的大小（Eden + Survior from + Survior to）的大小，增大新生代的大小，老年代的大小将被减小，sun 官方推荐 新生代的大小：堆 = 3 : 8</p>\n</li>\n<li><p>-XX:NewSize：设置新生代大小</p>\n</li>\n<li><p>-XX:MaxNewSize：设置新生代的最大值-Xmn 相当于设同时设置 NewSize=MaxNewSize</p>\n</li>\n<li><p>-XX:NewRation：老年代：新生代 = 4，即 old：(Eden + Survivor from + Survivor to) ，则说明新生代为整个堆区的 1/5</p>\n</li>\n<li><p>-XX:SurvivorRation：设置 Eden 区和 Survivor。<br>默认值为8；即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 8:1:1<br>若值为3，即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 3:1:1</p>\n<h2 id=\"3-方法区（非堆）\"><a href=\"#3-方法区（非堆）\" class=\"headerlink\" title=\"3. 方法区（非堆）\"></a>3. 方法区（非堆）</h2></li>\n<li><p>-XX:PermSize：设置方法区大小</p>\n</li>\n<li><p>-XX:MaxPermSize： 设置方法区的最大值</p>\n</li>\n<li><p>1.8 之前可以理解为 永久区（PerSize，MaxPerSize）。</p>\n</li>\n<li><p>1.8 之后使用 元数据区 取代。（MaxMetaspaceSize）。</p>\n<h2 id=\"4-栈\"><a href=\"#4-栈\" class=\"headerlink\" title=\"4. 栈\"></a>4. 栈</h2></li>\n<li><p>-Xss：栈内存的大小</p>\n<h2 id=\"5-详细参数\"><a href=\"#5-详细参数\" class=\"headerlink\" title=\"5. 详细参数\"></a>5. 详细参数</h2><h3 id=\"5-1-基础参数\"><a href=\"#5-1-基础参数\" class=\"headerlink\" title=\"5.1.基础参数\"></a>5.1.基础参数</h3><table>\n<thead>\n<tr>\n<th><strong>参数名称</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>默认值</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n<td>物理内存的1/64(&lt;1GB)</td>\n<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n<td>物理内存的1/4(&lt;1GB)</td>\n<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>年轻代大小(1.4or lator)</td>\n<td></td>\n<td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。</td>\n</tr>\n<tr>\n<td>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:NewSize</td>\n<td>设置年轻代大小(for 1.3/1.4)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:MaxNewSize</td>\n<td>年轻代最大值(for 1.3/1.4)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>设置持久代(perm gen)初始值</td>\n<td>物理内存的1/64</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>设置持久代最大值</td>\n<td>物理内存的1/4</td>\n<td></td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>每个线程的堆栈大小</td>\n<td></td>\n<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td>\n</tr>\n<tr>\n<td>一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”. 一般设置128k或者256k这个值就可以了。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-<em>XX:ThreadStackSize</em></td>\n<td>Thread Stack Size</td>\n<td></td>\n<td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>\n<td></td>\n<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td>\n</tr>\n<tr>\n<td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>Eden区与Survivor区的大小比值</td>\n<td></td>\n<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>\n</tr>\n<tr>\n<td>-XX:LargePageSizeInBytes</td>\n<td>内存页的大小不可设置过大， 会影响Perm的大小</td>\n<td></td>\n<td>=128m</td>\n</tr>\n<tr>\n<td>-XX:+UseFastAccessorMethods</td>\n<td>原始类型的快速优化</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+DisableExplicitGC</td>\n<td>关闭System.gc()</td>\n<td></td>\n<td>这个参数需要严格的测试</td>\n</tr>\n<tr>\n<td>-XX:MaxTenuringThreshold</td>\n<td>垃圾最大年龄</td>\n<td></td>\n<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>\n</tr>\n<tr>\n<td>该参数只有在串行GC时才有效.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+AggressiveOpts</td>\n<td>加快编译</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+UseBiasedLocking</td>\n<td>锁机制的性能改善</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-Xnoclassgc</td>\n<td>禁用垃圾回收</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:SoftRefLRUPolicyMSPerMB</td>\n<td>每兆堆空闲空间中SoftReference的存活时间</td>\n<td>1s</td>\n<td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td>\n</tr>\n<tr>\n<td>-XX:PretenureSizeThreshold</td>\n<td>对象超过多大是直接在旧生代分配</td>\n<td>0</td>\n<td>单位字节 新生代采用Parallel Scavenge GC时无效</td>\n</tr>\n<tr>\n<td>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:TLABWasteTargetPercent</td>\n<td>TLAB占eden区的百分比</td>\n<td>1%</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+<em>CollectGen0First</em></td>\n<td>FullGC时是否先YGC</td>\n<td>false</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"5-2-并行收集器相关参数\"><a href=\"#5-2-并行收集器相关参数\" class=\"headerlink\" title=\"5.2 并行收集器相关参数\"></a>5.2 并行收集器相关参数</h3><p>| -XX:+UseParallelGC | Full GC采用parallel MSC<br>(此项待验证) |   | 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) |<br>| — | — | — | — |<br>| -XX:+UseParNewGC | 设置年轻代为并行收集 |   | 可与CMS收集同时使用<br>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 |<br>| -XX:ParallelGCThreads | 并行收集器的线程数 |   | 此值最好配置与处理器数目相等 同样适用于CMS |<br>| -XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) |   | 这个是JAVA 6出现的参数选项 |<br>| -XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) |   | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. |<br>| -XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 |   | 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. |<br>| -XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 |   | 公式为1/(1+n) |<br>| -XX:+<em>ScavengeBeforeFullGC</em> | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.) |</p>\n<h3 id=\"5-3-CMS相关参数\"><a href=\"#5-3-CMS相关参数\" class=\"headerlink\" title=\"5.3 CMS相关参数\"></a>5.3 CMS相关参数</h3><table>\n<thead>\n<tr>\n<th>-XX:+UseConcMarkSweepGC</th>\n<th>使用CMS内存收集</th>\n<th></th>\n<th>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+AggressiveHeap</td>\n<td></td>\n<td></td>\n<td>试图是使用大量的物理内存</td>\n</tr>\n<tr>\n<td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>至少需要256MB内存</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:CMSFullGCsBeforeCompaction</td>\n<td>多少次后进行内存压缩</td>\n<td></td>\n<td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>\n</tr>\n<tr>\n<td>-XX:+CMSParallelRemarkEnabled</td>\n<td>降低标记停顿</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX+UseCMSCompactAtFullCollection</td>\n<td>在FULL GC的时候， 对年老代的压缩</td>\n<td></td>\n<td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td>\n</tr>\n<tr>\n<td>可能会影响性能,但是可以消除碎片</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+UseCMSInitiatingOccupancyOnly</td>\n<td>使用手动定义初始化定义开始CMS收集</td>\n<td></td>\n<td>禁止hostspot自行触发CMS GC</td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingOccupancyFraction=70</td>\n<td>使用cms作为垃圾回收</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>使用70％后开始CMS收集</td>\n<td>92</td>\n<td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式<a href=\"http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value\">CMSInitiatingOccupancyFraction计算公式</a></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingPermOccupancyFraction</td>\n<td>设置Perm Gen使用到达多少比率时触发</td>\n<td>92</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+CMSIncrementalMode</td>\n<td>设置为增量模式</td>\n<td></td>\n<td>用于单CPU情况</td>\n</tr>\n<tr>\n<td>-XX:+CMSClassUnloadingEnabled</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"5-4-辅助信息\"><a href=\"#5-4-辅助信息\" class=\"headerlink\" title=\"5.4 辅助信息\"></a>5.4 辅助信息</h3><p>| -XX:+PrintGC |   |   | 输出形式:<br>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>[Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] |<br>| — | — | — | — |<br>| -XX:+PrintGCDetails |   |   | 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] |<br>| -XX:+PrintGCTimeStamps |   |   |   |<br>| -XX:+PrintGC:PrintGCTimeStamps |   |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用<br>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] |<br>| -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用 |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |<br>| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 |   | 输出形式:Application time: 0.5291524 seconds |<br>| -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息 |   |   |<br>| -Xloggc:filename | 把相关日志信息记录到文件以便分析.<br>与上面几个配合使用 |   |   |<br>| -XX:+PrintClassHistogram | garbage collects before printing the histogram. |   |   |<br>| -XX:+PrintTLAB | 查看TLAB空间的使用情况 |   |   |<br>| XX:+PrintTenuringDistribution | 查看每次minor GC后新的存活周期的阈值 |   | Desired survivor size 1048576 bytes, new threshold 7 (max 15)<br>new threshold 7即标识新的存活周期的阈值为7。 |</p>\n<h2 id=\"6-参考\"><a href=\"#6-参考\" class=\"headerlink\" title=\"6.参考\"></a>6.参考</h2><p><a href=\"https://juejin.cn/post/6844903740848242695\">https://juejin.cn/post/6844903740848242695</a><br><a href=\"http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html\">http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-查看\"><a href=\"#1-查看\" class=\"headerlink\" title=\"1. 查看\"></a>1. 查看</h2><p><strong>-XX:+PrintFlagsFinal</strong></p>\n<ul>\n<li><p>查看堆的默认值，使用下面的代码。<br>其中 InitialHeapSize 为最开始的堆的大小，MaxHeapSize 为堆的最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class=\"line\">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class=\"line\">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class=\"line\">    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;</span><br><span class=\"line\">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class=\"line\">    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;</span><br><span class=\"line\">java version &quot;1.8.0_25&quot;</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>查看栈的默认值, 其中 ThreadStackSize 为栈内存的大小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</span><br><span class=\"line\"> intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class=\"line\"> intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class=\"line\"> intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class=\"line\">java version &quot;1.8.0_25&quot;</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-堆\"><a href=\"#2-堆\" class=\"headerlink\" title=\"2. 堆\"></a>2. 堆</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/804884/1627721065789-f0943cfd-fbc6-4efd-847f-5661628e8a9e.png#clientId=ud7a2e44c-082c-4&from=paste&id=uac2b358e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=593&originalType=url&ratio=1&size=88416&status=done&style=none&taskId=u6a74a41e-6989-4ec2-b966-583063cd2d7\" alt=\"image.png\"></p>\n</li>\n<li><p>-Xmx：初始堆的大小</p>\n</li>\n<li><p>-Xms：最大堆大小，建议这两个参数大小保持一致，为物理内存的 1/4</p>\n</li>\n<li><p>-Xmn：指定新生代的大小（Eden + Survior from + Survior to）的大小，增大新生代的大小，老年代的大小将被减小，sun 官方推荐 新生代的大小：堆 = 3 : 8</p>\n</li>\n<li><p>-XX:NewSize：设置新生代大小</p>\n</li>\n<li><p>-XX:MaxNewSize：设置新生代的最大值-Xmn 相当于设同时设置 NewSize=MaxNewSize</p>\n</li>\n<li><p>-XX:NewRation：老年代：新生代 = 4，即 old：(Eden + Survivor from + Survivor to) ，则说明新生代为整个堆区的 1/5</p>\n</li>\n<li><p>-XX:SurvivorRation：设置 Eden 区和 Survivor。<br>默认值为8；即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 8:1:1<br>若值为3，即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 3:1:1</p>\n<h2 id=\"3-方法区（非堆）\"><a href=\"#3-方法区（非堆）\" class=\"headerlink\" title=\"3. 方法区（非堆）\"></a>3. 方法区（非堆）</h2></li>\n<li><p>-XX:PermSize：设置方法区大小</p>\n</li>\n<li><p>-XX:MaxPermSize： 设置方法区的最大值</p>\n</li>\n<li><p>1.8 之前可以理解为 永久区（PerSize，MaxPerSize）。</p>\n</li>\n<li><p>1.8 之后使用 元数据区 取代。（MaxMetaspaceSize）。</p>\n<h2 id=\"4-栈\"><a href=\"#4-栈\" class=\"headerlink\" title=\"4. 栈\"></a>4. 栈</h2></li>\n<li><p>-Xss：栈内存的大小</p>\n<h2 id=\"5-详细参数\"><a href=\"#5-详细参数\" class=\"headerlink\" title=\"5. 详细参数\"></a>5. 详细参数</h2><h3 id=\"5-1-基础参数\"><a href=\"#5-1-基础参数\" class=\"headerlink\" title=\"5.1.基础参数\"></a>5.1.基础参数</h3><table>\n<thead>\n<tr>\n<th><strong>参数名称</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>默认值</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n<td>物理内存的1/64(&lt;1GB)</td>\n<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n<td>物理内存的1/4(&lt;1GB)</td>\n<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>年轻代大小(1.4or lator)</td>\n<td></td>\n<td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。</td>\n</tr>\n<tr>\n<td>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:NewSize</td>\n<td>设置年轻代大小(for 1.3/1.4)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:MaxNewSize</td>\n<td>年轻代最大值(for 1.3/1.4)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>设置持久代(perm gen)初始值</td>\n<td>物理内存的1/64</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>设置持久代最大值</td>\n<td>物理内存的1/4</td>\n<td></td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>每个线程的堆栈大小</td>\n<td></td>\n<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td>\n</tr>\n<tr>\n<td>一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”. 一般设置128k或者256k这个值就可以了。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-<em>XX:ThreadStackSize</em></td>\n<td>Thread Stack Size</td>\n<td></td>\n<td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>\n<td></td>\n<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td>\n</tr>\n<tr>\n<td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>Eden区与Survivor区的大小比值</td>\n<td></td>\n<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>\n</tr>\n<tr>\n<td>-XX:LargePageSizeInBytes</td>\n<td>内存页的大小不可设置过大， 会影响Perm的大小</td>\n<td></td>\n<td>=128m</td>\n</tr>\n<tr>\n<td>-XX:+UseFastAccessorMethods</td>\n<td>原始类型的快速优化</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+DisableExplicitGC</td>\n<td>关闭System.gc()</td>\n<td></td>\n<td>这个参数需要严格的测试</td>\n</tr>\n<tr>\n<td>-XX:MaxTenuringThreshold</td>\n<td>垃圾最大年龄</td>\n<td></td>\n<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>\n</tr>\n<tr>\n<td>该参数只有在串行GC时才有效.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+AggressiveOpts</td>\n<td>加快编译</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+UseBiasedLocking</td>\n<td>锁机制的性能改善</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-Xnoclassgc</td>\n<td>禁用垃圾回收</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:SoftRefLRUPolicyMSPerMB</td>\n<td>每兆堆空闲空间中SoftReference的存活时间</td>\n<td>1s</td>\n<td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td>\n</tr>\n<tr>\n<td>-XX:PretenureSizeThreshold</td>\n<td>对象超过多大是直接在旧生代分配</td>\n<td>0</td>\n<td>单位字节 新生代采用Parallel Scavenge GC时无效</td>\n</tr>\n<tr>\n<td>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:TLABWasteTargetPercent</td>\n<td>TLAB占eden区的百分比</td>\n<td>1%</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+<em>CollectGen0First</em></td>\n<td>FullGC时是否先YGC</td>\n<td>false</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"5-2-并行收集器相关参数\"><a href=\"#5-2-并行收集器相关参数\" class=\"headerlink\" title=\"5.2 并行收集器相关参数\"></a>5.2 并行收集器相关参数</h3><p>| -XX:+UseParallelGC | Full GC采用parallel MSC<br>(此项待验证) |   | 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) |<br>| — | — | — | — |<br>| -XX:+UseParNewGC | 设置年轻代为并行收集 |   | 可与CMS收集同时使用<br>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 |<br>| -XX:ParallelGCThreads | 并行收集器的线程数 |   | 此值最好配置与处理器数目相等 同样适用于CMS |<br>| -XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) |   | 这个是JAVA 6出现的参数选项 |<br>| -XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) |   | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. |<br>| -XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 |   | 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. |<br>| -XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 |   | 公式为1/(1+n) |<br>| -XX:+<em>ScavengeBeforeFullGC</em> | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.) |</p>\n<h3 id=\"5-3-CMS相关参数\"><a href=\"#5-3-CMS相关参数\" class=\"headerlink\" title=\"5.3 CMS相关参数\"></a>5.3 CMS相关参数</h3><table>\n<thead>\n<tr>\n<th>-XX:+UseConcMarkSweepGC</th>\n<th>使用CMS内存收集</th>\n<th></th>\n<th>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+AggressiveHeap</td>\n<td></td>\n<td></td>\n<td>试图是使用大量的物理内存</td>\n</tr>\n<tr>\n<td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>至少需要256MB内存</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:CMSFullGCsBeforeCompaction</td>\n<td>多少次后进行内存压缩</td>\n<td></td>\n<td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>\n</tr>\n<tr>\n<td>-XX:+CMSParallelRemarkEnabled</td>\n<td>降低标记停顿</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX+UseCMSCompactAtFullCollection</td>\n<td>在FULL GC的时候， 对年老代的压缩</td>\n<td></td>\n<td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td>\n</tr>\n<tr>\n<td>可能会影响性能,但是可以消除碎片</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+UseCMSInitiatingOccupancyOnly</td>\n<td>使用手动定义初始化定义开始CMS收集</td>\n<td></td>\n<td>禁止hostspot自行触发CMS GC</td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingOccupancyFraction=70</td>\n<td>使用cms作为垃圾回收</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>使用70％后开始CMS收集</td>\n<td>92</td>\n<td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式<a href=\"http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value\">CMSInitiatingOccupancyFraction计算公式</a></td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingPermOccupancyFraction</td>\n<td>设置Perm Gen使用到达多少比率时触发</td>\n<td>92</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+CMSIncrementalMode</td>\n<td>设置为增量模式</td>\n<td></td>\n<td>用于单CPU情况</td>\n</tr>\n<tr>\n<td>-XX:+CMSClassUnloadingEnabled</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"5-4-辅助信息\"><a href=\"#5-4-辅助信息\" class=\"headerlink\" title=\"5.4 辅助信息\"></a>5.4 辅助信息</h3><p>| -XX:+PrintGC |   |   | 输出形式:<br>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>[Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] |<br>| — | — | — | — |<br>| -XX:+PrintGCDetails |   |   | 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] |<br>| -XX:+PrintGCTimeStamps |   |   |   |<br>| -XX:+PrintGC:PrintGCTimeStamps |   |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用<br>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] |<br>| -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用 |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |<br>| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 |   | 输出形式:Application time: 0.5291524 seconds |<br>| -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息 |   |   |<br>| -Xloggc:filename | 把相关日志信息记录到文件以便分析.<br>与上面几个配合使用 |   |   |<br>| -XX:+PrintClassHistogram | garbage collects before printing the histogram. |   |   |<br>| -XX:+PrintTLAB | 查看TLAB空间的使用情况 |   |   |<br>| XX:+PrintTenuringDistribution | 查看每次minor GC后新的存活周期的阈值 |   | Desired survivor size 1048576 bytes, new threshold 7 (max 15)<br>new threshold 7即标识新的存活周期的阈值为7。 |</p>\n<h2 id=\"6-参考\"><a href=\"#6-参考\" class=\"headerlink\" title=\"6.参考\"></a>6.参考</h2><p><a href=\"https://juejin.cn/post/6844903740848242695\">https://juejin.cn/post/6844903740848242695</a><br><a href=\"http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html\">http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html</a></p>\n"},{"title":"JVM内存与线程","_content":"\n\n## 1 内存\n\n### 1.1 内存一致性\n\n由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory），如图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170806222602143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol，等等。\n\n### 1.2 主内存与工作内存\n\nJava 内存模型的主要目标是定义程序各个变量的访问规则，即在虚拟机机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与 Java 编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存，线程间无法直接访问对方工作内存的中变量，线程间变量值得传递均需要通过主内存来完成。如图所示：\n\n### 1.3 内存间的交互操作\n\n关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：\n\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。\n\nunlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n\nread（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用\n\nload（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n\nuse（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n\nassign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n\nstore（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。\n\nwrite（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。\n\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间， store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺 序是 read a，read b，load b， load a。\n\nJava 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n\n不允许 read 和 load、store 和 write 操作之一单独出现\n\n不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n\n不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。\n\n一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。\n\n一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现\n\n如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值\n\n如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。\n\n对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。\n\n### 1.4 重排序\n\n在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：\n\n1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。\n\n2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 Java 源代码到最终实际执行的指令序列，会经过下面三种重排序：\n\n为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java 内存模型把内存屏障分为 LoadLoad、LoadStore、StoreLoad 和 StoreStore 四种：\n\n### 1.5 volatile 型变量\n\n当一个变量定义为 volatile 之后，它将具备两种特性：\n\n第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成\n\n由于 valatile 只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他的状态变量共同参与不变约束\n\n第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义\n\nJava 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store、write 操作时需要满足如下的规则：\n\n1.只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 操作可以认为是与线程 T 对变量 V 的 load 和 read 操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量 V 之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量 V 所作的修改后的值。\n\n2.只有当线程 T 对变量 V 执行的前一个动是 assign 的时候，线程 T 才能对变量 V 执行 store 操作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 操作的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 操作可以认为是与线程 T 对变量 V 的 store 和 write 操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改 V 后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量 V 的修改。\n\n3.假定操作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定操作 F 是操作 A 相关联的 load 或 store 操作，假定操作 P 是与操作 F 相应的对变量 V 的 read 或 write 操作；类型地，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定操作 G 是操作 B 相关联的 load 或 store 操作，假定操作 Q 是与操作 G 相应的对变量 V 的 read 或 write 操作。如果 A 先于 B，那么 P 先于 Q。这条规则要求 valitile 修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。\n\n### 1.6 对于 long 和 double 型变量的特殊规则\n\nJava 模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 为的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为两次 32 为的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性\n\n### 1.7 原子性、可见性和有序性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile 特殊规则保障新值可以立即同步到祝内存中。Synchronized 是在对一个变量执行 unlock 之前，必须把变量同步回主内存中（执行 store、write 操作）。被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 this 的引用传递出去，那在其他线程中就能看见 final 字段的值\n\n可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。\n\n### 1.8 先行发生原则\n\n这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序\n\n1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构\n\n2.管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序\n\n3.Volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序\n\n4.线程启动规则：Thread 对象的 start()方法先行发生于此线程的每一个动作\n\n5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行\n\n6.线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生\n\n7.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始\n\n8.传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论\n\n## 2 Java 线程\n\n协同式调度：线程的执行时间由线程本身控制\n\n抢占式调度：线程的执行时间由系统来分配\n\n### 2.1 状态转换\n\n1.新建\n\n2.运行：可能正在执行。可能正在等待 CPU 为它分配执行时间\n\n3.无限期等待：不会被分配 CUP 执行时间，它们要等待被其他线程显式唤醒\n\n4.限期等待：不会被分配 CUP 执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒\n\n5.阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生\n\n6.结束：已终止线程的线程状态，线程已经结束执行\n\n### 2.2 线程安全\n\n1、不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。\n\n2、绝对线程安全\n\n3、相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性\n\n4、线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用\n\n5、线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码\n\n### 2.3 线程安全的实现方法\n\n1.互斥同步：\n\n同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的\n\n在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，它经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，对应的在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止\n\nSynchronized，ReentrantLock 增加了一些高级功能\n\n1.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助\n\n2.公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁\n\n3.锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition 方法即可\n\n2.非阻塞同步\n\n3.无同步方案\n\n可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。\n\n判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的\n\n线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题\n\n### 2.4 锁优化\n\n适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁\n\n#### 2.4.1 自旋锁与自适应自旋\n\n自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁\n\n自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。\n\n#### 2.4.2 锁消除\n\n锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行\n\n#### 2.4.3 锁粗化\n\n如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部\n\n#### 2.4.4 轻量级锁\n\n#### 2.4.5 偏向锁\n\n它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS 操作都不做了\n\n如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步\n\n## 3 逃逸分析\n\n逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸\n\n如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化\n\n栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多\n\n同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉\n\n标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long 等及 refrence 类型等都不能在进一步分解，它们称为标量。\n\n如果一个数据可以继续分解，就称为聚合量，Java 中的对象就是最典型的聚合量\n\n如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替\n","source":"_posts/language/jvm/JVM内存与线程.md","raw":"---\ntitle: JVM内存与线程\ncategories:\n- java\n---\n\n\n## 1 内存\n\n### 1.1 内存一致性\n\n由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory），如图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170806222602143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol，等等。\n\n### 1.2 主内存与工作内存\n\nJava 内存模型的主要目标是定义程序各个变量的访问规则，即在虚拟机机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与 Java 编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存，线程间无法直接访问对方工作内存的中变量，线程间变量值得传递均需要通过主内存来完成。如图所示：\n\n### 1.3 内存间的交互操作\n\n关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：\n\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。\n\nunlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n\nread（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用\n\nload（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n\nuse（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n\nassign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n\nstore（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。\n\nwrite（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。\n\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间， store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺 序是 read a，read b，load b， load a。\n\nJava 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n\n不允许 read 和 load、store 和 write 操作之一单独出现\n\n不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n\n不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。\n\n一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。\n\n一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现\n\n如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值\n\n如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。\n\n对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。\n\n### 1.4 重排序\n\n在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：\n\n1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。\n\n2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 Java 源代码到最终实际执行的指令序列，会经过下面三种重排序：\n\n为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java 内存模型把内存屏障分为 LoadLoad、LoadStore、StoreLoad 和 StoreStore 四种：\n\n### 1.5 volatile 型变量\n\n当一个变量定义为 volatile 之后，它将具备两种特性：\n\n第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成\n\n由于 valatile 只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他的状态变量共同参与不变约束\n\n第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义\n\nJava 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store、write 操作时需要满足如下的规则：\n\n1.只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 操作可以认为是与线程 T 对变量 V 的 load 和 read 操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量 V 之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量 V 所作的修改后的值。\n\n2.只有当线程 T 对变量 V 执行的前一个动是 assign 的时候，线程 T 才能对变量 V 执行 store 操作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 操作的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 操作可以认为是与线程 T 对变量 V 的 store 和 write 操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改 V 后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量 V 的修改。\n\n3.假定操作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定操作 F 是操作 A 相关联的 load 或 store 操作，假定操作 P 是与操作 F 相应的对变量 V 的 read 或 write 操作；类型地，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定操作 G 是操作 B 相关联的 load 或 store 操作，假定操作 Q 是与操作 G 相应的对变量 V 的 read 或 write 操作。如果 A 先于 B，那么 P 先于 Q。这条规则要求 valitile 修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。\n\n### 1.6 对于 long 和 double 型变量的特殊规则\n\nJava 模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 为的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为两次 32 为的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性\n\n### 1.7 原子性、可见性和有序性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile 特殊规则保障新值可以立即同步到祝内存中。Synchronized 是在对一个变量执行 unlock 之前，必须把变量同步回主内存中（执行 store、write 操作）。被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 this 的引用传递出去，那在其他线程中就能看见 final 字段的值\n\n可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。\n\n### 1.8 先行发生原则\n\n这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序\n\n1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构\n\n2.管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序\n\n3.Volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序\n\n4.线程启动规则：Thread 对象的 start()方法先行发生于此线程的每一个动作\n\n5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行\n\n6.线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生\n\n7.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始\n\n8.传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论\n\n## 2 Java 线程\n\n协同式调度：线程的执行时间由线程本身控制\n\n抢占式调度：线程的执行时间由系统来分配\n\n### 2.1 状态转换\n\n1.新建\n\n2.运行：可能正在执行。可能正在等待 CPU 为它分配执行时间\n\n3.无限期等待：不会被分配 CUP 执行时间，它们要等待被其他线程显式唤醒\n\n4.限期等待：不会被分配 CUP 执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒\n\n5.阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生\n\n6.结束：已终止线程的线程状态，线程已经结束执行\n\n### 2.2 线程安全\n\n1、不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。\n\n2、绝对线程安全\n\n3、相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性\n\n4、线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用\n\n5、线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码\n\n### 2.3 线程安全的实现方法\n\n1.互斥同步：\n\n同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的\n\n在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，它经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，对应的在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止\n\nSynchronized，ReentrantLock 增加了一些高级功能\n\n1.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助\n\n2.公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁\n\n3.锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition 方法即可\n\n2.非阻塞同步\n\n3.无同步方案\n\n可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。\n\n判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的\n\n线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题\n\n### 2.4 锁优化\n\n适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁\n\n#### 2.4.1 自旋锁与自适应自旋\n\n自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁\n\n自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。\n\n#### 2.4.2 锁消除\n\n锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行\n\n#### 2.4.3 锁粗化\n\n如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部\n\n#### 2.4.4 轻量级锁\n\n#### 2.4.5 偏向锁\n\n它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS 操作都不做了\n\n如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步\n\n## 3 逃逸分析\n\n逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸\n\n如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化\n\n栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多\n\n同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉\n\n标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long 等及 refrence 类型等都不能在进一步分解，它们称为标量。\n\n如果一个数据可以继续分解，就称为聚合量，Java 中的对象就是最典型的聚合量\n\n如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替\n","slug":"language/jvm/JVM内存与线程","published":1,"date":"2021-07-31T09:04:32.018Z","updated":"2021-07-31T09:04:32.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bw000by2ukchsf7qww","content":"<h2 id=\"1-内存\"><a href=\"#1-内存\" class=\"headerlink\" title=\"1 内存\"></a>1 内存</h2><h3 id=\"1-1-内存一致性\"><a href=\"#1-1-内存一致性\" class=\"headerlink\" title=\"1.1 内存一致性\"></a>1.1 内存一致性</h3><p>由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory），如图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170806222602143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol，等等。</p>\n<h3 id=\"1-2-主内存与工作内存\"><a href=\"#1-2-主内存与工作内存\" class=\"headerlink\" title=\"1.2 主内存与工作内存\"></a>1.2 主内存与工作内存</h3><p>Java 内存模型的主要目标是定义程序各个变量的访问规则，即在虚拟机机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与 Java 编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存，线程间无法直接访问对方工作内存的中变量，线程间变量值得传递均需要通过主内存来完成。如图所示：</p>\n<h3 id=\"1-3-内存间的交互操作\"><a href=\"#1-3-内存间的交互操作\" class=\"headerlink\" title=\"1.3 内存间的交互操作\"></a>1.3 内存间的交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：</p>\n<p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>\n<p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>\n<p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</p>\n<p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>\n<p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>\n<p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>\n<p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p>\n<p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p>\n<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间， store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺 序是 read a，read b，load b， load a。</p>\n<p>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>\n<p>不允许 read 和 load、store 和 write 操作之一单独出现</p>\n<p>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>\n<p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</p>\n<p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>\n<p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现</p>\n<p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</p>\n<p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</p>\n<p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</p>\n<h3 id=\"1-4-重排序\"><a href=\"#1-4-重排序\" class=\"headerlink\" title=\"1.4 重排序\"></a>1.4 重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>\n<p>1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</p>\n<p>2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n<p>3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>\n<p>从 Java 源代码到最终实际执行的指令序列，会经过下面三种重排序：</p>\n<p>为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java 内存模型把内存屏障分为 LoadLoad、LoadStore、StoreLoad 和 StoreStore 四种：</p>\n<h3 id=\"1-5-volatile-型变量\"><a href=\"#1-5-volatile-型变量\" class=\"headerlink\" title=\"1.5 volatile 型变量\"></a>1.5 volatile 型变量</h3><p>当一个变量定义为 volatile 之后，它将具备两种特性：</p>\n<p>第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成</p>\n<p>由于 valatile 只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他的状态变量共同参与不变约束</p>\n<p>第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</p>\n<p>Java 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store、write 操作时需要满足如下的规则：</p>\n<p>1.只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 操作可以认为是与线程 T 对变量 V 的 load 和 read 操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量 V 之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量 V 所作的修改后的值。</p>\n<p>2.只有当线程 T 对变量 V 执行的前一个动是 assign 的时候，线程 T 才能对变量 V 执行 store 操作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 操作的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 操作可以认为是与线程 T 对变量 V 的 store 和 write 操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改 V 后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量 V 的修改。</p>\n<p>3.假定操作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定操作 F 是操作 A 相关联的 load 或 store 操作，假定操作 P 是与操作 F 相应的对变量 V 的 read 或 write 操作；类型地，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定操作 G 是操作 B 相关联的 load 或 store 操作，假定操作 Q 是与操作 G 相应的对变量 V 的 read 或 write 操作。如果 A 先于 B，那么 P 先于 Q。这条规则要求 valitile 修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。</p>\n<h3 id=\"1-6-对于-long-和-double-型变量的特殊规则\"><a href=\"#1-6-对于-long-和-double-型变量的特殊规则\" class=\"headerlink\" title=\"1.6 对于 long 和 double 型变量的特殊规则\"></a>1.6 对于 long 和 double 型变量的特殊规则</h3><p>Java 模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 为的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为两次 32 为的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性</p>\n<h3 id=\"1-7-原子性、可见性和有序性\"><a href=\"#1-7-原子性、可见性和有序性\" class=\"headerlink\" title=\"1.7 原子性、可见性和有序性\"></a>1.7 原子性、可见性和有序性</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile 特殊规则保障新值可以立即同步到祝内存中。Synchronized 是在对一个变量执行 unlock 之前，必须把变量同步回主内存中（执行 store、write 操作）。被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 this 的引用传递出去，那在其他线程中就能看见 final 字段的值</p>\n<p>可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>\n<h3 id=\"1-8-先行发生原则\"><a href=\"#1-8-先行发生原则\" class=\"headerlink\" title=\"1.8 先行发生原则\"></a>1.8 先行发生原则</h3><p>这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序</p>\n<p>1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</p>\n<p>2.管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</p>\n<p>3.Volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</p>\n<p>4.线程启动规则：Thread 对象的 start()方法先行发生于此线程的每一个动作</p>\n<p>5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</p>\n<p>6.线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生</p>\n<p>7.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始</p>\n<p>8.传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论</p>\n<h2 id=\"2-Java-线程\"><a href=\"#2-Java-线程\" class=\"headerlink\" title=\"2 Java 线程\"></a>2 Java 线程</h2><p>协同式调度：线程的执行时间由线程本身控制</p>\n<p>抢占式调度：线程的执行时间由系统来分配</p>\n<h3 id=\"2-1-状态转换\"><a href=\"#2-1-状态转换\" class=\"headerlink\" title=\"2.1 状态转换\"></a>2.1 状态转换</h3><p>1.新建</p>\n<p>2.运行：可能正在执行。可能正在等待 CPU 为它分配执行时间</p>\n<p>3.无限期等待：不会被分配 CUP 执行时间，它们要等待被其他线程显式唤醒</p>\n<p>4.限期等待：不会被分配 CUP 执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</p>\n<p>5.阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</p>\n<p>6.结束：已终止线程的线程状态，线程已经结束执行</p>\n<h3 id=\"2-2-线程安全\"><a href=\"#2-2-线程安全\" class=\"headerlink\" title=\"2.2 线程安全\"></a>2.2 线程安全</h3><p>1、不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。</p>\n<p>2、绝对线程安全</p>\n<p>3、相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</p>\n<p>4、线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用</p>\n<p>5、线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</p>\n<h3 id=\"2-3-线程安全的实现方法\"><a href=\"#2-3-线程安全的实现方法\" class=\"headerlink\" title=\"2.3 线程安全的实现方法\"></a>2.3 线程安全的实现方法</h3><p>1.互斥同步：</p>\n<p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的</p>\n<p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，它经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，对应的在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止</p>\n<p>Synchronized，ReentrantLock 增加了一些高级功能</p>\n<p>1.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</p>\n<p>2.公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</p>\n<p>3.锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition 方法即可</p>\n<p>2.非阻塞同步</p>\n<p>3.无同步方案</p>\n<p>可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p>\n<p>判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</p>\n<p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>\n<h3 id=\"2-4-锁优化\"><a href=\"#2-4-锁优化\" class=\"headerlink\" title=\"2.4 锁优化\"></a>2.4 锁优化</h3><p>适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁</p>\n<h4 id=\"2-4-1-自旋锁与自适应自旋\"><a href=\"#2-4-1-自旋锁与自适应自旋\" class=\"headerlink\" title=\"2.4.1 自旋锁与自适应自旋\"></a>2.4.1 自旋锁与自适应自旋</h4><p>自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</p>\n<p>自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。</p>\n<h4 id=\"2-4-2-锁消除\"><a href=\"#2-4-2-锁消除\" class=\"headerlink\" title=\"2.4.2 锁消除\"></a>2.4.2 锁消除</h4><p>锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</p>\n<h4 id=\"2-4-3-锁粗化\"><a href=\"#2-4-3-锁粗化\" class=\"headerlink\" title=\"2.4.3 锁粗化\"></a>2.4.3 锁粗化</h4><p>如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p>\n<h4 id=\"2-4-4-轻量级锁\"><a href=\"#2-4-4-轻量级锁\" class=\"headerlink\" title=\"2.4.4 轻量级锁\"></a>2.4.4 轻量级锁</h4><h4 id=\"2-4-5-偏向锁\"><a href=\"#2-4-5-偏向锁\" class=\"headerlink\" title=\"2.4.5 偏向锁\"></a>2.4.5 偏向锁</h4><p>它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS 操作都不做了</p>\n<p>如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步</p>\n<h2 id=\"3-逃逸分析\"><a href=\"#3-逃逸分析\" class=\"headerlink\" title=\"3 逃逸分析\"></a>3 逃逸分析</h2><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</p>\n<p>如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</p>\n<p>栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多</p>\n<p>同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉</p>\n<p>标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long 等及 refrence 类型等都不能在进一步分解，它们称为标量。</p>\n<p>如果一个数据可以继续分解，就称为聚合量，Java 中的对象就是最典型的聚合量</p>\n<p>如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-内存\"><a href=\"#1-内存\" class=\"headerlink\" title=\"1 内存\"></a>1 内存</h2><h3 id=\"1-1-内存一致性\"><a href=\"#1-1-内存一致性\" class=\"headerlink\" title=\"1.1 内存一致性\"></a>1.1 内存一致性</h3><p>由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory），如图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170806222602143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol，等等。</p>\n<h3 id=\"1-2-主内存与工作内存\"><a href=\"#1-2-主内存与工作内存\" class=\"headerlink\" title=\"1.2 主内存与工作内存\"></a>1.2 主内存与工作内存</h3><p>Java 内存模型的主要目标是定义程序各个变量的访问规则，即在虚拟机机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与 Java 编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存，线程间无法直接访问对方工作内存的中变量，线程间变量值得传递均需要通过主内存来完成。如图所示：</p>\n<h3 id=\"1-3-内存间的交互操作\"><a href=\"#1-3-内存间的交互操作\" class=\"headerlink\" title=\"1.3 内存间的交互操作\"></a>1.3 内存间的交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：</p>\n<p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>\n<p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>\n<p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</p>\n<p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>\n<p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>\n<p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>\n<p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p>\n<p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p>\n<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间， store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺 序是 read a，read b，load b， load a。</p>\n<p>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>\n<p>不允许 read 和 load、store 和 write 操作之一单独出现</p>\n<p>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>\n<p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</p>\n<p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>\n<p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现</p>\n<p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</p>\n<p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</p>\n<p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</p>\n<h3 id=\"1-4-重排序\"><a href=\"#1-4-重排序\" class=\"headerlink\" title=\"1.4 重排序\"></a>1.4 重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>\n<p>1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</p>\n<p>2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n<p>3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>\n<p>从 Java 源代码到最终实际执行的指令序列，会经过下面三种重排序：</p>\n<p>为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java 内存模型把内存屏障分为 LoadLoad、LoadStore、StoreLoad 和 StoreStore 四种：</p>\n<h3 id=\"1-5-volatile-型变量\"><a href=\"#1-5-volatile-型变量\" class=\"headerlink\" title=\"1.5 volatile 型变量\"></a>1.5 volatile 型变量</h3><p>当一个变量定义为 volatile 之后，它将具备两种特性：</p>\n<p>第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成</p>\n<p>由于 valatile 只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他的状态变量共同参与不变约束</p>\n<p>第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</p>\n<p>Java 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store、write 操作时需要满足如下的规则：</p>\n<p>1.只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 操作可以认为是与线程 T 对变量 V 的 load 和 read 操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量 V 之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量 V 所作的修改后的值。</p>\n<p>2.只有当线程 T 对变量 V 执行的前一个动是 assign 的时候，线程 T 才能对变量 V 执行 store 操作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 操作的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 操作可以认为是与线程 T 对变量 V 的 store 和 write 操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改 V 后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量 V 的修改。</p>\n<p>3.假定操作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定操作 F 是操作 A 相关联的 load 或 store 操作，假定操作 P 是与操作 F 相应的对变量 V 的 read 或 write 操作；类型地，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定操作 G 是操作 B 相关联的 load 或 store 操作，假定操作 Q 是与操作 G 相应的对变量 V 的 read 或 write 操作。如果 A 先于 B，那么 P 先于 Q。这条规则要求 valitile 修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。</p>\n<h3 id=\"1-6-对于-long-和-double-型变量的特殊规则\"><a href=\"#1-6-对于-long-和-double-型变量的特殊规则\" class=\"headerlink\" title=\"1.6 对于 long 和 double 型变量的特殊规则\"></a>1.6 对于 long 和 double 型变量的特殊规则</h3><p>Java 模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 为的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为两次 32 为的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性</p>\n<h3 id=\"1-7-原子性、可见性和有序性\"><a href=\"#1-7-原子性、可见性和有序性\" class=\"headerlink\" title=\"1.7 原子性、可见性和有序性\"></a>1.7 原子性、可见性和有序性</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile 特殊规则保障新值可以立即同步到祝内存中。Synchronized 是在对一个变量执行 unlock 之前，必须把变量同步回主内存中（执行 store、write 操作）。被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 this 的引用传递出去，那在其他线程中就能看见 final 字段的值</p>\n<p>可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>\n<h3 id=\"1-8-先行发生原则\"><a href=\"#1-8-先行发生原则\" class=\"headerlink\" title=\"1.8 先行发生原则\"></a>1.8 先行发生原则</h3><p>这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序</p>\n<p>1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</p>\n<p>2.管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</p>\n<p>3.Volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</p>\n<p>4.线程启动规则：Thread 对象的 start()方法先行发生于此线程的每一个动作</p>\n<p>5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</p>\n<p>6.线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生</p>\n<p>7.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始</p>\n<p>8.传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论</p>\n<h2 id=\"2-Java-线程\"><a href=\"#2-Java-线程\" class=\"headerlink\" title=\"2 Java 线程\"></a>2 Java 线程</h2><p>协同式调度：线程的执行时间由线程本身控制</p>\n<p>抢占式调度：线程的执行时间由系统来分配</p>\n<h3 id=\"2-1-状态转换\"><a href=\"#2-1-状态转换\" class=\"headerlink\" title=\"2.1 状态转换\"></a>2.1 状态转换</h3><p>1.新建</p>\n<p>2.运行：可能正在执行。可能正在等待 CPU 为它分配执行时间</p>\n<p>3.无限期等待：不会被分配 CUP 执行时间，它们要等待被其他线程显式唤醒</p>\n<p>4.限期等待：不会被分配 CUP 执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</p>\n<p>5.阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</p>\n<p>6.结束：已终止线程的线程状态，线程已经结束执行</p>\n<h3 id=\"2-2-线程安全\"><a href=\"#2-2-线程安全\" class=\"headerlink\" title=\"2.2 线程安全\"></a>2.2 线程安全</h3><p>1、不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。</p>\n<p>2、绝对线程安全</p>\n<p>3、相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</p>\n<p>4、线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用</p>\n<p>5、线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</p>\n<h3 id=\"2-3-线程安全的实现方法\"><a href=\"#2-3-线程安全的实现方法\" class=\"headerlink\" title=\"2.3 线程安全的实现方法\"></a>2.3 线程安全的实现方法</h3><p>1.互斥同步：</p>\n<p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的</p>\n<p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，它经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，对应的在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止</p>\n<p>Synchronized，ReentrantLock 增加了一些高级功能</p>\n<p>1.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</p>\n<p>2.公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</p>\n<p>3.锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition 方法即可</p>\n<p>2.非阻塞同步</p>\n<p>3.无同步方案</p>\n<p>可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p>\n<p>判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</p>\n<p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>\n<h3 id=\"2-4-锁优化\"><a href=\"#2-4-锁优化\" class=\"headerlink\" title=\"2.4 锁优化\"></a>2.4 锁优化</h3><p>适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁</p>\n<h4 id=\"2-4-1-自旋锁与自适应自旋\"><a href=\"#2-4-1-自旋锁与自适应自旋\" class=\"headerlink\" title=\"2.4.1 自旋锁与自适应自旋\"></a>2.4.1 自旋锁与自适应自旋</h4><p>自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</p>\n<p>自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。</p>\n<h4 id=\"2-4-2-锁消除\"><a href=\"#2-4-2-锁消除\" class=\"headerlink\" title=\"2.4.2 锁消除\"></a>2.4.2 锁消除</h4><p>锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</p>\n<h4 id=\"2-4-3-锁粗化\"><a href=\"#2-4-3-锁粗化\" class=\"headerlink\" title=\"2.4.3 锁粗化\"></a>2.4.3 锁粗化</h4><p>如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p>\n<h4 id=\"2-4-4-轻量级锁\"><a href=\"#2-4-4-轻量级锁\" class=\"headerlink\" title=\"2.4.4 轻量级锁\"></a>2.4.4 轻量级锁</h4><h4 id=\"2-4-5-偏向锁\"><a href=\"#2-4-5-偏向锁\" class=\"headerlink\" title=\"2.4.5 偏向锁\"></a>2.4.5 偏向锁</h4><p>它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS 操作都不做了</p>\n<p>如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步</p>\n<h2 id=\"3-逃逸分析\"><a href=\"#3-逃逸分析\" class=\"headerlink\" title=\"3 逃逸分析\"></a>3 逃逸分析</h2><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</p>\n<p>如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</p>\n<p>栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多</p>\n<p>同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉</p>\n<p>标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long 等及 refrence 类型等都不能在进一步分解，它们称为标量。</p>\n<p>如果一个数据可以继续分解，就称为聚合量，Java 中的对象就是最典型的聚合量</p>\n<p>如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替</p>\n"},{"title":"JVM内存模型","_content":"\n\n\n##<center>JVM 内存模型</center> 1.内存模型结构图\n\n![**这里写图片描述**](http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n| 名称         | 特征                                                     | 作用                                                                      | 配置参数                           | 异常                                 |\n| ------------ | -------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------- | ------------------------------------ |\n| 程序计数器   | 占用内存小，线程私有， 生命周期与线程相同                | 大致为字节码行号指示器                                                    | 无                                 | 无                                   |\n| 虚拟机栈     | 线程私有，生命周期与线程相同，使用连续的内存空间         | Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息 | -Xss                               | OutOfMemoryError，StackOverflowError |\n| java 堆      | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 保存对象实例，所有对象实例（包括数组）都要在堆上分配                      | -Xms-Xsx -Xmn                      | OutOfMemoryError                     |\n| 方法区       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据  | -XX:PermSize:16M-XX:MaxPermSize64M | OutOfMemoryError                     |\n| 运行时常量池 | 方法区的一部分，具有动态性                               | 存放字面量及符号引用                                                      | 无                                 | 无                                   |\n\n<h5>1.1 程序计数器</h5>\n程序 计数器（ Program Counter Register） 是一 块 较小 的 内存 空间， 它的 作用 可以 看做 是 当前 线程 所 执行 的 字节 码 的 行号 指示器。 在 虚拟 机 的 概念 模型 里（ 仅是 概念 模型， 各种 虚拟 机 可能 会 通过 一些 更 高效 的 方式 去 实现）， 字节 码 解释器 工作 时 就是 通过 改变 这个 计数器 的 值 来 选取 下一 条 需要 执行 的 字节 码 指令， 分支、 循环、 跳 转、 异常 处理、 线程 恢复 等 基础 功能 都 需要 依赖 这个 计数器 来 完成。\n由于 Java 虚拟 机 的 多 线程 是 通过 线程 轮流 切换 并 分配 处理器 执行 时间 的 方式 来 实现 的， 在任 何 一个 确定 的 时刻， 一个 处理器（ 对于 多 核 处理器 来说 是一 个 内核） 只会 执行 一条 线程 中的 指令。 因此， 为了 线程 切换 后能 恢复 到 正确 的 执行 位置， 每条 线程 都 需要 有一个 独立 的 程序 计数器， 各条 线程 之间 的 计数器 互不 影响， 独立 存储， 我们 称 这类 内存 区域 为“ 线程 私有” 的 内存。 如果 线程 正在 执行 的 是 一个 Java 方法， 这个 计数器 记录 的 是 正在 执行 的 虚拟 机 字节 码 指令 的 地址； 如果 正在 执 行的 是 Natvie 方法， 这个 计数器 值 则为 空（ Undefined）。 此 内存 区域 是 唯一 一个 在 Java 虚拟 机 规范 中 没有 规定 任何 OutOfMemoryError 情况 的 区域。\n\n<h5>1.2 Java 虚拟 机 栈</h5>\n与 程序 计数器 一样， Java 虚拟 机 栈（ Java Virtual Machine Stacks） 也是 线程 私有 的， 它的 生命 周期 与 线程 相同。 虚拟 机 栈 描述 的 是 Java 方法 执行 的 内存 模型： 每个 方法 被 执行 的 时候 都会 同时 创建 一个 栈 帧（ Stack Frame[ 1]） 用于 存储 局部 变 量表、 操作 栈、 动态 链接、 方法 出口 等 信息。 每一个 方法 被 调用 直至 执行 完成 的 过程， 就 对应 着 一个 栈 帧 在 虚拟 机 栈 中 从 入栈 到 出 栈 的 过程,对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 经常 有人 把 Java 内存 区 分为 堆 内存（ Heap） 和 栈 内存（ Stack）， 这种 分法 比较 粗糙， Java 内存 区域 的 划分 实际上 远比 这 复杂。 这种 划分 方式 的 流行 只能 说明 大多数 程序员 最 关注 的、 与 对象 内存 分配 关系 最 密切 的 内存 区域 是 这 两块。 其中 所指 的“ 堆” 在后面 会 专门 讲述， 而 所指 的“ 栈” 就是 现在 讲的 虚拟 机 栈， 或者 说是 虚拟 机 栈 中的 局部 变量 表 部分。 局部 变量 表 存放 了 编译 期 可知 的 各种 基本 数据 类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象 引用（ reference 类型， 它不 等同 于 对象 本身， 根据 不同 的 虚拟 机 实现， 它可 能 是一 个 指向 对象 起始 地址 的 引用 指针， 也可能 指向 一个 代表 对象 的 句柄 或者 其他 与此 对象 相关 的 位置） 和 returnAddress 类型（ 指向 了 一条 字节 码 指令 的 地址）。 其中 64 位 长度 的 long 和 double 类型 的 数据 会 占用 2 个 局部 变量 空间（Slot）， 其余 的 数据 类型 只占 用 1 个。 局部 变量 表 所需 的 内存 空间 在编 译 期间 完成 分配， 当 进入 一个 方法 时， 这个 方法 需 要在 帧 中 分配 多大 的 局部 变量 空间 是 完全 确定 的， 在 方法 运行 期间 不会 改变 局部 变 量表 的 大小。 在 Java 虚拟 机 规范 中， 对这 个 区域 规定了 两种 异常 状况： 如果 线程 请求 的 栈 深度 大于 虚拟 机 所 允许 的 深度， 将 抛出 StackOverflowError 异常； 如果 虚拟 机 栈 可以 动态 扩展（ 当前 大部分 的 Java 虚拟 机 都可 动态 扩展， 只不过 Java 虚拟 机 规范 中 也 允许 固定 长度 的 虚拟 机 栈）， 当 扩展 时 无法 申请 到 足够 的 内存 时会 抛出 OutOfMemoryError 异常。\n<h6>1.2.1 局部变量表</h6>\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。\n局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。\nreference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\nreturnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。\n虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。\n Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。\n 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n<h6>1.2.2 操作数栈</h6>\n和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。\n虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。\n虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中。如下演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：\n```java\n   begin  \n   iload_0    // push the int in local variable 0 ontothe stack  \n   iload_1    //push the int in local variable 1 onto the stack  \n   iadd       // pop two ints, add them, push result  \n   istore_2   // pop int, store into local variable 2  \n   end\n```\n1. 指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中\n2. iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈\n3. istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。\n4. 局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。\n\n![**这里写图片描述**](http://img.blog.csdn.net/20170727201918687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)<center>\n\n<h6>1.2.3 动态连接<h6>\n虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。\n如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。\n<h6> 1.2.4 返回地址 <h6>\n方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。\n不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。\n方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。\n\n![这里写图片描述](http://img.blog.csdn.net/20170727204302809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n\n<h6> 1.2.5 异常 <h6>\n在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。如下代码为请求大于虚拟机堆栈深度所出现的异常\n\n```\n    java\npackage com.sf.jvm;\n/**\n* VM Args：- Xss128k\n*/\npublic class JavaVMStackSOF {\n  private intstackLength=1;\n  public void stackLeak() {\n    stackLength++;\n    stackLeak();\n  }\n  public static void main(String[] args)throwsThrowable {\n    JavaVMStackSOF oom =newJavaVMStackSOF();\n    try{\n      oom.stackLeak();\n    }catch(Throwable e) {\n      System.out.println(\" stack length:\" + oom.stackLength);\n      throw e;\n    }\n  }\n}\n```\n\n运行出现如下情况：\n\n```\nstack length:22337\nException in thread \"main\" java.lang.StackOverflowError\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\n```\n\n<h4>1.3 本地 方法 栈</h4>\n\n本地 方法 栈（ Native Method Stacks） 与 虚拟 机 栈 所 发挥 的 作用 是非 常 相似 的， 其 区别 不过 是 虚拟 机 栈 为 虚拟 机 执行 Java 方法（ 也就是 字节 码） 服务， 而 本地 方法 栈 则是 为 虚拟 机 使 用到 的 Native 方法 服务。 虚拟 机 规范 中 对本 地 方法 栈 中的 方法 使用 的 语言、 使用 方式 与 数据 结构 并没有 强制 规定， 因此 具体 的 虚拟 机 可以 自由 实现 它。 甚至 有的 虚拟 机（ 譬如 Sun HotSpot 虚拟 机） 直接 就把 本地 方法 栈 和 虚拟 机 栈 合二为一。 与 虚拟 机 栈 一样， 本地 方法 栈 区域 也会 抛出 StackOverflowError 和 OutOfMemoryError 异常。\n\n对于一个运行中的 Java 程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。\n　　本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让 Java 程序调用本地方法。\n　　任何本地方法接口都会使用某种本地方法栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。\n　　如果某个虚拟机实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当 C 程序调用一个 C 函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。\n　　很可能本地方法接口需要回调 Java 虚拟机中的 Java 方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个 Java 栈。\n　　![这里写图片描述](http://img.blog.csdn.net/20170727205440144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n　　这幅图展示了 JAVA 虚拟机内部线程运行的全景图。当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个 Java 方法，一个线程可能在整个生命周期中都执行 Java 方法，操作它的 Java 栈；或者它可能毫无障碍地在 Java 栈和本地方法栈之间跳转。\n\n该线程首先调用了两个 Java 方法，而第二个 Java 方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个 C 语言栈，其间有两个 C 函数，第一个 C 函数被第二个 Java 方法当做本地方法调用，而这个 C 函数又调用了第二个 C 函数。之后第二个 C 函数又通过本地方法接口回调了一个 Java 方法（第三个 Java 方法），最终这个 Java 方法又调用了一个 Java 方法（它成为图中的当前方法）。\n内存溢出实例：\n\n```java\npackagecom.sf.jvm;\n/**\n* VM Args：\n* -Xss2M\n*/\npublic classJavaVMStackOOM {\n   private void dontStop() {\n      while(true) {\n         try{\n           Thread.sleep(100000);\n        }catch(InterruptedException e) {\n\t\t   e.printStackTrace();\n\t    }\n\t  }\n  }\n\t  public void stackLeakByThread() {\n\t\tint threadNum =0;\n\t    while(true) {\n\t\t    Thread thread =newThread(newRunnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\tdontStop();\n\t\t\t\t}\n\t\t});\n\t\tthread.start();\n\t\tthreadNum++;\n\t\t}\n\t}\n\tpublic static void main(String[] args)throwsThrowable {\n\t\tJavaVMStackOOM oom =newJavaVMStackOOM();\n\t\toom.stackLeakByThread();\n\t}\n}\n\n运行程序抛出如下异常：\nException in thread \"main\" java. lang. OutOfMemoryError: unable to create new native thread\n```\n\n<h4>1.4 Java 堆<h4>\n\nJava 堆（ Java Heap） 是 Java 虚拟 机 所 管理 的 内存 中最 大的 一块。 Java 堆 是 被 所有 线程 共享 的 一块 内存 区域， 在 虚拟 机 启动 时 创建。 此 内存 区域 的 唯一 目的 就是 存放 对象 实例， 几乎 所有 的 对象 实例 都在 这里 分配 内存。 这一 点在 Java 虚拟 机 规范 中的 描述 是： 所有 的 对象 实例 以及 数组 都 要在 堆 上 分配[ 2]， 但是 随着 JIT 编译器 的 发展 与 逃逸 分析 技术 的 逐渐 成熟， 栈 上 分配、 标量 替换[ 3] 优化 技术 将会 导致 一些 微妙 的 变化 发生， 所有 的 对象 都 分配 在 堆 上 也 渐渐 变得 不是 那么“ 绝对” 了。 Java 堆 是 垃圾 收集 器 管理 的 主要 区域， 因此 很多 时候 也 被 称做“ GC 堆”（ Garbage Collected Heap）。 如果 从内 存 回收 的 角度 看， 由于 现在 收集 器 基本 都是 采 用的 分 代收 集 算法， 所以 Java 堆 中 还可以 细分 为： 新生代 和 老 年代； 再 细致 一点 的 有 Eden 空间、 From Survivor 空间、 To Survivor 空间 等。 如果 从内 存 分配 的 角度 看， 线程 共享 的 Java 堆 中 可能 划分 出 多个 线程 私有 的 分配 缓冲区（ Thread Local Allocation Buffer， TLAB）。 不过， 无论如何 划分， 都与 存放 内容 无关， 无论 哪个 区域， 存储 的 都 仍然是 对象 实例， 进一步 划分 的 目的 是 为了 更好 地 回收 内存， 或者 更快 地 分配 内存。 在 本章 中， 我们 仅仅 针对 内存 区域 的 作用 进行 讨论， Java 堆 中的 上述 各个 区域 的 分配 和 回收 等 细节 将会 是 下 一章 的 主题。 根据 Java 虚拟 机 规范 的 规定， Java 堆 可以 处于 物理上 不连续 的 内存 空间 中， 只要 逻辑上 是 连续 的 即可， 就 像 我们 的 磁盘 空间 一样。 在 实现 时， 既可以 实现 成 固定 大小 的， 也可以 是 可扩展 的， 不过 当前 主流 的 虚拟 机 都是 按照 可扩展 来 实现 的（ 通过- Xmx 和- Xms 控制）。\nJava 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。\n在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。如下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170727210308831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n\n从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。\n默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。\n老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。\n默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。\nJVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。\n因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间。\n\nGC 堆\nJava 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。\nMinor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。\n新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。\n当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。\n当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳\n( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。\n但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。\nFull GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。\n现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。\n另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。\n\n设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。\n\n| jvm 参数                        | 解释                                                                                                                    |\n| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| -Xms                            | 初始堆大小。如：-Xms256m                                                                                                |\n| -Xmx                            | 最大堆大小。如：-Xmx512m                                                                                                |\n| -Xmn                            | 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% |\n| -Xss                            | JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。                                         |\n| -XX:NewRatio                    | 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3                                       |\n| -XX:SurvivorRatio               | 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10                  |\n| -XX:PermSize                    | 永久代(方法区)的初始大小                                                                                                |\n| -XX:MaxPermSize                 | 永久代(方法区)的最大值                                                                                                  |\n| -XX:+PrintGCDetails             | 打印 GC 信息                                                                                                            |\n| -XX:+HeapDumpOnOutOfMemoryError | 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用                                                        |\n\nJava 堆 用于 储存 对象 实例， 我们 只要 不断 地 创建 对象， 并且 保证 GC Roots 到 对象 之间 有可 达 路径 来 避免 垃圾 回收 机制 清除 这些 对象， 就会 在 对象 数量 到达 最 大堆 的 容量 限制 后 产生 内存 溢出 异常。实例如下：\n\n```java\npackagecom.sf.jvm;\nimportjava.util.ArrayList;\nimportjava.util.List;\n/**\n* VM Args：\n* -Xms20m -Xmx20m\n* -XX:+HeapDumpOnOutOfMemoryError\n* -XX:+PrintGCDetails\n*/\npublic classHeapOutOfMemory {\n\n\tpublic static void main(String[] args) {\n\t\toutOfMemory();\n\t}\n\tstatic void noOutOfMemory(){\n\t\twhile(true) {\n\t\t\tnewOOMObject();\n\t\t}\n\t}\n\tstatic void outOfMemory(){\n\t\tList<OOMObject> list =newArrayList<OOMObject>();\n\t\twhile(true) {\n\t\t\tlist.add(newOOMObject());\n\t\t}\n\t}\n}\nclassOOMObject {\n\tbytemem[] =new byte[2014];\n}\n异常信息如下：\n[GC (Allocation Failure) [PSYoungGen: 5632K->512K(6144K)] 5632K->5024K(19968K), 0.0027725 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n[GC (Allocation Failure) [PSYoungGen: 6144K->504K(6144K)] 10656K->11432K(19968K), 0.0022202 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n[Full GC (Ergonomics) [PSYoungGen: 504K->0K(6144K)] [ParOldGen: 10928K->10092K(13824K)] 11432K->10092K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0149535 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]\n........\n[Full GC (Allocation Failure) [PSYoungGen: 5632K->5632K(6144K)] [ParOldGen: 13823K->13823K(13824K)] 19455K->19455K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0086009 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid2780.hprof ...\nHeap dump file created [20898436 bytes in 0.027 secs]\n[Full GC (Ergonomics) Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\nat com.sf.jvm.OOMObject.<init>(HeapOutOfMemory.java:29)\nat com.sf.jvm.HeapOutOfMemory.outOfMemory(HeapOutOfMemory.java:23)\nat com.sf.jvm.HeapOutOfMemory.main(HeapOutOfMemory.java:12)\n[PSYoungGen: 5632K->0K(6144K)] [ParOldGen: 13823K->579K(13824K)] 19455K->579K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0096016 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\nHeap\nPSYoungGen total 6144K, used 177K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)\neden space 5632K, 3% used [0x00000000ff980000,0x00000000ff9ac4a0,0x00000000fff00000)\nfrom space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\nto space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\nParOldGen total 13824K, used 579K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)\nobject space 13824K, 4% used [0x00000000fec00000,0x00000000fec90c20,0x00000000ff980000)\nMetaspace used 3005K, capacity 4496K, committed 4864K, reserved 1056768K\nclass space used 326K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n用 jvisualvm.exe 打开查看 dump，发现主要是 OOMobject 不被释放。\n\n<h4>1.5 方法 区<h4>\n      <h5>1.5.1 方法区</h5> \n方法 区（ Method Area） 与 Java 堆 一样， 是 各个 线程 共享 的 内存 区域， 它 用于 存储 已被 虚拟 机 加载 的 类 信息、 常量、 静态 变量、 即时 编译器 编译 后的 代码 等 数据。 虽然 Java 虚拟 机 规范 把 方法 区 描述为 堆 的 一个 逻辑 部分， 但是 它 却有 一个 别名 叫做 Non- Heap（ 非 堆）， 目的 应该 是与 Java 堆 区分 开来。 对于 习惯 在 HotSpot 虚拟 机上 开发 和 部署 程序 的 开发者 来说， 很多人 愿意 把 方法 区 称为“ 永久 代”（ Permanent Generation）， 本质上 两者 并不 等价， 仅仅 是因为 HotSpot 虚拟 机 的 设计 团队 选择 把 GC 分 代收 集 扩展 至 方法 区， 或者说 使用 永久 代 来 实现 方法 区 而已。 对于 其他 虚拟 机（ 如 BEA JRockit、 IBM J9 等） 来说 是 不存在 永久 代 的 概念 的。 即使是 HotSpot 虚拟 机 本身， 根据 官方 发布 的 路线 图 信息， 现在 也有 放弃 永久 代 并“ 搬家” 至 Native Memory 来 实现 方法 区 的 规划 了。 Java 虚拟 机 规范 对这 个 区域 的 限制 非常 宽松， 除了 和 Java 堆 一样 不需要 连续 的 内存 和 可以 选择 固定 大小 或者 可扩展 外， 还可以 选择 不实 现 垃圾 收集。 相对而言， 垃圾 收集 行为 在这 个 区域 是 比较 少 出现 的， 但 并非 数据 进入 了 方法 区 就 如 永久 代 的 名字 一样“ 永久” 存在 了。 这个 区域 的 内存 回收 目标 主要 是 针对 常量 池 的 回收 和 对 类型 的 卸载， 一般来说 这个 区域 的 回收“ 成绩” 比较 难以 令人满意， 尤其是 类型 的 卸载， 条件 相当 苛刻， 但是 这部 分 区域 的 回收 确实 是有 必要 的。 在 Sun 公司 的 BUG 列表 中， 曾 出现 过 的 若干个 严重 的 BUG 就是 由于 低 版本 的 HotSpot 虚拟 机 对此 区域 未完 全 回收 而 导致 内存 泄漏。 根据 Java 虚拟 机 规范 的 规定， 当 方法 区 无法 满足 内存 分配 需求 时， 将 抛出 OutOfMemoryError 异常。方法 区 用于 存放 Class 的 相关 信息， 如 类 名、 访问 修饰 符、 常量 池、 字段 描述、 方法 描述 等。 对于 这个 区域 的 测试， 基本 的 思路 是 运行时 产生 大量 的 类 去 填满 方法 区， 直到 溢出。 虽然 直接 使用 Java SE API 也可以 动态 产生 类（ 如 反射 时 的 GeneratedConstructorAccessor 和 动态 代理 等）， 但在 本次 实验 中 操作 起来 比较 麻烦。 在 代码 清单 2- 5 中， 笔者 借助 CGLib[ 3] 直接 操作 字节 码 运行时， 生成 了 大量 的 动态 类。 值得 特别 注意 的 是， 我们 在这 个 例子 中 模拟 的 场景 并非 纯粹 是一 个 实验， 这样 的 应用 经常 会 出现 在 实际 应用 中： 当前 的 很多 主流 框架， 如 Spring 和 Hibernate 对 类 进行 增强 时， 都会 使用 到 CGLib 这类 字节 码 技术， 增 强的 类 越多， 就 需要 越大 的 方法 区 来 保证 动态 生成 的 Class 可以 加载 入 内存。\n方法 区 溢出 也是 一种 常见 的 内存 溢出 异常， 一个 类 如果 要被 垃圾 收集 器 回收 掉， 判定 条件 是非 常 苛刻 的。 在 经常 动态 生成 大量 Class 的 应用 中， 需要 特别 注意 类 的 回收 状况。 这类 场景 除了 上面 提到 的 程序 使用 了 GCLib 字节 码 增强 外， 常见 的 还有： 大量 JSP 或 动态 产生 JSP 文件 的 应用（ JSP 第一次 运行时 需要 编译 为 Java 类）、 基于 OSGi 的 应用（ 即使是 同一个 类 文件， 被 不同 的 加载 器 加载 也会 视为 不同 的 类） 等。\n代码 清单 2- 5 　 借助 CGLib 使得 方法 区 出现 内存 溢出 异常\n```java\npackagecom.sf.jvm;\n/**\n* VM Args： -XX: PermSize= 10M -XX: MaxPermSize= 10M\n*/\npublic class JavaMethodAreaOOM {\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tEnhancer enhancer =newEnhancer();\n\t\t\tenhancer.setSuperclass(OOMObject.class);\n\t\t\tenhancer.setUseCache(false);\n\t\t\tenhancer.setCallback(newMethodInterceptor() {\n\t\t\t\tpublic Object intercept(Object obj, Method method, \n\t\t\t\t\tObject[] args, MethodProxy proxy)throwsThrowable {\n\t\t\t\t\treturnproxy.invokeSuper(obj, args);\n\t\t\t\t}\n\t\t\t});\n\t\t\tenhancer.create();\n\t\t}\n\t}\n\tstatic classOOMObject {\n\t}\n}\n运行 结果：\nCaused by: \njava. lang. OutOfMemoryError: \nPermGen space at java. lang. ClassLoader. defineClass1( Native Method)\nat java. lang. ClassLoader. defineClassCond( ClassLoader. java: 632) \nat java. lang. ClassLoader. defineClass( ClassLoader. java: 616）\n```\n\n<h5>1.5.2 运行时常量池</h5>\n 运行时 常量 池（ Runtime Constant Pool） 是 方法 区 的 一部分。 Class 文件 中 除了 有 类 的 版本、 字段、 方法、接口 等 描述 等 信息 外， 还有 一项 信息 是 常量 池（ Constant Pool Table）， 用于 存放 编译 期 生成 的 各种 字面 量 和 符号 引用， 这部 分 内容 将 在 类 加载 后 存放 到 方法 区 的 运行时 常量 池 中。 Java 虚拟 机 对 Class 文件 的 每一 部分（ 自然 也 包括 常量 池） 的 格式 都有 严格 的 规定， 每一个 字节 用于 存储 哪种 数据 都 必须 符合 规范 上 的 要求， 这样 才会 被 虚拟 机 认可、 装载 和 执行。 但 对于 运行时 常量 池， Java 虚拟 机 规范 没有 做 任何 细节 的 要求， 不同 的 提供 商 实现 的 虚拟 机 可以 按照 自己的 需要 来 实现 这个 内存 区域。 不过， 一般来说， 除了 保存 Class 文件 中 描述 的 符号 引用 外， 还会 把 翻译 出来 的 直接 引用 也 存储 在 运行时 常量 池 中[ 4]。 运行时 常量 池 相对于 Class 文件 常量 池 的 另外 一个 重要 特征 是 具备 动态 性， Java 语言 并不 要求 常量 一定 只能 在 编译 期 产生， 也就是 并非 预置 入 Class 文件 中 常量 池 的 内容 才能 进入 方法 区 运行时 常量 池， 运行 期间 也可 能将 新的 常量 放入 池 中， 这种 特性 被 开发 人员 利用 得比 较多 的 便是 String 类 的 intern() 方法。 既然 运行时 常量 池 是 方法 区 的 一部分， 自然 会受 到 方法 区 内存 的 限制， 当 常量 池 无法 再 申请 到 内存 时会 抛出 OutOfMemoryError 异常。\n \n```java\npackage com.sf.jvm;\nimportjava.util.ArrayList;\nimportjava.util.List;\n/**\n* VM Args：- XX:PermSize=10M -XX:MaxPermSize=10M\n*/\npublic class RuntimeConstantPoolOOM {\n\tpublic static void main(String[] args) {\n\t\t// 使用 List 保持 着 常量 池 引用， 避免 Full GC 回收 常量 池 行为\n\t\tList<String> list =new ArrayList<String>();\n\t\t// 10MB 的 PermSize 在 integer 范围内 足够 产生 OOM 了\n\t\tint i = 0;\n\t\twhile(true) {\n\t\t\tlist.add(String.valueOf(i++ +\"xxxxxxxxxxxxxxxxxxxxx\").intern());\n\t\t}\n\t}\n}\n运行异常：\nException in thread \"main\" java. lang. OutOfMemoryError: \nPermGen space at java. lang. String. intern( Native Method) \nat org. fenixsoft. oom. RuntimeConstantPoolOOM. main( RuntimeConstantPoolOOM. java:...\n```\n\n<h4>1.7 直接 内存</h4>\n 直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。越过了DirectByteBuffer类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。如下实例为直接内存溢出。    \n```java\npackage com.sf.jvm;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Field;\nimport staticcom.sun.deploy.util.BufferUtil.MB;\n/**\n* VM Args：- Xmx20M -XX: MaxDirectMemorySize= 10M\n*/\npublic classDirectMemoryOOM {\n\tprivate static final int_1MB=1024*1024;\n\tpublic static void main(String[] args)throwsException {\n\t\tField unsafeField = Unsafe.class.getDeclaredFields()[0];\n\t\tunsafeField.setAccessible(true);\n\t\tUnsafe unsafe = (Unsafe) unsafeField.get(null);\n\t\twhile(true) {\n\t\t\tunsafe.allocateMemory(_1MB);\n\t\t}\n\t}\n}\n运行异常：\nException in thread \"main\" java.lang.OutOfMemoryError\nat sun.misc.Unsafe.allocateMemory(Native Method)\nat com.sf.jvm.DirectMemoryOOM.main(DirectMemoryOOM.java:20)\n```\n<h4>1.8 对象的访问</h4>\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Objectobj=newObject();假设这句代码出现在方法体中，那“Objectobj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“newObject()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（InstanceData，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（ObjectMemoryLayout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n       如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图:\n![这里写图片描述](http://img.blog.csdn.net/20170728094239784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n        如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图:`<center>`![这里写图片描述](http://img.blog.csdn.net/20170728094300056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n         这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。\n参照：\n深入理解Java虚拟机\nhttp://blog.csdn.net/u012152619/article/details/46968883\nhttp://www.importnew.com/14630.html\n","source":"_posts/language/jvm/JVM内存模型.md","raw":"---\ntitle: JVM内存模型\ncategories:\n- java\n---\n\n\n\n##<center>JVM 内存模型</center> 1.内存模型结构图\n\n![**这里写图片描述**](http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n| 名称         | 特征                                                     | 作用                                                                      | 配置参数                           | 异常                                 |\n| ------------ | -------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------- | ------------------------------------ |\n| 程序计数器   | 占用内存小，线程私有， 生命周期与线程相同                | 大致为字节码行号指示器                                                    | 无                                 | 无                                   |\n| 虚拟机栈     | 线程私有，生命周期与线程相同，使用连续的内存空间         | Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息 | -Xss                               | OutOfMemoryError，StackOverflowError |\n| java 堆      | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 保存对象实例，所有对象实例（包括数组）都要在堆上分配                      | -Xms-Xsx -Xmn                      | OutOfMemoryError                     |\n| 方法区       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据  | -XX:PermSize:16M-XX:MaxPermSize64M | OutOfMemoryError                     |\n| 运行时常量池 | 方法区的一部分，具有动态性                               | 存放字面量及符号引用                                                      | 无                                 | 无                                   |\n\n<h5>1.1 程序计数器</h5>\n程序 计数器（ Program Counter Register） 是一 块 较小 的 内存 空间， 它的 作用 可以 看做 是 当前 线程 所 执行 的 字节 码 的 行号 指示器。 在 虚拟 机 的 概念 模型 里（ 仅是 概念 模型， 各种 虚拟 机 可能 会 通过 一些 更 高效 的 方式 去 实现）， 字节 码 解释器 工作 时 就是 通过 改变 这个 计数器 的 值 来 选取 下一 条 需要 执行 的 字节 码 指令， 分支、 循环、 跳 转、 异常 处理、 线程 恢复 等 基础 功能 都 需要 依赖 这个 计数器 来 完成。\n由于 Java 虚拟 机 的 多 线程 是 通过 线程 轮流 切换 并 分配 处理器 执行 时间 的 方式 来 实现 的， 在任 何 一个 确定 的 时刻， 一个 处理器（ 对于 多 核 处理器 来说 是一 个 内核） 只会 执行 一条 线程 中的 指令。 因此， 为了 线程 切换 后能 恢复 到 正确 的 执行 位置， 每条 线程 都 需要 有一个 独立 的 程序 计数器， 各条 线程 之间 的 计数器 互不 影响， 独立 存储， 我们 称 这类 内存 区域 为“ 线程 私有” 的 内存。 如果 线程 正在 执行 的 是 一个 Java 方法， 这个 计数器 记录 的 是 正在 执行 的 虚拟 机 字节 码 指令 的 地址； 如果 正在 执 行的 是 Natvie 方法， 这个 计数器 值 则为 空（ Undefined）。 此 内存 区域 是 唯一 一个 在 Java 虚拟 机 规范 中 没有 规定 任何 OutOfMemoryError 情况 的 区域。\n\n<h5>1.2 Java 虚拟 机 栈</h5>\n与 程序 计数器 一样， Java 虚拟 机 栈（ Java Virtual Machine Stacks） 也是 线程 私有 的， 它的 生命 周期 与 线程 相同。 虚拟 机 栈 描述 的 是 Java 方法 执行 的 内存 模型： 每个 方法 被 执行 的 时候 都会 同时 创建 一个 栈 帧（ Stack Frame[ 1]） 用于 存储 局部 变 量表、 操作 栈、 动态 链接、 方法 出口 等 信息。 每一个 方法 被 调用 直至 执行 完成 的 过程， 就 对应 着 一个 栈 帧 在 虚拟 机 栈 中 从 入栈 到 出 栈 的 过程,对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 经常 有人 把 Java 内存 区 分为 堆 内存（ Heap） 和 栈 内存（ Stack）， 这种 分法 比较 粗糙， Java 内存 区域 的 划分 实际上 远比 这 复杂。 这种 划分 方式 的 流行 只能 说明 大多数 程序员 最 关注 的、 与 对象 内存 分配 关系 最 密切 的 内存 区域 是 这 两块。 其中 所指 的“ 堆” 在后面 会 专门 讲述， 而 所指 的“ 栈” 就是 现在 讲的 虚拟 机 栈， 或者 说是 虚拟 机 栈 中的 局部 变量 表 部分。 局部 变量 表 存放 了 编译 期 可知 的 各种 基本 数据 类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象 引用（ reference 类型， 它不 等同 于 对象 本身， 根据 不同 的 虚拟 机 实现， 它可 能 是一 个 指向 对象 起始 地址 的 引用 指针， 也可能 指向 一个 代表 对象 的 句柄 或者 其他 与此 对象 相关 的 位置） 和 returnAddress 类型（ 指向 了 一条 字节 码 指令 的 地址）。 其中 64 位 长度 的 long 和 double 类型 的 数据 会 占用 2 个 局部 变量 空间（Slot）， 其余 的 数据 类型 只占 用 1 个。 局部 变量 表 所需 的 内存 空间 在编 译 期间 完成 分配， 当 进入 一个 方法 时， 这个 方法 需 要在 帧 中 分配 多大 的 局部 变量 空间 是 完全 确定 的， 在 方法 运行 期间 不会 改变 局部 变 量表 的 大小。 在 Java 虚拟 机 规范 中， 对这 个 区域 规定了 两种 异常 状况： 如果 线程 请求 的 栈 深度 大于 虚拟 机 所 允许 的 深度， 将 抛出 StackOverflowError 异常； 如果 虚拟 机 栈 可以 动态 扩展（ 当前 大部分 的 Java 虚拟 机 都可 动态 扩展， 只不过 Java 虚拟 机 规范 中 也 允许 固定 长度 的 虚拟 机 栈）， 当 扩展 时 无法 申请 到 足够 的 内存 时会 抛出 OutOfMemoryError 异常。\n<h6>1.2.1 局部变量表</h6>\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。\n局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。\nreference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\nreturnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。\n虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。\n Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。\n 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n<h6>1.2.2 操作数栈</h6>\n和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。\n虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。\n虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中。如下演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：\n```java\n   begin  \n   iload_0    // push the int in local variable 0 ontothe stack  \n   iload_1    //push the int in local variable 1 onto the stack  \n   iadd       // pop two ints, add them, push result  \n   istore_2   // pop int, store into local variable 2  \n   end\n```\n1. 指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中\n2. iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈\n3. istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。\n4. 局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。\n\n![**这里写图片描述**](http://img.blog.csdn.net/20170727201918687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)<center>\n\n<h6>1.2.3 动态连接<h6>\n虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。\n如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。\n<h6> 1.2.4 返回地址 <h6>\n方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。\n不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。\n方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。\n\n![这里写图片描述](http://img.blog.csdn.net/20170727204302809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n\n<h6> 1.2.5 异常 <h6>\n在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。如下代码为请求大于虚拟机堆栈深度所出现的异常\n\n```\n    java\npackage com.sf.jvm;\n/**\n* VM Args：- Xss128k\n*/\npublic class JavaVMStackSOF {\n  private intstackLength=1;\n  public void stackLeak() {\n    stackLength++;\n    stackLeak();\n  }\n  public static void main(String[] args)throwsThrowable {\n    JavaVMStackSOF oom =newJavaVMStackSOF();\n    try{\n      oom.stackLeak();\n    }catch(Throwable e) {\n      System.out.println(\" stack length:\" + oom.stackLength);\n      throw e;\n    }\n  }\n}\n```\n\n运行出现如下情况：\n\n```\nstack length:22337\nException in thread \"main\" java.lang.StackOverflowError\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\nat com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)\n```\n\n<h4>1.3 本地 方法 栈</h4>\n\n本地 方法 栈（ Native Method Stacks） 与 虚拟 机 栈 所 发挥 的 作用 是非 常 相似 的， 其 区别 不过 是 虚拟 机 栈 为 虚拟 机 执行 Java 方法（ 也就是 字节 码） 服务， 而 本地 方法 栈 则是 为 虚拟 机 使 用到 的 Native 方法 服务。 虚拟 机 规范 中 对本 地 方法 栈 中的 方法 使用 的 语言、 使用 方式 与 数据 结构 并没有 强制 规定， 因此 具体 的 虚拟 机 可以 自由 实现 它。 甚至 有的 虚拟 机（ 譬如 Sun HotSpot 虚拟 机） 直接 就把 本地 方法 栈 和 虚拟 机 栈 合二为一。 与 虚拟 机 栈 一样， 本地 方法 栈 区域 也会 抛出 StackOverflowError 和 OutOfMemoryError 异常。\n\n对于一个运行中的 Java 程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。\n　　本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让 Java 程序调用本地方法。\n　　任何本地方法接口都会使用某种本地方法栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。\n　　如果某个虚拟机实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当 C 程序调用一个 C 函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。\n　　很可能本地方法接口需要回调 Java 虚拟机中的 Java 方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个 Java 栈。\n　　![这里写图片描述](http://img.blog.csdn.net/20170727205440144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n　　这幅图展示了 JAVA 虚拟机内部线程运行的全景图。当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个 Java 方法，一个线程可能在整个生命周期中都执行 Java 方法，操作它的 Java 栈；或者它可能毫无障碍地在 Java 栈和本地方法栈之间跳转。\n\n该线程首先调用了两个 Java 方法，而第二个 Java 方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个 C 语言栈，其间有两个 C 函数，第一个 C 函数被第二个 Java 方法当做本地方法调用，而这个 C 函数又调用了第二个 C 函数。之后第二个 C 函数又通过本地方法接口回调了一个 Java 方法（第三个 Java 方法），最终这个 Java 方法又调用了一个 Java 方法（它成为图中的当前方法）。\n内存溢出实例：\n\n```java\npackagecom.sf.jvm;\n/**\n* VM Args：\n* -Xss2M\n*/\npublic classJavaVMStackOOM {\n   private void dontStop() {\n      while(true) {\n         try{\n           Thread.sleep(100000);\n        }catch(InterruptedException e) {\n\t\t   e.printStackTrace();\n\t    }\n\t  }\n  }\n\t  public void stackLeakByThread() {\n\t\tint threadNum =0;\n\t    while(true) {\n\t\t    Thread thread =newThread(newRunnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\tdontStop();\n\t\t\t\t}\n\t\t});\n\t\tthread.start();\n\t\tthreadNum++;\n\t\t}\n\t}\n\tpublic static void main(String[] args)throwsThrowable {\n\t\tJavaVMStackOOM oom =newJavaVMStackOOM();\n\t\toom.stackLeakByThread();\n\t}\n}\n\n运行程序抛出如下异常：\nException in thread \"main\" java. lang. OutOfMemoryError: unable to create new native thread\n```\n\n<h4>1.4 Java 堆<h4>\n\nJava 堆（ Java Heap） 是 Java 虚拟 机 所 管理 的 内存 中最 大的 一块。 Java 堆 是 被 所有 线程 共享 的 一块 内存 区域， 在 虚拟 机 启动 时 创建。 此 内存 区域 的 唯一 目的 就是 存放 对象 实例， 几乎 所有 的 对象 实例 都在 这里 分配 内存。 这一 点在 Java 虚拟 机 规范 中的 描述 是： 所有 的 对象 实例 以及 数组 都 要在 堆 上 分配[ 2]， 但是 随着 JIT 编译器 的 发展 与 逃逸 分析 技术 的 逐渐 成熟， 栈 上 分配、 标量 替换[ 3] 优化 技术 将会 导致 一些 微妙 的 变化 发生， 所有 的 对象 都 分配 在 堆 上 也 渐渐 变得 不是 那么“ 绝对” 了。 Java 堆 是 垃圾 收集 器 管理 的 主要 区域， 因此 很多 时候 也 被 称做“ GC 堆”（ Garbage Collected Heap）。 如果 从内 存 回收 的 角度 看， 由于 现在 收集 器 基本 都是 采 用的 分 代收 集 算法， 所以 Java 堆 中 还可以 细分 为： 新生代 和 老 年代； 再 细致 一点 的 有 Eden 空间、 From Survivor 空间、 To Survivor 空间 等。 如果 从内 存 分配 的 角度 看， 线程 共享 的 Java 堆 中 可能 划分 出 多个 线程 私有 的 分配 缓冲区（ Thread Local Allocation Buffer， TLAB）。 不过， 无论如何 划分， 都与 存放 内容 无关， 无论 哪个 区域， 存储 的 都 仍然是 对象 实例， 进一步 划分 的 目的 是 为了 更好 地 回收 内存， 或者 更快 地 分配 内存。 在 本章 中， 我们 仅仅 针对 内存 区域 的 作用 进行 讨论， Java 堆 中的 上述 各个 区域 的 分配 和 回收 等 细节 将会 是 下 一章 的 主题。 根据 Java 虚拟 机 规范 的 规定， Java 堆 可以 处于 物理上 不连续 的 内存 空间 中， 只要 逻辑上 是 连续 的 即可， 就 像 我们 的 磁盘 空间 一样。 在 实现 时， 既可以 实现 成 固定 大小 的， 也可以 是 可扩展 的， 不过 当前 主流 的 虚拟 机 都是 按照 可扩展 来 实现 的（ 通过- Xmx 和- Xms 控制）。\nJava 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。\n在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。如下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170727210308831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n\n从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。\n默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。\n老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。\n默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。\nJVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。\n因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间。\n\nGC 堆\nJava 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。\nMinor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。\n新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。\n当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。\n当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳\n( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。\n但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。\nFull GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。\n现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。\n另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。\n\n设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。\n\n| jvm 参数                        | 解释                                                                                                                    |\n| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| -Xms                            | 初始堆大小。如：-Xms256m                                                                                                |\n| -Xmx                            | 最大堆大小。如：-Xmx512m                                                                                                |\n| -Xmn                            | 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% |\n| -Xss                            | JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。                                         |\n| -XX:NewRatio                    | 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3                                       |\n| -XX:SurvivorRatio               | 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10                  |\n| -XX:PermSize                    | 永久代(方法区)的初始大小                                                                                                |\n| -XX:MaxPermSize                 | 永久代(方法区)的最大值                                                                                                  |\n| -XX:+PrintGCDetails             | 打印 GC 信息                                                                                                            |\n| -XX:+HeapDumpOnOutOfMemoryError | 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用                                                        |\n\nJava 堆 用于 储存 对象 实例， 我们 只要 不断 地 创建 对象， 并且 保证 GC Roots 到 对象 之间 有可 达 路径 来 避免 垃圾 回收 机制 清除 这些 对象， 就会 在 对象 数量 到达 最 大堆 的 容量 限制 后 产生 内存 溢出 异常。实例如下：\n\n```java\npackagecom.sf.jvm;\nimportjava.util.ArrayList;\nimportjava.util.List;\n/**\n* VM Args：\n* -Xms20m -Xmx20m\n* -XX:+HeapDumpOnOutOfMemoryError\n* -XX:+PrintGCDetails\n*/\npublic classHeapOutOfMemory {\n\n\tpublic static void main(String[] args) {\n\t\toutOfMemory();\n\t}\n\tstatic void noOutOfMemory(){\n\t\twhile(true) {\n\t\t\tnewOOMObject();\n\t\t}\n\t}\n\tstatic void outOfMemory(){\n\t\tList<OOMObject> list =newArrayList<OOMObject>();\n\t\twhile(true) {\n\t\t\tlist.add(newOOMObject());\n\t\t}\n\t}\n}\nclassOOMObject {\n\tbytemem[] =new byte[2014];\n}\n异常信息如下：\n[GC (Allocation Failure) [PSYoungGen: 5632K->512K(6144K)] 5632K->5024K(19968K), 0.0027725 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n[GC (Allocation Failure) [PSYoungGen: 6144K->504K(6144K)] 10656K->11432K(19968K), 0.0022202 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n[Full GC (Ergonomics) [PSYoungGen: 504K->0K(6144K)] [ParOldGen: 10928K->10092K(13824K)] 11432K->10092K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0149535 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]\n........\n[Full GC (Allocation Failure) [PSYoungGen: 5632K->5632K(6144K)] [ParOldGen: 13823K->13823K(13824K)] 19455K->19455K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0086009 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid2780.hprof ...\nHeap dump file created [20898436 bytes in 0.027 secs]\n[Full GC (Ergonomics) Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\nat com.sf.jvm.OOMObject.<init>(HeapOutOfMemory.java:29)\nat com.sf.jvm.HeapOutOfMemory.outOfMemory(HeapOutOfMemory.java:23)\nat com.sf.jvm.HeapOutOfMemory.main(HeapOutOfMemory.java:12)\n[PSYoungGen: 5632K->0K(6144K)] [ParOldGen: 13823K->579K(13824K)] 19455K->579K(19968K), [Metaspace: 2973K->2973K(1056768K)], 0.0096016 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\nHeap\nPSYoungGen total 6144K, used 177K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)\neden space 5632K, 3% used [0x00000000ff980000,0x00000000ff9ac4a0,0x00000000fff00000)\nfrom space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\nto space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\nParOldGen total 13824K, used 579K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)\nobject space 13824K, 4% used [0x00000000fec00000,0x00000000fec90c20,0x00000000ff980000)\nMetaspace used 3005K, capacity 4496K, committed 4864K, reserved 1056768K\nclass space used 326K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n用 jvisualvm.exe 打开查看 dump，发现主要是 OOMobject 不被释放。\n\n<h4>1.5 方法 区<h4>\n      <h5>1.5.1 方法区</h5> \n方法 区（ Method Area） 与 Java 堆 一样， 是 各个 线程 共享 的 内存 区域， 它 用于 存储 已被 虚拟 机 加载 的 类 信息、 常量、 静态 变量、 即时 编译器 编译 后的 代码 等 数据。 虽然 Java 虚拟 机 规范 把 方法 区 描述为 堆 的 一个 逻辑 部分， 但是 它 却有 一个 别名 叫做 Non- Heap（ 非 堆）， 目的 应该 是与 Java 堆 区分 开来。 对于 习惯 在 HotSpot 虚拟 机上 开发 和 部署 程序 的 开发者 来说， 很多人 愿意 把 方法 区 称为“ 永久 代”（ Permanent Generation）， 本质上 两者 并不 等价， 仅仅 是因为 HotSpot 虚拟 机 的 设计 团队 选择 把 GC 分 代收 集 扩展 至 方法 区， 或者说 使用 永久 代 来 实现 方法 区 而已。 对于 其他 虚拟 机（ 如 BEA JRockit、 IBM J9 等） 来说 是 不存在 永久 代 的 概念 的。 即使是 HotSpot 虚拟 机 本身， 根据 官方 发布 的 路线 图 信息， 现在 也有 放弃 永久 代 并“ 搬家” 至 Native Memory 来 实现 方法 区 的 规划 了。 Java 虚拟 机 规范 对这 个 区域 的 限制 非常 宽松， 除了 和 Java 堆 一样 不需要 连续 的 内存 和 可以 选择 固定 大小 或者 可扩展 外， 还可以 选择 不实 现 垃圾 收集。 相对而言， 垃圾 收集 行为 在这 个 区域 是 比较 少 出现 的， 但 并非 数据 进入 了 方法 区 就 如 永久 代 的 名字 一样“ 永久” 存在 了。 这个 区域 的 内存 回收 目标 主要 是 针对 常量 池 的 回收 和 对 类型 的 卸载， 一般来说 这个 区域 的 回收“ 成绩” 比较 难以 令人满意， 尤其是 类型 的 卸载， 条件 相当 苛刻， 但是 这部 分 区域 的 回收 确实 是有 必要 的。 在 Sun 公司 的 BUG 列表 中， 曾 出现 过 的 若干个 严重 的 BUG 就是 由于 低 版本 的 HotSpot 虚拟 机 对此 区域 未完 全 回收 而 导致 内存 泄漏。 根据 Java 虚拟 机 规范 的 规定， 当 方法 区 无法 满足 内存 分配 需求 时， 将 抛出 OutOfMemoryError 异常。方法 区 用于 存放 Class 的 相关 信息， 如 类 名、 访问 修饰 符、 常量 池、 字段 描述、 方法 描述 等。 对于 这个 区域 的 测试， 基本 的 思路 是 运行时 产生 大量 的 类 去 填满 方法 区， 直到 溢出。 虽然 直接 使用 Java SE API 也可以 动态 产生 类（ 如 反射 时 的 GeneratedConstructorAccessor 和 动态 代理 等）， 但在 本次 实验 中 操作 起来 比较 麻烦。 在 代码 清单 2- 5 中， 笔者 借助 CGLib[ 3] 直接 操作 字节 码 运行时， 生成 了 大量 的 动态 类。 值得 特别 注意 的 是， 我们 在这 个 例子 中 模拟 的 场景 并非 纯粹 是一 个 实验， 这样 的 应用 经常 会 出现 在 实际 应用 中： 当前 的 很多 主流 框架， 如 Spring 和 Hibernate 对 类 进行 增强 时， 都会 使用 到 CGLib 这类 字节 码 技术， 增 强的 类 越多， 就 需要 越大 的 方法 区 来 保证 动态 生成 的 Class 可以 加载 入 内存。\n方法 区 溢出 也是 一种 常见 的 内存 溢出 异常， 一个 类 如果 要被 垃圾 收集 器 回收 掉， 判定 条件 是非 常 苛刻 的。 在 经常 动态 生成 大量 Class 的 应用 中， 需要 特别 注意 类 的 回收 状况。 这类 场景 除了 上面 提到 的 程序 使用 了 GCLib 字节 码 增强 外， 常见 的 还有： 大量 JSP 或 动态 产生 JSP 文件 的 应用（ JSP 第一次 运行时 需要 编译 为 Java 类）、 基于 OSGi 的 应用（ 即使是 同一个 类 文件， 被 不同 的 加载 器 加载 也会 视为 不同 的 类） 等。\n代码 清单 2- 5 　 借助 CGLib 使得 方法 区 出现 内存 溢出 异常\n```java\npackagecom.sf.jvm;\n/**\n* VM Args： -XX: PermSize= 10M -XX: MaxPermSize= 10M\n*/\npublic class JavaMethodAreaOOM {\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tEnhancer enhancer =newEnhancer();\n\t\t\tenhancer.setSuperclass(OOMObject.class);\n\t\t\tenhancer.setUseCache(false);\n\t\t\tenhancer.setCallback(newMethodInterceptor() {\n\t\t\t\tpublic Object intercept(Object obj, Method method, \n\t\t\t\t\tObject[] args, MethodProxy proxy)throwsThrowable {\n\t\t\t\t\treturnproxy.invokeSuper(obj, args);\n\t\t\t\t}\n\t\t\t});\n\t\t\tenhancer.create();\n\t\t}\n\t}\n\tstatic classOOMObject {\n\t}\n}\n运行 结果：\nCaused by: \njava. lang. OutOfMemoryError: \nPermGen space at java. lang. ClassLoader. defineClass1( Native Method)\nat java. lang. ClassLoader. defineClassCond( ClassLoader. java: 632) \nat java. lang. ClassLoader. defineClass( ClassLoader. java: 616）\n```\n\n<h5>1.5.2 运行时常量池</h5>\n 运行时 常量 池（ Runtime Constant Pool） 是 方法 区 的 一部分。 Class 文件 中 除了 有 类 的 版本、 字段、 方法、接口 等 描述 等 信息 外， 还有 一项 信息 是 常量 池（ Constant Pool Table）， 用于 存放 编译 期 生成 的 各种 字面 量 和 符号 引用， 这部 分 内容 将 在 类 加载 后 存放 到 方法 区 的 运行时 常量 池 中。 Java 虚拟 机 对 Class 文件 的 每一 部分（ 自然 也 包括 常量 池） 的 格式 都有 严格 的 规定， 每一个 字节 用于 存储 哪种 数据 都 必须 符合 规范 上 的 要求， 这样 才会 被 虚拟 机 认可、 装载 和 执行。 但 对于 运行时 常量 池， Java 虚拟 机 规范 没有 做 任何 细节 的 要求， 不同 的 提供 商 实现 的 虚拟 机 可以 按照 自己的 需要 来 实现 这个 内存 区域。 不过， 一般来说， 除了 保存 Class 文件 中 描述 的 符号 引用 外， 还会 把 翻译 出来 的 直接 引用 也 存储 在 运行时 常量 池 中[ 4]。 运行时 常量 池 相对于 Class 文件 常量 池 的 另外 一个 重要 特征 是 具备 动态 性， Java 语言 并不 要求 常量 一定 只能 在 编译 期 产生， 也就是 并非 预置 入 Class 文件 中 常量 池 的 内容 才能 进入 方法 区 运行时 常量 池， 运行 期间 也可 能将 新的 常量 放入 池 中， 这种 特性 被 开发 人员 利用 得比 较多 的 便是 String 类 的 intern() 方法。 既然 运行时 常量 池 是 方法 区 的 一部分， 自然 会受 到 方法 区 内存 的 限制， 当 常量 池 无法 再 申请 到 内存 时会 抛出 OutOfMemoryError 异常。\n \n```java\npackage com.sf.jvm;\nimportjava.util.ArrayList;\nimportjava.util.List;\n/**\n* VM Args：- XX:PermSize=10M -XX:MaxPermSize=10M\n*/\npublic class RuntimeConstantPoolOOM {\n\tpublic static void main(String[] args) {\n\t\t// 使用 List 保持 着 常量 池 引用， 避免 Full GC 回收 常量 池 行为\n\t\tList<String> list =new ArrayList<String>();\n\t\t// 10MB 的 PermSize 在 integer 范围内 足够 产生 OOM 了\n\t\tint i = 0;\n\t\twhile(true) {\n\t\t\tlist.add(String.valueOf(i++ +\"xxxxxxxxxxxxxxxxxxxxx\").intern());\n\t\t}\n\t}\n}\n运行异常：\nException in thread \"main\" java. lang. OutOfMemoryError: \nPermGen space at java. lang. String. intern( Native Method) \nat org. fenixsoft. oom. RuntimeConstantPoolOOM. main( RuntimeConstantPoolOOM. java:...\n```\n\n<h4>1.7 直接 内存</h4>\n 直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。越过了DirectByteBuffer类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。如下实例为直接内存溢出。    \n```java\npackage com.sf.jvm;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Field;\nimport staticcom.sun.deploy.util.BufferUtil.MB;\n/**\n* VM Args：- Xmx20M -XX: MaxDirectMemorySize= 10M\n*/\npublic classDirectMemoryOOM {\n\tprivate static final int_1MB=1024*1024;\n\tpublic static void main(String[] args)throwsException {\n\t\tField unsafeField = Unsafe.class.getDeclaredFields()[0];\n\t\tunsafeField.setAccessible(true);\n\t\tUnsafe unsafe = (Unsafe) unsafeField.get(null);\n\t\twhile(true) {\n\t\t\tunsafe.allocateMemory(_1MB);\n\t\t}\n\t}\n}\n运行异常：\nException in thread \"main\" java.lang.OutOfMemoryError\nat sun.misc.Unsafe.allocateMemory(Native Method)\nat com.sf.jvm.DirectMemoryOOM.main(DirectMemoryOOM.java:20)\n```\n<h4>1.8 对象的访问</h4>\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Objectobj=newObject();假设这句代码出现在方法体中，那“Objectobj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“newObject()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（InstanceData，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（ObjectMemoryLayout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n       如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图:\n![这里写图片描述](http://img.blog.csdn.net/20170728094239784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n        如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图:`<center>`![这里写图片描述](http://img.blog.csdn.net/20170728094300056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n         这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。\n参照：\n深入理解Java虚拟机\nhttp://blog.csdn.net/u012152619/article/details/46968883\nhttp://www.importnew.com/14630.html\n","slug":"language/jvm/JVM内存模型","published":1,"date":"2021-07-31T09:04:32.026Z","updated":"2021-07-31T09:04:32.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bx000dy2ukh5ww9389","content":"<p>##<center>JVM 内存模型</center> 1.内存模型结构图</p>\n<p><img src=\"http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"**这里写图片描述**\"></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特征</th>\n<th>作用</th>\n<th>配置参数</th>\n<th>异常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序计数器</td>\n<td>占用内存小，线程私有， 生命周期与线程相同</td>\n<td>大致为字节码行号指示器</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>虚拟机栈</td>\n<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>\n<td>Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>\n<td>-Xss</td>\n<td>OutOfMemoryError，StackOverflowError</td>\n</tr>\n<tr>\n<td>java 堆</td>\n<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>\n<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>\n<td>-Xms-Xsx -Xmn</td>\n<td>OutOfMemoryError</td>\n</tr>\n<tr>\n<td>方法区</td>\n<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>\n<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>\n<td>-XX:PermSize:16M-XX:MaxPermSize64M</td>\n<td>OutOfMemoryError</td>\n</tr>\n<tr>\n<td>运行时常量池</td>\n<td>方法区的一部分，具有动态性</td>\n<td>存放字面量及符号引用</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<h5>1.1 程序计数器</h5>\n程序 计数器（ Program Counter Register） 是一 块 较小 的 内存 空间， 它的 作用 可以 看做 是 当前 线程 所 执行 的 字节 码 的 行号 指示器。 在 虚拟 机 的 概念 模型 里（ 仅是 概念 模型， 各种 虚拟 机 可能 会 通过 一些 更 高效 的 方式 去 实现）， 字节 码 解释器 工作 时 就是 通过 改变 这个 计数器 的 值 来 选取 下一 条 需要 执行 的 字节 码 指令， 分支、 循环、 跳 转、 异常 处理、 线程 恢复 等 基础 功能 都 需要 依赖 这个 计数器 来 完成。\n由于 Java 虚拟 机 的 多 线程 是 通过 线程 轮流 切换 并 分配 处理器 执行 时间 的 方式 来 实现 的， 在任 何 一个 确定 的 时刻， 一个 处理器（ 对于 多 核 处理器 来说 是一 个 内核） 只会 执行 一条 线程 中的 指令。 因此， 为了 线程 切换 后能 恢复 到 正确 的 执行 位置， 每条 线程 都 需要 有一个 独立 的 程序 计数器， 各条 线程 之间 的 计数器 互不 影响， 独立 存储， 我们 称 这类 内存 区域 为“ 线程 私有” 的 内存。 如果 线程 正在 执行 的 是 一个 Java 方法， 这个 计数器 记录 的 是 正在 执行 的 虚拟 机 字节 码 指令 的 地址； 如果 正在 执 行的 是 Natvie 方法， 这个 计数器 值 则为 空（ Undefined）。 此 内存 区域 是 唯一 一个 在 Java 虚拟 机 规范 中 没有 规定 任何 OutOfMemoryError 情况 的 区域。\n\n<h5>1.2 Java 虚拟 机 栈</h5>\n与 程序 计数器 一样， Java 虚拟 机 栈（ Java Virtual Machine Stacks） 也是 线程 私有 的， 它的 生命 周期 与 线程 相同。 虚拟 机 栈 描述 的 是 Java 方法 执行 的 内存 模型： 每个 方法 被 执行 的 时候 都会 同时 创建 一个 栈 帧（ Stack Frame[ 1]） 用于 存储 局部 变 量表、 操作 栈、 动态 链接、 方法 出口 等 信息。 每一个 方法 被 调用 直至 执行 完成 的 过程， 就 对应 着 一个 栈 帧 在 虚拟 机 栈 中 从 入栈 到 出 栈 的 过程,对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 经常 有人 把 Java 内存 区 分为 堆 内存（ Heap） 和 栈 内存（ Stack）， 这种 分法 比较 粗糙， Java 内存 区域 的 划分 实际上 远比 这 复杂。 这种 划分 方式 的 流行 只能 说明 大多数 程序员 最 关注 的、 与 对象 内存 分配 关系 最 密切 的 内存 区域 是 这 两块。 其中 所指 的“ 堆” 在后面 会 专门 讲述， 而 所指 的“ 栈” 就是 现在 讲的 虚拟 机 栈， 或者 说是 虚拟 机 栈 中的 局部 变量 表 部分。 局部 变量 表 存放 了 编译 期 可知 的 各种 基本 数据 类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象 引用（ reference 类型， 它不 等同 于 对象 本身， 根据 不同 的 虚拟 机 实现， 它可 能 是一 个 指向 对象 起始 地址 的 引用 指针， 也可能 指向 一个 代表 对象 的 句柄 或者 其他 与此 对象 相关 的 位置） 和 returnAddress 类型（ 指向 了 一条 字节 码 指令 的 地址）。 其中 64 位 长度 的 long 和 double 类型 的 数据 会 占用 2 个 局部 变量 空间（Slot）， 其余 的 数据 类型 只占 用 1 个。 局部 变量 表 所需 的 内存 空间 在编 译 期间 完成 分配， 当 进入 一个 方法 时， 这个 方法 需 要在 帧 中 分配 多大 的 局部 变量 空间 是 完全 确定 的， 在 方法 运行 期间 不会 改变 局部 变 量表 的 大小。 在 Java 虚拟 机 规范 中， 对这 个 区域 规定了 两种 异常 状况： 如果 线程 请求 的 栈 深度 大于 虚拟 机 所 允许 的 深度， 将 抛出 StackOverflowError 异常； 如果 虚拟 机 栈 可以 动态 扩展（ 当前 大部分 的 Java 虚拟 机 都可 动态 扩展， 只不过 Java 虚拟 机 规范 中 也 允许 固定 长度 的 虚拟 机 栈）， 当 扩展 时 无法 申请 到 足够 的 内存 时会 抛出 OutOfMemoryError 异常。\n<h6>1.2.1 局部变量表</h6>\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。\n局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。\nreference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\nreturnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。\n虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。\n Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。\n 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n<h6>1.2.2 操作数栈</h6>\n和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。\n虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。\n虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中。如下演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">begin  </span><br><span class=\"line\">iload_0    <span class=\"comment\">// push the int in local variable 0 ontothe stack  </span></span><br><span class=\"line\">iload_1    <span class=\"comment\">//push the int in local variable 1 onto the stack  </span></span><br><span class=\"line\">iadd       <span class=\"comment\">// pop two ints, add them, push result  </span></span><br><span class=\"line\">istore_2   <span class=\"comment\">// pop int, store into local variable 2  </span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n1. 指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中\n2. iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈\n3. istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。\n4. 局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。\n\n<p><img src=\"http://img.blog.csdn.net/20170727201918687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"**这里写图片描述**\"><center></p>\n<h6>1.2.3 动态连接<h6>\n虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。\n如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。\n<h6> 1.2.4 返回地址 <h6>\n方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。\n不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。\n方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。\n\n<p><img src=\"http://img.blog.csdn.net/20170727204302809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></center></p>\n<h6> 1.2.5 异常 <h6>\n在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。如下代码为请求大于虚拟机堆栈深度所出现的异常\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    java</span><br><span class=\"line\">package com.sf.jvm;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* VM Args：- Xss128k</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class JavaVMStackSOF &#123;</span><br><span class=\"line\">  private intstackLength=1;</span><br><span class=\"line\">  public void stackLeak() &#123;</span><br><span class=\"line\">    stackLength++;</span><br><span class=\"line\">    stackLeak();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main(String[] args)throwsThrowable &#123;</span><br><span class=\"line\">    JavaVMStackSOF oom =newJavaVMStackSOF();</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">      oom.stackLeak();</span><br><span class=\"line\">    &#125;catch(Throwable e) &#123;</span><br><span class=\"line\">      System.out.println(&quot; stack length:&quot; + oom.stackLength);</span><br><span class=\"line\">      throw e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行出现如下情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack length:22337</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br></pre></td></tr></table></figure>\n\n<h4>1.3 本地 方法 栈</h4>\n\n<p>本地 方法 栈（ Native Method Stacks） 与 虚拟 机 栈 所 发挥 的 作用 是非 常 相似 的， 其 区别 不过 是 虚拟 机 栈 为 虚拟 机 执行 Java 方法（ 也就是 字节 码） 服务， 而 本地 方法 栈 则是 为 虚拟 机 使 用到 的 Native 方法 服务。 虚拟 机 规范 中 对本 地 方法 栈 中的 方法 使用 的 语言、 使用 方式 与 数据 结构 并没有 强制 规定， 因此 具体 的 虚拟 机 可以 自由 实现 它。 甚至 有的 虚拟 机（ 譬如 Sun HotSpot 虚拟 机） 直接 就把 本地 方法 栈 和 虚拟 机 栈 合二为一。 与 虚拟 机 栈 一样， 本地 方法 栈 区域 也会 抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>\n<p>对于一个运行中的 Java 程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。<br>　　本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让 Java 程序调用本地方法。<br>　　任何本地方法接口都会使用某种本地方法栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br>　　如果某个虚拟机实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当 C 程序调用一个 C 函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。<br>　　很可能本地方法接口需要回调 Java 虚拟机中的 Java 方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个 Java 栈。<br>　　<img src=\"http://img.blog.csdn.net/20170727205440144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>　　这幅图展示了 JAVA 虚拟机内部线程运行的全景图。当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个 Java 方法，一个线程可能在整个生命周期中都执行 Java 方法，操作它的 Java 栈；或者它可能毫无障碍地在 Java 栈和本地方法栈之间跳转。</p>\n<p>该线程首先调用了两个 Java 方法，而第二个 Java 方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个 C 语言栈，其间有两个 C 函数，第一个 C 函数被第二个 Java 方法当做本地方法调用，而这个 C 函数又调用了第二个 C 函数。之后第二个 C 函数又通过本地方法接口回调了一个 Java 方法（第三个 Java 方法），最终这个 Java 方法又调用了一个 Java 方法（它成为图中的当前方法）。<br>内存溢出实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：</span></span><br><span class=\"line\"><span class=\"comment\">* -Xss2M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classJavaVMStackOOM &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dontStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           Thread.sleep(<span class=\"number\">100000</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">\t\t   e.printStackTrace();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stackLeakByThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> threadNum =<span class=\"number\">0</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t    Thread thread =newThread(newRunnable() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\tdontStop();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tthreadNum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>throwsThrowable </span>&#123;</span><br><span class=\"line\">\t\tJavaVMStackOOM oom =newJavaVMStackOOM();</span><br><span class=\"line\">\t\toom.stackLeakByThread();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">运行程序抛出如下异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java. lang. OutOfMemoryError: unable to create <span class=\"keyword\">new</span> <span class=\"keyword\">native</span> thread</span><br></pre></td></tr></table></figure>\n\n<h4>1.4 Java 堆<h4>\n\n<p>Java 堆（ Java Heap） 是 Java 虚拟 机 所 管理 的 内存 中最 大的 一块。 Java 堆 是 被 所有 线程 共享 的 一块 内存 区域， 在 虚拟 机 启动 时 创建。 此 内存 区域 的 唯一 目的 就是 存放 对象 实例， 几乎 所有 的 对象 实例 都在 这里 分配 内存。 这一 点在 Java 虚拟 机 规范 中的 描述 是： 所有 的 对象 实例 以及 数组 都 要在 堆 上 分配[ 2]， 但是 随着 JIT 编译器 的 发展 与 逃逸 分析 技术 的 逐渐 成熟， 栈 上 分配、 标量 替换[ 3] 优化 技术 将会 导致 一些 微妙 的 变化 发生， 所有 的 对象 都 分配 在 堆 上 也 渐渐 变得 不是 那么“ 绝对” 了。 Java 堆 是 垃圾 收集 器 管理 的 主要 区域， 因此 很多 时候 也 被 称做“ GC 堆”（ Garbage Collected Heap）。 如果 从内 存 回收 的 角度 看， 由于 现在 收集 器 基本 都是 采 用的 分 代收 集 算法， 所以 Java 堆 中 还可以 细分 为： 新生代 和 老 年代； 再 细致 一点 的 有 Eden 空间、 From Survivor 空间、 To Survivor 空间 等。 如果 从内 存 分配 的 角度 看， 线程 共享 的 Java 堆 中 可能 划分 出 多个 线程 私有 的 分配 缓冲区（ Thread Local Allocation Buffer， TLAB）。 不过， 无论如何 划分， 都与 存放 内容 无关， 无论 哪个 区域， 存储 的 都 仍然是 对象 实例， 进一步 划分 的 目的 是 为了 更好 地 回收 内存， 或者 更快 地 分配 内存。 在 本章 中， 我们 仅仅 针对 内存 区域 的 作用 进行 讨论， Java 堆 中的 上述 各个 区域 的 分配 和 回收 等 细节 将会 是 下 一章 的 主题。 根据 Java 虚拟 机 规范 的 规定， Java 堆 可以 处于 物理上 不连续 的 内存 空间 中， 只要 逻辑上 是 连续 的 即可， 就 像 我们 的 磁盘 空间 一样。 在 实现 时， 既可以 实现 成 固定 大小 的， 也可以 是 可扩展 的， 不过 当前 主流 的 虚拟 机 都是 按照 可扩展 来 实现 的（ 通过- Xmx 和- Xms 控制）。<br>Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170727210308831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></center></p>\n<p>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。<br>老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。<br>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间。</p>\n<p>GC 堆<br>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。<br>当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。<br>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。<br>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p>\n<p>设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。</p>\n<table>\n<thead>\n<tr>\n<th>jvm 参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小。如：-Xms256m</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小。如：-Xmx512m</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>永久代(方法区)的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>永久代(方法区)的最大值</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCDetails</td>\n<td>打印 GC 信息</td>\n</tr>\n<tr>\n<td>-XX:+HeapDumpOnOutOfMemoryError</td>\n<td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td>\n</tr>\n</tbody></table>\n<p>Java 堆 用于 储存 对象 实例， 我们 只要 不断 地 创建 对象， 并且 保证 GC Roots 到 对象 之间 有可 达 路径 来 避免 垃圾 回收 机制 清除 这些 对象， 就会 在 对象 数量 到达 最 大堆 的 容量 限制 后 产生 内存 溢出 异常。实例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\">importjava.util.ArrayList;</span><br><span class=\"line\">importjava.util.List;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：</span></span><br><span class=\"line\"><span class=\"comment\">* -Xms20m -Xmx20m</span></span><br><span class=\"line\"><span class=\"comment\">* -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class=\"line\"><span class=\"comment\">* -XX:+PrintGCDetails</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classHeapOutOfMemory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\toutOfMemory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">noOutOfMemory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tnewOOMObject();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">outOfMemory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tList&lt;OOMObject&gt; list =newArrayList&lt;OOMObject&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tlist.add(newOOMObject());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">classOOMObject &#123;</span><br><span class=\"line\">\tbytemem[] =<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2014</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">异常信息如下：</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;512K(6144K)] 5632K-&gt;5024K(19968K), <span class=\"number\">0.0027725</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 6144K-&gt;504K(6144K)] 10656K-&gt;11432K(19968K), <span class=\"number\">0.0022202</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span> [PSYoungGen: 504K-&gt;0<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 10928K-&gt;10092<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 11432K-&gt;10092<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0149535 secs] [Times: user</span>=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">........</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 5632K-&gt;5632<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 13823K-&gt;13823<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 19455K-&gt;19455<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0086009 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid2780.hprof ...</span><br><span class=\"line\">Heap dump file created [<span class=\"number\">20898436</span> bytes in <span class=\"number\">0.027</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span> Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.OOMObject.&lt;init&gt;<span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">29</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.HeapOutOfMemory.<span class=\"title\">outOfMemory</span><span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">23</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.HeapOutOfMemory.<span class=\"title\">main</span><span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">12</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">[PSYoungGen: 5632K-&gt;0<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 13823K-&gt;579<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 19455K-&gt;579<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0096016 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">Heap</span><br><span class=\"line\">PSYoungGen total 6144K, used 177K [<span class=\"number\">0x00000000ff980000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">eden space 5632K, <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000ff980000</span>,<span class=\"number\">0x00000000ff9ac4a0</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\">from space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">to space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff80000</span>)</span><br><span class=\"line\">ParOldGen total 13824K, used 579K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff980000</span>, <span class=\"number\">0x00000000ff980000</span>)</span><br><span class=\"line\">object space 13824K, <span class=\"number\">4</span>% used [<span class=\"number\">0x00000000fec00000</span>,<span class=\"number\">0x00000000fec90c20</span>,<span class=\"number\">0x00000000ff980000</span>)</span><br><span class=\"line\">Metaspace used 3005K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span> <span class=\"title\">used</span> 326<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>用 jvisualvm.exe 打开查看 dump，发现主要是 OOMobject 不被释放。</p>\n<h4>1.5 方法 区<h4>\n      <h5>1.5.1 方法区</h5> \n方法 区（ Method Area） 与 Java 堆 一样， 是 各个 线程 共享 的 内存 区域， 它 用于 存储 已被 虚拟 机 加载 的 类 信息、 常量、 静态 变量、 即时 编译器 编译 后的 代码 等 数据。 虽然 Java 虚拟 机 规范 把 方法 区 描述为 堆 的 一个 逻辑 部分， 但是 它 却有 一个 别名 叫做 Non- Heap（ 非 堆）， 目的 应该 是与 Java 堆 区分 开来。 对于 习惯 在 HotSpot 虚拟 机上 开发 和 部署 程序 的 开发者 来说， 很多人 愿意 把 方法 区 称为“ 永久 代”（ Permanent Generation）， 本质上 两者 并不 等价， 仅仅 是因为 HotSpot 虚拟 机 的 设计 团队 选择 把 GC 分 代收 集 扩展 至 方法 区， 或者说 使用 永久 代 来 实现 方法 区 而已。 对于 其他 虚拟 机（ 如 BEA JRockit、 IBM J9 等） 来说 是 不存在 永久 代 的 概念 的。 即使是 HotSpot 虚拟 机 本身， 根据 官方 发布 的 路线 图 信息， 现在 也有 放弃 永久 代 并“ 搬家” 至 Native Memory 来 实现 方法 区 的 规划 了。 Java 虚拟 机 规范 对这 个 区域 的 限制 非常 宽松， 除了 和 Java 堆 一样 不需要 连续 的 内存 和 可以 选择 固定 大小 或者 可扩展 外， 还可以 选择 不实 现 垃圾 收集。 相对而言， 垃圾 收集 行为 在这 个 区域 是 比较 少 出现 的， 但 并非 数据 进入 了 方法 区 就 如 永久 代 的 名字 一样“ 永久” 存在 了。 这个 区域 的 内存 回收 目标 主要 是 针对 常量 池 的 回收 和 对 类型 的 卸载， 一般来说 这个 区域 的 回收“ 成绩” 比较 难以 令人满意， 尤其是 类型 的 卸载， 条件 相当 苛刻， 但是 这部 分 区域 的 回收 确实 是有 必要 的。 在 Sun 公司 的 BUG 列表 中， 曾 出现 过 的 若干个 严重 的 BUG 就是 由于 低 版本 的 HotSpot 虚拟 机 对此 区域 未完 全 回收 而 导致 内存 泄漏。 根据 Java 虚拟 机 规范 的 规定， 当 方法 区 无法 满足 内存 分配 需求 时， 将 抛出 OutOfMemoryError 异常。方法 区 用于 存放 Class 的 相关 信息， 如 类 名、 访问 修饰 符、 常量 池、 字段 描述、 方法 描述 等。 对于 这个 区域 的 测试， 基本 的 思路 是 运行时 产生 大量 的 类 去 填满 方法 区， 直到 溢出。 虽然 直接 使用 Java SE API 也可以 动态 产生 类（ 如 反射 时 的 GeneratedConstructorAccessor 和 动态 代理 等）， 但在 本次 实验 中 操作 起来 比较 麻烦。 在 代码 清单 2- 5 中， 笔者 借助 CGLib[ 3] 直接 操作 字节 码 运行时， 生成 了 大量 的 动态 类。 值得 特别 注意 的 是， 我们 在这 个 例子 中 模拟 的 场景 并非 纯粹 是一 个 实验， 这样 的 应用 经常 会 出现 在 实际 应用 中： 当前 的 很多 主流 框架， 如 Spring 和 Hibernate 对 类 进行 增强 时， 都会 使用 到 CGLib 这类 字节 码 技术， 增 强的 类 越多， 就 需要 越大 的 方法 区 来 保证 动态 生成 的 Class 可以 加载 入 内存。\n方法 区 溢出 也是 一种 常见 的 内存 溢出 异常， 一个 类 如果 要被 垃圾 收集 器 回收 掉， 判定 条件 是非 常 苛刻 的。 在 经常 动态 生成 大量 Class 的 应用 中， 需要 特别 注意 类 的 回收 状况。 这类 场景 除了 上面 提到 的 程序 使用 了 GCLib 字节 码 增强 外， 常见 的 还有： 大量 JSP 或 动态 产生 JSP 文件 的 应用（ JSP 第一次 运行时 需要 编译 为 Java 类）、 基于 OSGi 的 应用（ 即使是 同一个 类 文件， 被 不同 的 加载 器 加载 也会 视为 不同 的 类） 等。\n代码 清单 2- 5 　 借助 CGLib 使得 方法 区 出现 内存 溢出 异常\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args： -XX: PermSize= 10M -XX: MaxPermSize= 10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tEnhancer enhancer =newEnhancer();</span><br><span class=\"line\">\t\t\tenhancer.setSuperclass(OOMObject.class);</span><br><span class=\"line\">\t\t\tenhancer.setUseCache(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\t\tenhancer.setCallback(newMethodInterceptor() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object obj, Method method, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\tObject[] args, MethodProxy proxy)</span>throwsThrowable </span>&#123;</span><br><span class=\"line\">\t\t\t\t\treturnproxy.invokeSuper(obj, args);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tenhancer.create();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> classOOMObject &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行 结果：</span><br><span class=\"line\">Caused by: </span><br><span class=\"line\">java. lang. OutOfMemoryError: </span><br><span class=\"line\">PermGen space at java. lang. ClassLoader. defineClass1( Native Method)</span><br><span class=\"line\">at java. lang. ClassLoader. defineClassCond( ClassLoader. java: <span class=\"number\">632</span>) </span><br><span class=\"line\">at java. lang. ClassLoader. defineClass( ClassLoader. java: <span class=\"number\">616</span>）</span><br></pre></td></tr></table></figure>\n\n<h5>1.5.2 运行时常量池</h5>\n 运行时 常量 池（ Runtime Constant Pool） 是 方法 区 的 一部分。 Class 文件 中 除了 有 类 的 版本、 字段、 方法、接口 等 描述 等 信息 外， 还有 一项 信息 是 常量 池（ Constant Pool Table）， 用于 存放 编译 期 生成 的 各种 字面 量 和 符号 引用， 这部 分 内容 将 在 类 加载 后 存放 到 方法 区 的 运行时 常量 池 中。 Java 虚拟 机 对 Class 文件 的 每一 部分（ 自然 也 包括 常量 池） 的 格式 都有 严格 的 规定， 每一个 字节 用于 存储 哪种 数据 都 必须 符合 规范 上 的 要求， 这样 才会 被 虚拟 机 认可、 装载 和 执行。 但 对于 运行时 常量 池， Java 虚拟 机 规范 没有 做 任何 细节 的 要求， 不同 的 提供 商 实现 的 虚拟 机 可以 按照 自己的 需要 来 实现 这个 内存 区域。 不过， 一般来说， 除了 保存 Class 文件 中 描述 的 符号 引用 外， 还会 把 翻译 出来 的 直接 引用 也 存储 在 运行时 常量 池 中[ 4]。 运行时 常量 池 相对于 Class 文件 常量 池 的 另外 一个 重要 特征 是 具备 动态 性， Java 语言 并不 要求 常量 一定 只能 在 编译 期 产生， 也就是 并非 预置 入 Class 文件 中 常量 池 的 内容 才能 进入 方法 区 运行时 常量 池， 运行 期间 也可 能将 新的 常量 放入 池 中， 这种 特性 被 开发 人员 利用 得比 较多 的 便是 String 类 的 intern() 方法。 既然 运行时 常量 池 是 方法 区 的 一部分， 自然 会受 到 方法 区 内存 的 限制， 当 常量 池 无法 再 申请 到 内存 时会 抛出 OutOfMemoryError 异常。\n \n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sf.jvm;</span><br><span class=\"line\">importjava.util.ArrayList;</span><br><span class=\"line\">importjava.util.List;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：- XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用 List 保持 着 常量 池 引用， 避免 Full GC 回收 常量 池 行为</span></span><br><span class=\"line\">\t\tList&lt;String&gt; list =<span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 10MB 的 PermSize 在 integer 范围内 足够 产生 OOM 了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tlist.add(String.valueOf(i++ +<span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxx&quot;</span>).intern());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java. lang. OutOfMemoryError: </span><br><span class=\"line\">PermGen space at java. lang. String. intern( Native Method) </span><br><span class=\"line\">at org. fenixsoft. oom. RuntimeConstantPoolOOM. main( RuntimeConstantPoolOOM. java:...</span><br></pre></td></tr></table></figure>\n\n<h4>1.7 直接 内存</h4>\n 直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。越过了DirectByteBuffer类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。如下实例为直接内存溢出。    \n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sf.jvm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.Unsafe;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"><span class=\"keyword\">import</span> staticcom.sun.deploy.util.BufferUtil.MB;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：- Xmx20M -XX: MaxDirectMemorySize= 10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classDirectMemoryOOM &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> int_1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>throwsException </span>&#123;</span><br><span class=\"line\">\t\tField unsafeField = Unsafe.class.getDeclaredFields()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tunsafeField.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tUnsafe unsafe = (Unsafe) unsafeField.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tunsafe.allocateMemory(_1MB);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class=\"line\">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class=\"line\">at com.sf.jvm.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n<h4>1.8 对象的访问</h4>\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Objectobj=newObject();假设这句代码出现在方法体中，那“Objectobj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“newObject()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（InstanceData，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（ObjectMemoryLayout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n       如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图:\n![这里写图片描述](http://img.blog.csdn.net/20170728094239784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n        如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图:`<center>`![这里写图片描述](http://img.blog.csdn.net/20170728094300056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n         这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。\n参照：\n深入理解Java虚拟机\nhttp://blog.csdn.net/u012152619/article/details/46968883\nhttp://www.importnew.com/14630.html\n","site":{"data":{}},"excerpt":"","more":"<p>##<center>JVM 内存模型</center> 1.内存模型结构图</p>\n<p><img src=\"http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"**这里写图片描述**\"></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特征</th>\n<th>作用</th>\n<th>配置参数</th>\n<th>异常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序计数器</td>\n<td>占用内存小，线程私有， 生命周期与线程相同</td>\n<td>大致为字节码行号指示器</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>虚拟机栈</td>\n<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>\n<td>Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>\n<td>-Xss</td>\n<td>OutOfMemoryError，StackOverflowError</td>\n</tr>\n<tr>\n<td>java 堆</td>\n<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>\n<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>\n<td>-Xms-Xsx -Xmn</td>\n<td>OutOfMemoryError</td>\n</tr>\n<tr>\n<td>方法区</td>\n<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>\n<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>\n<td>-XX:PermSize:16M-XX:MaxPermSize64M</td>\n<td>OutOfMemoryError</td>\n</tr>\n<tr>\n<td>运行时常量池</td>\n<td>方法区的一部分，具有动态性</td>\n<td>存放字面量及符号引用</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<h5>1.1 程序计数器</h5>\n程序 计数器（ Program Counter Register） 是一 块 较小 的 内存 空间， 它的 作用 可以 看做 是 当前 线程 所 执行 的 字节 码 的 行号 指示器。 在 虚拟 机 的 概念 模型 里（ 仅是 概念 模型， 各种 虚拟 机 可能 会 通过 一些 更 高效 的 方式 去 实现）， 字节 码 解释器 工作 时 就是 通过 改变 这个 计数器 的 值 来 选取 下一 条 需要 执行 的 字节 码 指令， 分支、 循环、 跳 转、 异常 处理、 线程 恢复 等 基础 功能 都 需要 依赖 这个 计数器 来 完成。\n由于 Java 虚拟 机 的 多 线程 是 通过 线程 轮流 切换 并 分配 处理器 执行 时间 的 方式 来 实现 的， 在任 何 一个 确定 的 时刻， 一个 处理器（ 对于 多 核 处理器 来说 是一 个 内核） 只会 执行 一条 线程 中的 指令。 因此， 为了 线程 切换 后能 恢复 到 正确 的 执行 位置， 每条 线程 都 需要 有一个 独立 的 程序 计数器， 各条 线程 之间 的 计数器 互不 影响， 独立 存储， 我们 称 这类 内存 区域 为“ 线程 私有” 的 内存。 如果 线程 正在 执行 的 是 一个 Java 方法， 这个 计数器 记录 的 是 正在 执行 的 虚拟 机 字节 码 指令 的 地址； 如果 正在 执 行的 是 Natvie 方法， 这个 计数器 值 则为 空（ Undefined）。 此 内存 区域 是 唯一 一个 在 Java 虚拟 机 规范 中 没有 规定 任何 OutOfMemoryError 情况 的 区域。\n\n<h5>1.2 Java 虚拟 机 栈</h5>\n与 程序 计数器 一样， Java 虚拟 机 栈（ Java Virtual Machine Stacks） 也是 线程 私有 的， 它的 生命 周期 与 线程 相同。 虚拟 机 栈 描述 的 是 Java 方法 执行 的 内存 模型： 每个 方法 被 执行 的 时候 都会 同时 创建 一个 栈 帧（ Stack Frame[ 1]） 用于 存储 局部 变 量表、 操作 栈、 动态 链接、 方法 出口 等 信息。 每一个 方法 被 调用 直至 执行 完成 的 过程， 就 对应 着 一个 栈 帧 在 虚拟 机 栈 中 从 入栈 到 出 栈 的 过程,对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 经常 有人 把 Java 内存 区 分为 堆 内存（ Heap） 和 栈 内存（ Stack）， 这种 分法 比较 粗糙， Java 内存 区域 的 划分 实际上 远比 这 复杂。 这种 划分 方式 的 流行 只能 说明 大多数 程序员 最 关注 的、 与 对象 内存 分配 关系 最 密切 的 内存 区域 是 这 两块。 其中 所指 的“ 堆” 在后面 会 专门 讲述， 而 所指 的“ 栈” 就是 现在 讲的 虚拟 机 栈， 或者 说是 虚拟 机 栈 中的 局部 变量 表 部分。 局部 变量 表 存放 了 编译 期 可知 的 各种 基本 数据 类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象 引用（ reference 类型， 它不 等同 于 对象 本身， 根据 不同 的 虚拟 机 实现， 它可 能 是一 个 指向 对象 起始 地址 的 引用 指针， 也可能 指向 一个 代表 对象 的 句柄 或者 其他 与此 对象 相关 的 位置） 和 returnAddress 类型（ 指向 了 一条 字节 码 指令 的 地址）。 其中 64 位 长度 的 long 和 double 类型 的 数据 会 占用 2 个 局部 变量 空间（Slot）， 其余 的 数据 类型 只占 用 1 个。 局部 变量 表 所需 的 内存 空间 在编 译 期间 完成 分配， 当 进入 一个 方法 时， 这个 方法 需 要在 帧 中 分配 多大 的 局部 变量 空间 是 完全 确定 的， 在 方法 运行 期间 不会 改变 局部 变 量表 的 大小。 在 Java 虚拟 机 规范 中， 对这 个 区域 规定了 两种 异常 状况： 如果 线程 请求 的 栈 深度 大于 虚拟 机 所 允许 的 深度， 将 抛出 StackOverflowError 异常； 如果 虚拟 机 栈 可以 动态 扩展（ 当前 大部分 的 Java 虚拟 机 都可 动态 扩展， 只不过 Java 虚拟 机 规范 中 也 允许 固定 长度 的 虚拟 机 栈）， 当 扩展 时 无法 申请 到 足够 的 内存 时会 抛出 OutOfMemoryError 异常。\n<h6>1.2.1 局部变量表</h6>\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。\n局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。\nreference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\nreturnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。\n虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。\n Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。\n 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n<h6>1.2.2 操作数栈</h6>\n和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。\n虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。\n虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中。如下演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">begin  </span><br><span class=\"line\">iload_0    <span class=\"comment\">// push the int in local variable 0 ontothe stack  </span></span><br><span class=\"line\">iload_1    <span class=\"comment\">//push the int in local variable 1 onto the stack  </span></span><br><span class=\"line\">iadd       <span class=\"comment\">// pop two ints, add them, push result  </span></span><br><span class=\"line\">istore_2   <span class=\"comment\">// pop int, store into local variable 2  </span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n1. 指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中\n2. iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈\n3. istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。\n4. 局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。\n\n<p><img src=\"http://img.blog.csdn.net/20170727201918687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"**这里写图片描述**\"><center></p>\n<h6>1.2.3 动态连接<h6>\n虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。\n如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。\n<h6> 1.2.4 返回地址 <h6>\n方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。\n不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。\n方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。\n\n<p><img src=\"http://img.blog.csdn.net/20170727204302809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></center></p>\n<h6> 1.2.5 异常 <h6>\n在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。如下代码为请求大于虚拟机堆栈深度所出现的异常\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    java</span><br><span class=\"line\">package com.sf.jvm;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* VM Args：- Xss128k</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class JavaVMStackSOF &#123;</span><br><span class=\"line\">  private intstackLength=1;</span><br><span class=\"line\">  public void stackLeak() &#123;</span><br><span class=\"line\">    stackLength++;</span><br><span class=\"line\">    stackLeak();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main(String[] args)throwsThrowable &#123;</span><br><span class=\"line\">    JavaVMStackSOF oom =newJavaVMStackSOF();</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">      oom.stackLeak();</span><br><span class=\"line\">    &#125;catch(Throwable e) &#123;</span><br><span class=\"line\">      System.out.println(&quot; stack length:&quot; + oom.stackLength);</span><br><span class=\"line\">      throw e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行出现如下情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack length:22337</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class=\"line\">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br></pre></td></tr></table></figure>\n\n<h4>1.3 本地 方法 栈</h4>\n\n<p>本地 方法 栈（ Native Method Stacks） 与 虚拟 机 栈 所 发挥 的 作用 是非 常 相似 的， 其 区别 不过 是 虚拟 机 栈 为 虚拟 机 执行 Java 方法（ 也就是 字节 码） 服务， 而 本地 方法 栈 则是 为 虚拟 机 使 用到 的 Native 方法 服务。 虚拟 机 规范 中 对本 地 方法 栈 中的 方法 使用 的 语言、 使用 方式 与 数据 结构 并没有 强制 规定， 因此 具体 的 虚拟 机 可以 自由 实现 它。 甚至 有的 虚拟 机（ 譬如 Sun HotSpot 虚拟 机） 直接 就把 本地 方法 栈 和 虚拟 机 栈 合二为一。 与 虚拟 机 栈 一样， 本地 方法 栈 区域 也会 抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>\n<p>对于一个运行中的 Java 程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。<br>　　本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让 Java 程序调用本地方法。<br>　　任何本地方法接口都会使用某种本地方法栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br>　　如果某个虚拟机实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当 C 程序调用一个 C 函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。<br>　　很可能本地方法接口需要回调 Java 虚拟机中的 Java 方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个 Java 栈。<br>　　<img src=\"http://img.blog.csdn.net/20170727205440144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>　　这幅图展示了 JAVA 虚拟机内部线程运行的全景图。当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个 Java 方法，一个线程可能在整个生命周期中都执行 Java 方法，操作它的 Java 栈；或者它可能毫无障碍地在 Java 栈和本地方法栈之间跳转。</p>\n<p>该线程首先调用了两个 Java 方法，而第二个 Java 方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个 C 语言栈，其间有两个 C 函数，第一个 C 函数被第二个 Java 方法当做本地方法调用，而这个 C 函数又调用了第二个 C 函数。之后第二个 C 函数又通过本地方法接口回调了一个 Java 方法（第三个 Java 方法），最终这个 Java 方法又调用了一个 Java 方法（它成为图中的当前方法）。<br>内存溢出实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：</span></span><br><span class=\"line\"><span class=\"comment\">* -Xss2M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classJavaVMStackOOM &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dontStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           Thread.sleep(<span class=\"number\">100000</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">\t\t   e.printStackTrace();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stackLeakByThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> threadNum =<span class=\"number\">0</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t    Thread thread =newThread(newRunnable() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\tdontStop();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tthreadNum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>throwsThrowable </span>&#123;</span><br><span class=\"line\">\t\tJavaVMStackOOM oom =newJavaVMStackOOM();</span><br><span class=\"line\">\t\toom.stackLeakByThread();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">运行程序抛出如下异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java. lang. OutOfMemoryError: unable to create <span class=\"keyword\">new</span> <span class=\"keyword\">native</span> thread</span><br></pre></td></tr></table></figure>\n\n<h4>1.4 Java 堆<h4>\n\n<p>Java 堆（ Java Heap） 是 Java 虚拟 机 所 管理 的 内存 中最 大的 一块。 Java 堆 是 被 所有 线程 共享 的 一块 内存 区域， 在 虚拟 机 启动 时 创建。 此 内存 区域 的 唯一 目的 就是 存放 对象 实例， 几乎 所有 的 对象 实例 都在 这里 分配 内存。 这一 点在 Java 虚拟 机 规范 中的 描述 是： 所有 的 对象 实例 以及 数组 都 要在 堆 上 分配[ 2]， 但是 随着 JIT 编译器 的 发展 与 逃逸 分析 技术 的 逐渐 成熟， 栈 上 分配、 标量 替换[ 3] 优化 技术 将会 导致 一些 微妙 的 变化 发生， 所有 的 对象 都 分配 在 堆 上 也 渐渐 变得 不是 那么“ 绝对” 了。 Java 堆 是 垃圾 收集 器 管理 的 主要 区域， 因此 很多 时候 也 被 称做“ GC 堆”（ Garbage Collected Heap）。 如果 从内 存 回收 的 角度 看， 由于 现在 收集 器 基本 都是 采 用的 分 代收 集 算法， 所以 Java 堆 中 还可以 细分 为： 新生代 和 老 年代； 再 细致 一点 的 有 Eden 空间、 From Survivor 空间、 To Survivor 空间 等。 如果 从内 存 分配 的 角度 看， 线程 共享 的 Java 堆 中 可能 划分 出 多个 线程 私有 的 分配 缓冲区（ Thread Local Allocation Buffer， TLAB）。 不过， 无论如何 划分， 都与 存放 内容 无关， 无论 哪个 区域， 存储 的 都 仍然是 对象 实例， 进一步 划分 的 目的 是 为了 更好 地 回收 内存， 或者 更快 地 分配 内存。 在 本章 中， 我们 仅仅 针对 内存 区域 的 作用 进行 讨论， Java 堆 中的 上述 各个 区域 的 分配 和 回收 等 细节 将会 是 下 一章 的 主题。 根据 Java 虚拟 机 规范 的 规定， Java 堆 可以 处于 物理上 不连续 的 内存 空间 中， 只要 逻辑上 是 连续 的 即可， 就 像 我们 的 磁盘 空间 一样。 在 实现 时， 既可以 实现 成 固定 大小 的， 也可以 是 可扩展 的， 不过 当前 主流 的 虚拟 机 都是 按照 可扩展 来 实现 的（ 通过- Xmx 和- Xms 控制）。<br>Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170727210308831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></center></p>\n<p>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。<br>老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。<br>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间。</p>\n<p>GC 堆<br>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。<br>当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。<br>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。<br>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p>\n<p>设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。</p>\n<table>\n<thead>\n<tr>\n<th>jvm 参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小。如：-Xms256m</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小。如：-Xmx512m</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>永久代(方法区)的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>永久代(方法区)的最大值</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCDetails</td>\n<td>打印 GC 信息</td>\n</tr>\n<tr>\n<td>-XX:+HeapDumpOnOutOfMemoryError</td>\n<td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td>\n</tr>\n</tbody></table>\n<p>Java 堆 用于 储存 对象 实例， 我们 只要 不断 地 创建 对象， 并且 保证 GC Roots 到 对象 之间 有可 达 路径 来 避免 垃圾 回收 机制 清除 这些 对象， 就会 在 对象 数量 到达 最 大堆 的 容量 限制 后 产生 内存 溢出 异常。实例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\">importjava.util.ArrayList;</span><br><span class=\"line\">importjava.util.List;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：</span></span><br><span class=\"line\"><span class=\"comment\">* -Xms20m -Xmx20m</span></span><br><span class=\"line\"><span class=\"comment\">* -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class=\"line\"><span class=\"comment\">* -XX:+PrintGCDetails</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classHeapOutOfMemory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\toutOfMemory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">noOutOfMemory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tnewOOMObject();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">outOfMemory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tList&lt;OOMObject&gt; list =newArrayList&lt;OOMObject&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tlist.add(newOOMObject());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">classOOMObject &#123;</span><br><span class=\"line\">\tbytemem[] =<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2014</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">异常信息如下：</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;512K(6144K)] 5632K-&gt;5024K(19968K), <span class=\"number\">0.0027725</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 6144K-&gt;504K(6144K)] 10656K-&gt;11432K(19968K), <span class=\"number\">0.0022202</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span> [PSYoungGen: 504K-&gt;0<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 10928K-&gt;10092<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 11432K-&gt;10092<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0149535 secs] [Times: user</span>=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">........</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 5632K-&gt;5632<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 13823K-&gt;13823<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 19455K-&gt;19455<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0086009 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid2780.hprof ...</span><br><span class=\"line\">Heap dump file created [<span class=\"number\">20898436</span> bytes in <span class=\"number\">0.027</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span> Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.OOMObject.&lt;init&gt;<span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">29</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.HeapOutOfMemory.<span class=\"title\">outOfMemory</span><span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">23</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">at com.sf.jvm.HeapOutOfMemory.<span class=\"title\">main</span><span class=\"params\">(HeapOutOfMemory.java:<span class=\"number\">12</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">[PSYoungGen: 5632K-&gt;0<span class=\"title\">K</span><span class=\"params\">(6144K)</span>] [ParOldGen: 13823K-&gt;579<span class=\"title\">K</span><span class=\"params\">(13824K)</span>] 19455K-&gt;579<span class=\"title\">K</span><span class=\"params\">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0096016 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs]</span><br><span class=\"line\">Heap</span><br><span class=\"line\">PSYoungGen total 6144K, used 177K [<span class=\"number\">0x00000000ff980000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">eden space 5632K, <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000ff980000</span>,<span class=\"number\">0x00000000ff9ac4a0</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\">from space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">to space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff80000</span>)</span><br><span class=\"line\">ParOldGen total 13824K, used 579K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff980000</span>, <span class=\"number\">0x00000000ff980000</span>)</span><br><span class=\"line\">object space 13824K, <span class=\"number\">4</span>% used [<span class=\"number\">0x00000000fec00000</span>,<span class=\"number\">0x00000000fec90c20</span>,<span class=\"number\">0x00000000ff980000</span>)</span><br><span class=\"line\">Metaspace used 3005K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span> <span class=\"title\">used</span> 326<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>用 jvisualvm.exe 打开查看 dump，发现主要是 OOMobject 不被释放。</p>\n<h4>1.5 方法 区<h4>\n      <h5>1.5.1 方法区</h5> \n方法 区（ Method Area） 与 Java 堆 一样， 是 各个 线程 共享 的 内存 区域， 它 用于 存储 已被 虚拟 机 加载 的 类 信息、 常量、 静态 变量、 即时 编译器 编译 后的 代码 等 数据。 虽然 Java 虚拟 机 规范 把 方法 区 描述为 堆 的 一个 逻辑 部分， 但是 它 却有 一个 别名 叫做 Non- Heap（ 非 堆）， 目的 应该 是与 Java 堆 区分 开来。 对于 习惯 在 HotSpot 虚拟 机上 开发 和 部署 程序 的 开发者 来说， 很多人 愿意 把 方法 区 称为“ 永久 代”（ Permanent Generation）， 本质上 两者 并不 等价， 仅仅 是因为 HotSpot 虚拟 机 的 设计 团队 选择 把 GC 分 代收 集 扩展 至 方法 区， 或者说 使用 永久 代 来 实现 方法 区 而已。 对于 其他 虚拟 机（ 如 BEA JRockit、 IBM J9 等） 来说 是 不存在 永久 代 的 概念 的。 即使是 HotSpot 虚拟 机 本身， 根据 官方 发布 的 路线 图 信息， 现在 也有 放弃 永久 代 并“ 搬家” 至 Native Memory 来 实现 方法 区 的 规划 了。 Java 虚拟 机 规范 对这 个 区域 的 限制 非常 宽松， 除了 和 Java 堆 一样 不需要 连续 的 内存 和 可以 选择 固定 大小 或者 可扩展 外， 还可以 选择 不实 现 垃圾 收集。 相对而言， 垃圾 收集 行为 在这 个 区域 是 比较 少 出现 的， 但 并非 数据 进入 了 方法 区 就 如 永久 代 的 名字 一样“ 永久” 存在 了。 这个 区域 的 内存 回收 目标 主要 是 针对 常量 池 的 回收 和 对 类型 的 卸载， 一般来说 这个 区域 的 回收“ 成绩” 比较 难以 令人满意， 尤其是 类型 的 卸载， 条件 相当 苛刻， 但是 这部 分 区域 的 回收 确实 是有 必要 的。 在 Sun 公司 的 BUG 列表 中， 曾 出现 过 的 若干个 严重 的 BUG 就是 由于 低 版本 的 HotSpot 虚拟 机 对此 区域 未完 全 回收 而 导致 内存 泄漏。 根据 Java 虚拟 机 规范 的 规定， 当 方法 区 无法 满足 内存 分配 需求 时， 将 抛出 OutOfMemoryError 异常。方法 区 用于 存放 Class 的 相关 信息， 如 类 名、 访问 修饰 符、 常量 池、 字段 描述、 方法 描述 等。 对于 这个 区域 的 测试， 基本 的 思路 是 运行时 产生 大量 的 类 去 填满 方法 区， 直到 溢出。 虽然 直接 使用 Java SE API 也可以 动态 产生 类（ 如 反射 时 的 GeneratedConstructorAccessor 和 动态 代理 等）， 但在 本次 实验 中 操作 起来 比较 麻烦。 在 代码 清单 2- 5 中， 笔者 借助 CGLib[ 3] 直接 操作 字节 码 运行时， 生成 了 大量 的 动态 类。 值得 特别 注意 的 是， 我们 在这 个 例子 中 模拟 的 场景 并非 纯粹 是一 个 实验， 这样 的 应用 经常 会 出现 在 实际 应用 中： 当前 的 很多 主流 框架， 如 Spring 和 Hibernate 对 类 进行 增强 时， 都会 使用 到 CGLib 这类 字节 码 技术， 增 强的 类 越多， 就 需要 越大 的 方法 区 来 保证 动态 生成 的 Class 可以 加载 入 内存。\n方法 区 溢出 也是 一种 常见 的 内存 溢出 异常， 一个 类 如果 要被 垃圾 收集 器 回收 掉， 判定 条件 是非 常 苛刻 的。 在 经常 动态 生成 大量 Class 的 应用 中， 需要 特别 注意 类 的 回收 状况。 这类 场景 除了 上面 提到 的 程序 使用 了 GCLib 字节 码 增强 外， 常见 的 还有： 大量 JSP 或 动态 产生 JSP 文件 的 应用（ JSP 第一次 运行时 需要 编译 为 Java 类）、 基于 OSGi 的 应用（ 即使是 同一个 类 文件， 被 不同 的 加载 器 加载 也会 视为 不同 的 类） 等。\n代码 清单 2- 5 　 借助 CGLib 使得 方法 区 出现 内存 溢出 异常\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packagecom.sf.jvm;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args： -XX: PermSize= 10M -XX: MaxPermSize= 10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tEnhancer enhancer =newEnhancer();</span><br><span class=\"line\">\t\t\tenhancer.setSuperclass(OOMObject.class);</span><br><span class=\"line\">\t\t\tenhancer.setUseCache(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\t\tenhancer.setCallback(newMethodInterceptor() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object obj, Method method, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\tObject[] args, MethodProxy proxy)</span>throwsThrowable </span>&#123;</span><br><span class=\"line\">\t\t\t\t\treturnproxy.invokeSuper(obj, args);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tenhancer.create();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> classOOMObject &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行 结果：</span><br><span class=\"line\">Caused by: </span><br><span class=\"line\">java. lang. OutOfMemoryError: </span><br><span class=\"line\">PermGen space at java. lang. ClassLoader. defineClass1( Native Method)</span><br><span class=\"line\">at java. lang. ClassLoader. defineClassCond( ClassLoader. java: <span class=\"number\">632</span>) </span><br><span class=\"line\">at java. lang. ClassLoader. defineClass( ClassLoader. java: <span class=\"number\">616</span>）</span><br></pre></td></tr></table></figure>\n\n<h5>1.5.2 运行时常量池</h5>\n 运行时 常量 池（ Runtime Constant Pool） 是 方法 区 的 一部分。 Class 文件 中 除了 有 类 的 版本、 字段、 方法、接口 等 描述 等 信息 外， 还有 一项 信息 是 常量 池（ Constant Pool Table）， 用于 存放 编译 期 生成 的 各种 字面 量 和 符号 引用， 这部 分 内容 将 在 类 加载 后 存放 到 方法 区 的 运行时 常量 池 中。 Java 虚拟 机 对 Class 文件 的 每一 部分（ 自然 也 包括 常量 池） 的 格式 都有 严格 的 规定， 每一个 字节 用于 存储 哪种 数据 都 必须 符合 规范 上 的 要求， 这样 才会 被 虚拟 机 认可、 装载 和 执行。 但 对于 运行时 常量 池， Java 虚拟 机 规范 没有 做 任何 细节 的 要求， 不同 的 提供 商 实现 的 虚拟 机 可以 按照 自己的 需要 来 实现 这个 内存 区域。 不过， 一般来说， 除了 保存 Class 文件 中 描述 的 符号 引用 外， 还会 把 翻译 出来 的 直接 引用 也 存储 在 运行时 常量 池 中[ 4]。 运行时 常量 池 相对于 Class 文件 常量 池 的 另外 一个 重要 特征 是 具备 动态 性， Java 语言 并不 要求 常量 一定 只能 在 编译 期 产生， 也就是 并非 预置 入 Class 文件 中 常量 池 的 内容 才能 进入 方法 区 运行时 常量 池， 运行 期间 也可 能将 新的 常量 放入 池 中， 这种 特性 被 开发 人员 利用 得比 较多 的 便是 String 类 的 intern() 方法。 既然 运行时 常量 池 是 方法 区 的 一部分， 自然 会受 到 方法 区 内存 的 限制， 当 常量 池 无法 再 申请 到 内存 时会 抛出 OutOfMemoryError 异常。\n \n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sf.jvm;</span><br><span class=\"line\">importjava.util.ArrayList;</span><br><span class=\"line\">importjava.util.List;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：- XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用 List 保持 着 常量 池 引用， 避免 Full GC 回收 常量 池 行为</span></span><br><span class=\"line\">\t\tList&lt;String&gt; list =<span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 10MB 的 PermSize 在 integer 范围内 足够 产生 OOM 了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tlist.add(String.valueOf(i++ +<span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxx&quot;</span>).intern());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java. lang. OutOfMemoryError: </span><br><span class=\"line\">PermGen space at java. lang. String. intern( Native Method) </span><br><span class=\"line\">at org. fenixsoft. oom. RuntimeConstantPoolOOM. main( RuntimeConstantPoolOOM. java:...</span><br></pre></td></tr></table></figure>\n\n<h4>1.7 直接 内存</h4>\n 直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。越过了DirectByteBuffer类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。如下实例为直接内存溢出。    \n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sf.jvm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.Unsafe;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"><span class=\"keyword\">import</span> staticcom.sun.deploy.util.BufferUtil.MB;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* VM Args：- Xmx20M -XX: MaxDirectMemorySize= 10M</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> classDirectMemoryOOM &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> int_1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>throwsException </span>&#123;</span><br><span class=\"line\">\t\tField unsafeField = Unsafe.class.getDeclaredFields()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tunsafeField.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tUnsafe unsafe = (Unsafe) unsafeField.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tunsafe.allocateMemory(_1MB);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行异常：</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class=\"line\">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class=\"line\">at com.sf.jvm.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n<h4>1.8 对象的访问</h4>\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Objectobj=newObject();假设这句代码出现在方法体中，那“Objectobj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“newObject()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（InstanceData，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（ObjectMemoryLayout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n       如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图:\n![这里写图片描述](http://img.blog.csdn.net/20170728094239784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n        如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图:`<center>`![这里写图片描述](http://img.blog.csdn.net/20170728094300056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>\n         这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。\n参照：\n深入理解Java虚拟机\nhttp://blog.csdn.net/u012152619/article/details/46968883\nhttp://www.importnew.com/14630.html\n"},{"title":"JVM性能调优的6大步骤-关键调优参数详解","_content":"\n\n## 一、JVM 内存调优\n\n对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。\n![](https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg)\n\n### 1.Full GC\n\n会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。\n\n### 2.导致 Full GC 的原因\n\n1)年老代（Tenured）被写满\n\n调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。\n\n2)持久代 Pemanet Generation 空间不足\n\n增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例\n\n3)System.gc()被显示调用\n\n垃圾回收不要手动触发，尽量依靠 JVM 自身的机制\n\n在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。\n\n## 二、JVM 性能调优方法和步骤\n\n![](https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg)\n\n### 1.监控 GC 的状态\n\n使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。\n\n举一个例子： 系统崩溃前的一些现象：\n\n每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC\n年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。\n\n### 2.生成堆的 dump 文件\n\n通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。\n\n### 3.分析 dump 文件\n\n打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：\n\nVisual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。\n\n### 4.分析结果，判断是否需要优化\n\n如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。\n\n注：如果满足下面的指标，则一般不需要进行 GC：\n\nMinor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；\n\n### 5.调整 GC 类型和内存分配\n\n如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。\n\n### 6.不断的分析和调整\n\n通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。\n\ncms 参数优化步流程\n![](https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg)\n下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。\n\n## JVM 调优参数参考\n\n### 1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\n\n### 2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。\n\n比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。\n\n### 3.年轻代和年老代设置多大才算合理\n\n1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC\n2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：\n如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：\n\n- （1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。\n\n- （2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。\n\n### 4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\n\n### 5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。\n\n理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\n\n觉得不错请点赞支持下。\n\n----end----\n\nJVM 相关技术干货推荐：\n\n- 深入详解 JVM 内存模型与 JVM 参数详细配置\n- 7 种 JVM 垃圾收集器特点，优劣势、及使用场景\n- JVM 的 4 种垃圾回收算法、垃圾回收机制与总结\n- 深入剖析 JVM：G1 收集器+回收流程+推荐用例\n\n## 参考：\n\nhttps://zhuanlan.zhihu.com/p/58897189\n","source":"_posts/language/jvm/JVM性能调优的6大步骤-关键调优参数详解.md","raw":"---\ntitle: JVM性能调优的6大步骤-关键调优参数详解\ncategories:\n- java\n---\n\n\n## 一、JVM 内存调优\n\n对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。\n![](https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg)\n\n### 1.Full GC\n\n会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。\n\n### 2.导致 Full GC 的原因\n\n1)年老代（Tenured）被写满\n\n调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。\n\n2)持久代 Pemanet Generation 空间不足\n\n增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例\n\n3)System.gc()被显示调用\n\n垃圾回收不要手动触发，尽量依靠 JVM 自身的机制\n\n在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。\n\n## 二、JVM 性能调优方法和步骤\n\n![](https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg)\n\n### 1.监控 GC 的状态\n\n使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。\n\n举一个例子： 系统崩溃前的一些现象：\n\n每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC\n年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。\n\n### 2.生成堆的 dump 文件\n\n通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。\n\n### 3.分析 dump 文件\n\n打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：\n\nVisual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。\n\n### 4.分析结果，判断是否需要优化\n\n如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。\n\n注：如果满足下面的指标，则一般不需要进行 GC：\n\nMinor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；\n\n### 5.调整 GC 类型和内存分配\n\n如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。\n\n### 6.不断的分析和调整\n\n通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。\n\ncms 参数优化步流程\n![](https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg)\n下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。\n\n## JVM 调优参数参考\n\n### 1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\n\n### 2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。\n\n比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。\n\n### 3.年轻代和年老代设置多大才算合理\n\n1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC\n2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：\n如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：\n\n- （1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。\n\n- （2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。\n\n### 4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\n\n### 5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。\n\n理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\n\n觉得不错请点赞支持下。\n\n----end----\n\nJVM 相关技术干货推荐：\n\n- 深入详解 JVM 内存模型与 JVM 参数详细配置\n- 7 种 JVM 垃圾收集器特点，优劣势、及使用场景\n- JVM 的 4 种垃圾回收算法、垃圾回收机制与总结\n- 深入剖析 JVM：G1 收集器+回收流程+推荐用例\n\n## 参考：\n\nhttps://zhuanlan.zhihu.com/p/58897189\n","slug":"language/jvm/JVM性能调优的6大步骤-关键调优参数详解","published":1,"date":"2021-07-31T09:04:32.004Z","updated":"2021-07-31T09:04:32.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2by000fy2uk284y9jan","content":"<h2 id=\"一、JVM-内存调优\"><a href=\"#一、JVM-内存调优\" class=\"headerlink\" title=\"一、JVM 内存调优\"></a>一、JVM 内存调优</h2><p>对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。<br><img src=\"https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg\"></p>\n<h3 id=\"1-Full-GC\"><a href=\"#1-Full-GC\" class=\"headerlink\" title=\"1.Full GC\"></a>1.Full GC</h3><p>会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。</p>\n<h3 id=\"2-导致-Full-GC-的原因\"><a href=\"#2-导致-Full-GC-的原因\" class=\"headerlink\" title=\"2.导致 Full GC 的原因\"></a>2.导致 Full GC 的原因</h3><p>1)年老代（Tenured）被写满</p>\n<p>调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。</p>\n<p>2)持久代 Pemanet Generation 空间不足</p>\n<p>增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例</p>\n<p>3)System.gc()被显示调用</p>\n<p>垃圾回收不要手动触发，尽量依靠 JVM 自身的机制</p>\n<p>在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。</p>\n<h2 id=\"二、JVM-性能调优方法和步骤\"><a href=\"#二、JVM-性能调优方法和步骤\" class=\"headerlink\" title=\"二、JVM 性能调优方法和步骤\"></a>二、JVM 性能调优方法和步骤</h2><p><img src=\"https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg\"></p>\n<h3 id=\"1-监控-GC-的状态\"><a href=\"#1-监控-GC-的状态\" class=\"headerlink\" title=\"1.监控 GC 的状态\"></a>1.监控 GC 的状态</h3><p>使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。</p>\n<p>举一个例子： 系统崩溃前的一些现象：</p>\n<p>每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC<br>年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。</p>\n<h3 id=\"2-生成堆的-dump-文件\"><a href=\"#2-生成堆的-dump-文件\" class=\"headerlink\" title=\"2.生成堆的 dump 文件\"></a>2.生成堆的 dump 文件</h3><p>通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。</p>\n<h3 id=\"3-分析-dump-文件\"><a href=\"#3-分析-dump-文件\" class=\"headerlink\" title=\"3.分析 dump 文件\"></a>3.分析 dump 文件</h3><p>打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：</p>\n<p>Visual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。</p>\n<h3 id=\"4-分析结果，判断是否需要优化\"><a href=\"#4-分析结果，判断是否需要优化\" class=\"headerlink\" title=\"4.分析结果，判断是否需要优化\"></a>4.分析结果，判断是否需要优化</h3><p>如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。</p>\n<p>注：如果满足下面的指标，则一般不需要进行 GC：</p>\n<p>Minor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；</p>\n<h3 id=\"5-调整-GC-类型和内存分配\"><a href=\"#5-调整-GC-类型和内存分配\" class=\"headerlink\" title=\"5.调整 GC 类型和内存分配\"></a>5.调整 GC 类型和内存分配</h3><p>如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p>\n<h3 id=\"6-不断的分析和调整\"><a href=\"#6-不断的分析和调整\" class=\"headerlink\" title=\"6.不断的分析和调整\"></a>6.不断的分析和调整</h3><p>通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。</p>\n<p>cms 参数优化步流程<br><img src=\"https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg\"><br>下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。</p>\n<h2 id=\"JVM-调优参数参考\"><a href=\"#JVM-调优参数参考\" class=\"headerlink\" title=\"JVM 调优参数参考\"></a>JVM 调优参数参考</h2><h3 id=\"1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值\"><a href=\"#1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值\" class=\"headerlink\" title=\"1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\"></a>1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;</h3><h3 id=\"2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。\"><a href=\"#2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。\" class=\"headerlink\" title=\"2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。\"></a>2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。</h3><p>比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。</p>\n<h3 id=\"3-年轻代和年老代设置多大才算合理\"><a href=\"#3-年轻代和年老代设置多大才算合理\" class=\"headerlink\" title=\"3.年轻代和年老代设置多大才算合理\"></a>3.年轻代和年老代设置多大才算合理</h3><p>1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC<br>2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：<br>如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：</p>\n<ul>\n<li><p>（1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。</p>\n</li>\n<li><p>（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。</p>\n</li>\n</ul>\n<h3 id=\"4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。\"><a href=\"#4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。\" class=\"headerlink\" title=\"4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\"></a>4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。</h3><h3 id=\"5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。\"><a href=\"#5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。\" class=\"headerlink\" title=\"5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。\"></a>5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。</h3><p>理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>\n<p>觉得不错请点赞支持下。</p>\n<p>—-end—-</p>\n<p>JVM 相关技术干货推荐：</p>\n<ul>\n<li>深入详解 JVM 内存模型与 JVM 参数详细配置</li>\n<li>7 种 JVM 垃圾收集器特点，优劣势、及使用场景</li>\n<li>JVM 的 4 种垃圾回收算法、垃圾回收机制与总结</li>\n<li>深入剖析 JVM：G1 收集器+回收流程+推荐用例</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://zhuanlan.zhihu.com/p/58897189\">https://zhuanlan.zhihu.com/p/58897189</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、JVM-内存调优\"><a href=\"#一、JVM-内存调优\" class=\"headerlink\" title=\"一、JVM 内存调优\"></a>一、JVM 内存调优</h2><p>对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。<br><img src=\"https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg\"></p>\n<h3 id=\"1-Full-GC\"><a href=\"#1-Full-GC\" class=\"headerlink\" title=\"1.Full GC\"></a>1.Full GC</h3><p>会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。</p>\n<h3 id=\"2-导致-Full-GC-的原因\"><a href=\"#2-导致-Full-GC-的原因\" class=\"headerlink\" title=\"2.导致 Full GC 的原因\"></a>2.导致 Full GC 的原因</h3><p>1)年老代（Tenured）被写满</p>\n<p>调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。</p>\n<p>2)持久代 Pemanet Generation 空间不足</p>\n<p>增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例</p>\n<p>3)System.gc()被显示调用</p>\n<p>垃圾回收不要手动触发，尽量依靠 JVM 自身的机制</p>\n<p>在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。</p>\n<h2 id=\"二、JVM-性能调优方法和步骤\"><a href=\"#二、JVM-性能调优方法和步骤\" class=\"headerlink\" title=\"二、JVM 性能调优方法和步骤\"></a>二、JVM 性能调优方法和步骤</h2><p><img src=\"https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg\"></p>\n<h3 id=\"1-监控-GC-的状态\"><a href=\"#1-监控-GC-的状态\" class=\"headerlink\" title=\"1.监控 GC 的状态\"></a>1.监控 GC 的状态</h3><p>使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。</p>\n<p>举一个例子： 系统崩溃前的一些现象：</p>\n<p>每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC<br>年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。</p>\n<h3 id=\"2-生成堆的-dump-文件\"><a href=\"#2-生成堆的-dump-文件\" class=\"headerlink\" title=\"2.生成堆的 dump 文件\"></a>2.生成堆的 dump 文件</h3><p>通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。</p>\n<h3 id=\"3-分析-dump-文件\"><a href=\"#3-分析-dump-文件\" class=\"headerlink\" title=\"3.分析 dump 文件\"></a>3.分析 dump 文件</h3><p>打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：</p>\n<p>Visual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。</p>\n<h3 id=\"4-分析结果，判断是否需要优化\"><a href=\"#4-分析结果，判断是否需要优化\" class=\"headerlink\" title=\"4.分析结果，判断是否需要优化\"></a>4.分析结果，判断是否需要优化</h3><p>如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。</p>\n<p>注：如果满足下面的指标，则一般不需要进行 GC：</p>\n<p>Minor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；</p>\n<h3 id=\"5-调整-GC-类型和内存分配\"><a href=\"#5-调整-GC-类型和内存分配\" class=\"headerlink\" title=\"5.调整 GC 类型和内存分配\"></a>5.调整 GC 类型和内存分配</h3><p>如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p>\n<h3 id=\"6-不断的分析和调整\"><a href=\"#6-不断的分析和调整\" class=\"headerlink\" title=\"6.不断的分析和调整\"></a>6.不断的分析和调整</h3><p>通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。</p>\n<p>cms 参数优化步流程<br><img src=\"https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg\"><br>下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。</p>\n<h2 id=\"JVM-调优参数参考\"><a href=\"#JVM-调优参数参考\" class=\"headerlink\" title=\"JVM 调优参数参考\"></a>JVM 调优参数参考</h2><h3 id=\"1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值\"><a href=\"#1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值\" class=\"headerlink\" title=\"1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\"></a>1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;</h3><h3 id=\"2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。\"><a href=\"#2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。\" class=\"headerlink\" title=\"2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。\"></a>2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。</h3><p>比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。</p>\n<h3 id=\"3-年轻代和年老代设置多大才算合理\"><a href=\"#3-年轻代和年老代设置多大才算合理\" class=\"headerlink\" title=\"3.年轻代和年老代设置多大才算合理\"></a>3.年轻代和年老代设置多大才算合理</h3><p>1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC<br>2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：<br>如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：</p>\n<ul>\n<li><p>（1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。</p>\n</li>\n<li><p>（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。</p>\n</li>\n</ul>\n<h3 id=\"4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。\"><a href=\"#4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。\" class=\"headerlink\" title=\"4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\"></a>4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。</h3><h3 id=\"5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。\"><a href=\"#5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。\" class=\"headerlink\" title=\"5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。\"></a>5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。</h3><p>理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>\n<p>觉得不错请点赞支持下。</p>\n<p>—-end—-</p>\n<p>JVM 相关技术干货推荐：</p>\n<ul>\n<li>深入详解 JVM 内存模型与 JVM 参数详细配置</li>\n<li>7 种 JVM 垃圾收集器特点，优劣势、及使用场景</li>\n<li>JVM 的 4 种垃圾回收算法、垃圾回收机制与总结</li>\n<li>深入剖析 JVM：G1 收集器+回收流程+推荐用例</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://zhuanlan.zhihu.com/p/58897189\">https://zhuanlan.zhihu.com/p/58897189</a></p>\n"},{"title":"JVM垃圾回收","_content":"\n# JVM垃圾回收\n\n## 1.简介\n jvm要进行垃圾回收粗略分为两个步骤：找出需要清理的内存(无效的内存区域) ， 清理无效的内存区域\n 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收所关注的是这部分内存。\n\n## 2. 无效内存区域的查找\n\n### 2.1 概要　\n\nJava堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”。判断方法有引用计数器法和根搜索算法等。\n\n#### 2.1.1 引用计数算法\n\n简单解释为给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当该引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。客观地说，引用计数算法（ReferenceCounting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：\n```java\n/**\n *testGC()方法执行后，objA和objB会不会被GC呢？\n *@authorzzm\n */\npublic class ReferenceCountingGC{　　\n\tpublic Object instance=null;　　 \n\tprivate static final int _1MB=1024*1024;　　\n\t/**　　\n\t*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过　　\n\t*/　　\n\tprivate byte[] bigSize=new byte[2*_1MB];　　\n\tpublic static void testGC(){\n\tReferenceCountingGC objA = new ReferenceCountingGC();\n\tReferenceCountingGC objB = newReferenceCountingGC();\n\tobjA.instance = objB;\n\tobjB.instance = objA;\n\tobjA = null; \n\tobjB = null;\n\t//假设在这行发生GC，那么objA和objB是否能被回收？\n\tSystem.gc();　　\n\t}\n}\n运行结果：\n```\n```\n[FullGC(System)\n[Tenured:0K->210K(10240K),0.0149142secs]\n4603K->210K(19456K),\n[Perm:2999K->2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]\nHeapdefnewgenerationtotal9216K,used82K\n[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Edenspace8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)\nfromspace1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)\ntospace1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)\ntenuredgenerationtotal10240K,used210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)\nthespace10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)\ncompactingpermgentotal21248K,\nused3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)\nthespace21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)\nNosharedspacesconfigured.\n```\n\n代码中testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们，为引用计数器的缺陷。但从运行结果中可以清楚地看到GC日志中包含“4603K->210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。\n\n#### 2.1.2 根搜索算法\n\n在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GCRootsTracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728135643324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。\n在Java语言里，可作为GCRoots的对象包括下面几种：\n* 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n* 方法区中的类静态属性引用的对象。\n* 方法区中的常量引用的对象。\n* 本地方法栈中JNI（即一般说的Native方法）的引用的对象。\n\n### 2.2 java的引用类型\n\n无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。\nJDK1.2之后，Java对引用的概念进行了扩充，并且引用强度不同。如下\n\n引用类型 | 概述\n------|--------\n强引用（StrongReference）|强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象\n软引用（SoftReference）|软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用\n弱引用（WeakReference）|弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用\n虚引用（PhantomReference）|虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用\n\n### 2.3 对象自救\n在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经经历两次标记过程：如果对象在进行根搜索后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。\n```java\n/***此代码演示了两点：\n *1.对象可以在被GC时自我拯救。\n *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次\n *@authorzzm\n * */\npublic class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n    public static void main(String[] args) throws Throwable {\n        SAVE_HOOK = new FinalizeEscapeGC(); //对象 第一次 成功 拯救 自己\n        SAVE_HOOK = null;\n        System.gc(); // 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它\n        Thread.sleep(500);\n        if (SAVE_HOOK != null) {\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\" no, i am dead :(\");\n        } // 下面 这段 代码 与 上面 的 完全 相同， 但是 这次 自救 却 失败 了\n        SAVE_HOOK = null;\n        System.gc(); // 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它\n        Thread.sleep(500);\n        if (SAVE_HOOK != null) {\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\" no, i am dead :(\");\n        }\n    }\n    public void isAlive() {\n        System.out.println(\" yes, i am still alive :)\");\n    }\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\" finalize mehtod executed!\");\n        FinalizeEscapeGC.SAVE_HOOK = this;\n    }\n}\n```\n```\n运行结果：\nfinalize mehtod executed! \nyes, i am still alive :) \nno, i am dead :(\n```\n\n从代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。代码中一次对象自我拯救的演示，在运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。\n### 2.4 回收方法区\n\n很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。\njava中同时满足下面3个条件才能算是“无用的类”：\n\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。\n* 加载该类的ClassLoader已经被回收。\n* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。\n是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类的加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，但-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n## 3. 清理无效内存\n### 3.1 垃圾收集算法\n\n由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。\n#### 3.1.1 标记-清除算法\n\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。\n它的主要缺点有两个：\n* 一个是效率问题，标记和清除过程的效率都不高；\n* 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n如下图为执行标记清除算法后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729100915368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n#### 3.1.2 标记-整理算法\n\n标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。\n主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。\n如下图为执行标记清除算法后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729100943066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n####3.1.3 复制算法\n\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。\n复制算法执行后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729101006020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 3.1.4 分代收集算法 \n分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。\n\n### 3.2 垃圾收集器\n垃圾收集器对比\n\n垃圾收集器 | 解释 | 对比\n-----|-----|-----\nSerial收集器| 新生代复制算法，老年代采用标记整理算法，Serial收集器到JDK1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。| 它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率\nParNew收集器 | 新生代复制算法，老年代采用标记整理算法，ParNew收集器其实就是Serial收集器的多线程版本 | ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。\nParallelScavenge收集器 | 新生代收集器采用复制算法 | Parallel Scavenge 收集 器 的 特点 是它 的 关注 点 与其 他 收集 器 不同， CMS 等 收集 器 的 关注 点 尽可能 地 缩短 垃圾 收集 时 用户 线程 的 停顿 时间， 而 Parallel Scavenge 收集 器 的 目标 则是 达到 一个 可 控制 的 吞吐量（ Throughput）。\n Serial Old 收集 器 |  Serial Old 是 Serial 收集 器 的 老年 代 版本 标记-整理算法 |这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用\n Parallel Old 收集 器 |  Parallel Scavenge 收集 器 的 老年 代 版本 标记-整理算法  |注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。\nCMS收集器 | CMS（ConcurrentMarkSweep）针对老年代进行回收的GC，标记-清除算法 | 收集器是一种以获取最短回收停顿时间为目标的收集器\nG1收集器 | 内存结构变更，相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。 | 服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器。\n\n并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。\n如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于SunHotSpot虚拟机1.6版Update22，这个虚拟机包含的所有收集器如图所示。\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221643962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nHotSpotJVM1.6的垃圾收集器展示了7种作用于不同分代的收集器（包括JDK1.6_Update14后引入的EarlyAccess版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。\n####3.2.1 Serial收集器\n         Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？Serial / Serial Old收集器的运行过程如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221849904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从 JDK 1.3 开始，一直到现在最新的 JDK 1.7，HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）乃至 GC 收集器的最前沿成果 Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RTSJ 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！\n\n写到这里，笔者似乎已经把 Serial 收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。\n\n#### 3.2.2 ParNew收集器\nParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221941057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。\n\n不幸的是，它作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个。ParNew 收集器也是使用 -XX: +UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。\n\nParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。\n\n注意 从 ParNew 收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，他们可以解释为： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个 CPU 上。\n\n#### 3.2.3 ParallelScavenge收集器\nParallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？\n\nParallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。\n\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\nParallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的-XX:GCTimeRatio 参数。\n\nMaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。\n\nGCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），默认值为 99，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。\n\n由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。\n\n####3.2.4 Serial Old 收集 器 \n   Serial Old 是 Serial 收集 器 的 老年 代 版本， 它 同样是 一个 单线 程 收集 器， 使用“ 标记- 整理” 算法。 这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用。 如果 在 Server 模式 下， 它 主要 还有 两大 用途： 一个 是在 JDK 1. 5 及 之前 的 版本 中 与 Parallel Scavenge 收集 器 搭配 使用[ 4]， 另外 一个 就是 作为 CMS 收集 器 的 后备 预 案， 在 并发 收集 发生 Concurrent Mode Failure 的 时候 使用。 这 两点 都将 在后 面的 内容 中 详细 讲解。 Serial Old 收集 器 的 工作 过程 如图 所示。\n\n![这里写图片描述](http://img.blog.csdn.net/20170729114927185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n   \n####3.2.5 Parallel Old 收集 器\n  Parallel Old 是 Parallel Scavenge 收集 器 的 老年 代 版本， 使用 多 线程 和“ 标记－整理” 算法。 这个 收集 器 是在 JDK 1. 6 中 才 开始 提供 的， 在此之前， 新生代 的 Parallel Scavenge 收集 器 一直 处于 比较 尴尬 的 状态。 原因 是， 如果 新生代 选择 了 Parallel Scavenge 收集 器， 老年 代 除了 Serial Old（ PS MarkSweep） 收集 器 外 别无选择（ 还 记得 上面 说过 Parallel Scavenge 收集 器 无法 与 CMS 收集 器 配合 工作 吗？）。 由于 单 线程 的 老 年代 Serial Old 收集 器 在 服务 端 应用 性 能上 的“ 拖累”， 即便 使用 了 Parallel Scavenge 收集 器 也 未必 能在 整体 应用 上 获得 吞吐量 最大化 的 效果， 又因 为 老年 代收 集中 无法 充分 利用 服务器 多 CPU 的 处理 能力， 在 老年 代 很大 而且 硬件 比较 高级的 环境 中， 这种 组合 的 吞吐量 甚至 还不 一 定有 ParNew 加 CMS 的 组合“ 给 力”。 直到 Parallel Old 收集 器 出现 后，“ 吞吐量 优先” 收集 器 终于 有了 比较 名副其实 的 应用 组合， 在 注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。 Parallel Old 收集 器 的 工作 过程 如图所示。\n ![这里写图片描述](http://img.blog.csdn.net/20170728222929126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 3.2.6 CMS收集器\nCMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分如下步骤，\n包括：\n\n 阶段\t|说明\n ----- | -----\n(1) 初始标记 (Initial Mark) |\t(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.\n(2) 并发标记 (Concurrent Marking) |\t在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.\n(3) 再次标记(Remark)\t| (Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.\n(4) 并发清理(Concurrent Sweep) |\t回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.\n(5) 重置(Resetting)| \t清理数据结构,为下一个并发收集做准备.\n其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。ConcurrentMarkSweep收集器运行示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728222952502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nCMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：\n* CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。\n* CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时候虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。\n* 还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。\n后续分开介绍：\n\n#### 3.2.7.G1收集器G1（GarbageFirst）收集器\n\nG1 GC 是 Jdk7 的新特性之一、Jdk7+版本都可以自主配置 G1 作为 JVM GC 选项；作为 JVM GC 算法的一次重大升级、DK7u 后 G1 已相对稳定、且未来计划替代 CMS、所以有必要深入了解下：\n\n不同于其他的分代回收算法、G1 将堆空间划分成了互相独立的区块。每块区域既有可能属于 O 区、也有可能是 Y 区，且每类区域空间可以是不连续的（对比 CMS 的 O 区和 Y 区都必须是连续的）。这种将 O 区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时 G1 仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729121950668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。\n平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：\n\nG1 在压缩空间方面有优势\nG1 通过将内存空间分成区域（Region）的方式避免内存碎片问题\nEden, Survivor, Old 区不再固定、在内存使用效率上来说更灵活\nG1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象\nG1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在 STW（stop the world）的时候做\nG1 会在 Young GC 中使用、而 CMS 只能在 O 区使用\n就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：\n\n服务端多核 CPU、JVM 内存占用较大的应用（至少大于 4G）\n应用在运行过程中会产生大量内存碎片、需要经常压缩空间\n想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象\n一次完整 G1GC 的详细过程：\n\nG1 在运行过程中主要包含如下 4 种操作方式：\n\nYGC（不同于 CMS）\n并发阶段\n混合模式\nfull GC （一般是 G1 出现问题时发生）\nYGC：\n\n下面是一次 YGC 前后内存区域是示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120730189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。\nG1 YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。\n\n目前淘系的应用大都使用 PrintGCDetails 参数打出 GC 日志、这个参数对 G1 同样有效、但日志内容颇为不同；下面是一个 Young GC 的例子：\n```\n23.430: [GC pause (young), 0.23094400 secs]\n...\n[Eden: 1286M(1286M)->0B(1212M)\nSurvivors: 78M->152M Heap: 1454M(4096M)->242M(4096M)][times: user=0.85 sys=0.05, real=0.23 secs]\n```\n\n上面日志的内容解析：Young GC 实际占用 230 毫秒、其中 GC 线程占用 850 毫秒的 CPU 时间\nE：内存占用从 1286MB 变成 0、都被移出\nS：从 78M 增长到了 152M、说明从 Eden 移过来 74M\nHeap:占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间\n很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨\n\n并发阶段：\n\n一个并发 G1 回收周期前后内存占用情况如下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120816584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上面的图表可以看出以下几点：\n1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用\n2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域\n3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收\n\nG1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：\n\n> 50.541: [GC pause (young) (initial-mark), 0.27767100 secs][eden: 1220m(1220m)->0b(1220m) survivors: 144m->144m heap: 3242m(4096m)->2093m(4096m)] [Times: user=1.02 sys=0.04, real=0.28\n>\n> > secs]\n\n上面的日志表明发生了 YGC、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。\n日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，\nG1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20%的 CPU，暂停时间相应的略微变长了些。\n\n接下来，G1 开始扫描根区域、日志示例：\n\n```\n50.819: [GC concurrent-root-region-scan-start]\n51.408: [GC concurrent-root-region-scan-end, 0.5890230]\n```\n\n一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候\n满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的：\n\n```\n> 350.994: [GC pause (young)\n> 351.093: [GC concurrent-root-region-scan-end, 0.6100090]\n> 351.093: [GC concurrent-mark-start],0.37559600 secs]\n```\n\nGC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是 100 毫秒。\n在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：\n\n```\n111.382: [GC concurrent-mark-start] ....\n120.905: [GC concurrent-mark-end, 9.5225160 sec]\n```\n\n并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：\n\n```\n> 120.910: [GC remark 120.959: [GC ref-PRC, 0.0000890 secs], 0.0718990 secs][times: user=0.23 sys=0.01, real=0.08 secs]\n> 120.985: [GC cleanup 3510M->3434M(4096M), 0.0111040 secs][times: user=0.04 sys=0.00, real=0.01 secs]\n```\n\n这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：\n```\n120.996: [GC concurrent-cleanup-start]\n120.996: [GC concurrent-cleanup-end, 0.0004520]\n```\n到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X），实际空间释放较少。\n\n混合 GC：\n\n接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120910552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：\n\n> 79.826: [GC pause (mixed), 0.26161600 secs] .... [Eden: 1222M(1222M)->0B(1220M) Survivors: 142M->144M Heap:\n> 3200M(4096M)->1964M(4096M)][times: user=1.01 sys=0.00, real=0.26 secs]\n> 上面的日志可以注意到 Eden 释放了 1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当 O 区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.\n> 后续分开介绍：。。\n\n## 参考\n深入理解 java 虚拟机\nhttp://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/\n","source":"_posts/language/jvm/JVM垃圾回收.md","raw":"---\ntitle: JVM垃圾回收\ncategories:\n- java\n---\n\n# JVM垃圾回收\n\n## 1.简介\n jvm要进行垃圾回收粗略分为两个步骤：找出需要清理的内存(无效的内存区域) ， 清理无效的内存区域\n 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收所关注的是这部分内存。\n\n## 2. 无效内存区域的查找\n\n### 2.1 概要　\n\nJava堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”。判断方法有引用计数器法和根搜索算法等。\n\n#### 2.1.1 引用计数算法\n\n简单解释为给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当该引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。客观地说，引用计数算法（ReferenceCounting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：\n```java\n/**\n *testGC()方法执行后，objA和objB会不会被GC呢？\n *@authorzzm\n */\npublic class ReferenceCountingGC{　　\n\tpublic Object instance=null;　　 \n\tprivate static final int _1MB=1024*1024;　　\n\t/**　　\n\t*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过　　\n\t*/　　\n\tprivate byte[] bigSize=new byte[2*_1MB];　　\n\tpublic static void testGC(){\n\tReferenceCountingGC objA = new ReferenceCountingGC();\n\tReferenceCountingGC objB = newReferenceCountingGC();\n\tobjA.instance = objB;\n\tobjB.instance = objA;\n\tobjA = null; \n\tobjB = null;\n\t//假设在这行发生GC，那么objA和objB是否能被回收？\n\tSystem.gc();　　\n\t}\n}\n运行结果：\n```\n```\n[FullGC(System)\n[Tenured:0K->210K(10240K),0.0149142secs]\n4603K->210K(19456K),\n[Perm:2999K->2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]\nHeapdefnewgenerationtotal9216K,used82K\n[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Edenspace8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)\nfromspace1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)\ntospace1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)\ntenuredgenerationtotal10240K,used210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)\nthespace10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)\ncompactingpermgentotal21248K,\nused3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)\nthespace21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)\nNosharedspacesconfigured.\n```\n\n代码中testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们，为引用计数器的缺陷。但从运行结果中可以清楚地看到GC日志中包含“4603K->210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。\n\n#### 2.1.2 根搜索算法\n\n在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GCRootsTracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728135643324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。\n在Java语言里，可作为GCRoots的对象包括下面几种：\n* 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n* 方法区中的类静态属性引用的对象。\n* 方法区中的常量引用的对象。\n* 本地方法栈中JNI（即一般说的Native方法）的引用的对象。\n\n### 2.2 java的引用类型\n\n无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。\nJDK1.2之后，Java对引用的概念进行了扩充，并且引用强度不同。如下\n\n引用类型 | 概述\n------|--------\n强引用（StrongReference）|强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象\n软引用（SoftReference）|软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用\n弱引用（WeakReference）|弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用\n虚引用（PhantomReference）|虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用\n\n### 2.3 对象自救\n在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经经历两次标记过程：如果对象在进行根搜索后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。\n```java\n/***此代码演示了两点：\n *1.对象可以在被GC时自我拯救。\n *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次\n *@authorzzm\n * */\npublic class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n    public static void main(String[] args) throws Throwable {\n        SAVE_HOOK = new FinalizeEscapeGC(); //对象 第一次 成功 拯救 自己\n        SAVE_HOOK = null;\n        System.gc(); // 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它\n        Thread.sleep(500);\n        if (SAVE_HOOK != null) {\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\" no, i am dead :(\");\n        } // 下面 这段 代码 与 上面 的 完全 相同， 但是 这次 自救 却 失败 了\n        SAVE_HOOK = null;\n        System.gc(); // 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它\n        Thread.sleep(500);\n        if (SAVE_HOOK != null) {\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\" no, i am dead :(\");\n        }\n    }\n    public void isAlive() {\n        System.out.println(\" yes, i am still alive :)\");\n    }\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\" finalize mehtod executed!\");\n        FinalizeEscapeGC.SAVE_HOOK = this;\n    }\n}\n```\n```\n运行结果：\nfinalize mehtod executed! \nyes, i am still alive :) \nno, i am dead :(\n```\n\n从代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。代码中一次对象自我拯救的演示，在运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。\n### 2.4 回收方法区\n\n很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。\njava中同时满足下面3个条件才能算是“无用的类”：\n\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。\n* 加载该类的ClassLoader已经被回收。\n* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。\n是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类的加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，但-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n## 3. 清理无效内存\n### 3.1 垃圾收集算法\n\n由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。\n#### 3.1.1 标记-清除算法\n\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。\n它的主要缺点有两个：\n* 一个是效率问题，标记和清除过程的效率都不高；\n* 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n如下图为执行标记清除算法后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729100915368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n#### 3.1.2 标记-整理算法\n\n标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。\n主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。\n如下图为执行标记清除算法后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729100943066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n####3.1.3 复制算法\n\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。\n复制算法执行后的内存区域：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729101006020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 3.1.4 分代收集算法 \n分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。\n\n### 3.2 垃圾收集器\n垃圾收集器对比\n\n垃圾收集器 | 解释 | 对比\n-----|-----|-----\nSerial收集器| 新生代复制算法，老年代采用标记整理算法，Serial收集器到JDK1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。| 它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率\nParNew收集器 | 新生代复制算法，老年代采用标记整理算法，ParNew收集器其实就是Serial收集器的多线程版本 | ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。\nParallelScavenge收集器 | 新生代收集器采用复制算法 | Parallel Scavenge 收集 器 的 特点 是它 的 关注 点 与其 他 收集 器 不同， CMS 等 收集 器 的 关注 点 尽可能 地 缩短 垃圾 收集 时 用户 线程 的 停顿 时间， 而 Parallel Scavenge 收集 器 的 目标 则是 达到 一个 可 控制 的 吞吐量（ Throughput）。\n Serial Old 收集 器 |  Serial Old 是 Serial 收集 器 的 老年 代 版本 标记-整理算法 |这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用\n Parallel Old 收集 器 |  Parallel Scavenge 收集 器 的 老年 代 版本 标记-整理算法  |注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。\nCMS收集器 | CMS（ConcurrentMarkSweep）针对老年代进行回收的GC，标记-清除算法 | 收集器是一种以获取最短回收停顿时间为目标的收集器\nG1收集器 | 内存结构变更，相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。 | 服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器。\n\n并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。\n如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于SunHotSpot虚拟机1.6版Update22，这个虚拟机包含的所有收集器如图所示。\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221643962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nHotSpotJVM1.6的垃圾收集器展示了7种作用于不同分代的收集器（包括JDK1.6_Update14后引入的EarlyAccess版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。\n####3.2.1 Serial收集器\n         Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？Serial / Serial Old收集器的运行过程如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221849904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从 JDK 1.3 开始，一直到现在最新的 JDK 1.7，HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）乃至 GC 收集器的最前沿成果 Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RTSJ 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！\n\n写到这里，笔者似乎已经把 Serial 收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。\n\n#### 3.2.2 ParNew收集器\nParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下\n\n![这里写图片描述](http://img.blog.csdn.net/20170728221941057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。\n\n不幸的是，它作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个。ParNew 收集器也是使用 -XX: +UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。\n\nParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。\n\n注意 从 ParNew 收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，他们可以解释为： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个 CPU 上。\n\n#### 3.2.3 ParallelScavenge收集器\nParallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？\n\nParallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。\n\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\nParallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的-XX:GCTimeRatio 参数。\n\nMaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。\n\nGCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），默认值为 99，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。\n\n由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。\n\n####3.2.4 Serial Old 收集 器 \n   Serial Old 是 Serial 收集 器 的 老年 代 版本， 它 同样是 一个 单线 程 收集 器， 使用“ 标记- 整理” 算法。 这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用。 如果 在 Server 模式 下， 它 主要 还有 两大 用途： 一个 是在 JDK 1. 5 及 之前 的 版本 中 与 Parallel Scavenge 收集 器 搭配 使用[ 4]， 另外 一个 就是 作为 CMS 收集 器 的 后备 预 案， 在 并发 收集 发生 Concurrent Mode Failure 的 时候 使用。 这 两点 都将 在后 面的 内容 中 详细 讲解。 Serial Old 收集 器 的 工作 过程 如图 所示。\n\n![这里写图片描述](http://img.blog.csdn.net/20170729114927185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n   \n####3.2.5 Parallel Old 收集 器\n  Parallel Old 是 Parallel Scavenge 收集 器 的 老年 代 版本， 使用 多 线程 和“ 标记－整理” 算法。 这个 收集 器 是在 JDK 1. 6 中 才 开始 提供 的， 在此之前， 新生代 的 Parallel Scavenge 收集 器 一直 处于 比较 尴尬 的 状态。 原因 是， 如果 新生代 选择 了 Parallel Scavenge 收集 器， 老年 代 除了 Serial Old（ PS MarkSweep） 收集 器 外 别无选择（ 还 记得 上面 说过 Parallel Scavenge 收集 器 无法 与 CMS 收集 器 配合 工作 吗？）。 由于 单 线程 的 老 年代 Serial Old 收集 器 在 服务 端 应用 性 能上 的“ 拖累”， 即便 使用 了 Parallel Scavenge 收集 器 也 未必 能在 整体 应用 上 获得 吞吐量 最大化 的 效果， 又因 为 老年 代收 集中 无法 充分 利用 服务器 多 CPU 的 处理 能力， 在 老年 代 很大 而且 硬件 比较 高级的 环境 中， 这种 组合 的 吞吐量 甚至 还不 一 定有 ParNew 加 CMS 的 组合“ 给 力”。 直到 Parallel Old 收集 器 出现 后，“ 吞吐量 优先” 收集 器 终于 有了 比较 名副其实 的 应用 组合， 在 注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。 Parallel Old 收集 器 的 工作 过程 如图所示。\n ![这里写图片描述](http://img.blog.csdn.net/20170728222929126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 3.2.6 CMS收集器\nCMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分如下步骤，\n包括：\n\n 阶段\t|说明\n ----- | -----\n(1) 初始标记 (Initial Mark) |\t(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.\n(2) 并发标记 (Concurrent Marking) |\t在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.\n(3) 再次标记(Remark)\t| (Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.\n(4) 并发清理(Concurrent Sweep) |\t回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.\n(5) 重置(Resetting)| \t清理数据结构,为下一个并发收集做准备.\n其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。ConcurrentMarkSweep收集器运行示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170728222952502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nCMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：\n* CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。\n* CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时候虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。\n* 还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。\n后续分开介绍：\n\n#### 3.2.7.G1收集器G1（GarbageFirst）收集器\n\nG1 GC 是 Jdk7 的新特性之一、Jdk7+版本都可以自主配置 G1 作为 JVM GC 选项；作为 JVM GC 算法的一次重大升级、DK7u 后 G1 已相对稳定、且未来计划替代 CMS、所以有必要深入了解下：\n\n不同于其他的分代回收算法、G1 将堆空间划分成了互相独立的区块。每块区域既有可能属于 O 区、也有可能是 Y 区，且每类区域空间可以是不连续的（对比 CMS 的 O 区和 Y 区都必须是连续的）。这种将 O 区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时 G1 仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729121950668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。\n平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：\n\nG1 在压缩空间方面有优势\nG1 通过将内存空间分成区域（Region）的方式避免内存碎片问题\nEden, Survivor, Old 区不再固定、在内存使用效率上来说更灵活\nG1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象\nG1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在 STW（stop the world）的时候做\nG1 会在 Young GC 中使用、而 CMS 只能在 O 区使用\n就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：\n\n服务端多核 CPU、JVM 内存占用较大的应用（至少大于 4G）\n应用在运行过程中会产生大量内存碎片、需要经常压缩空间\n想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象\n一次完整 G1GC 的详细过程：\n\nG1 在运行过程中主要包含如下 4 种操作方式：\n\nYGC（不同于 CMS）\n并发阶段\n混合模式\nfull GC （一般是 G1 出现问题时发生）\nYGC：\n\n下面是一次 YGC 前后内存区域是示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120730189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。\nG1 YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。\n\n目前淘系的应用大都使用 PrintGCDetails 参数打出 GC 日志、这个参数对 G1 同样有效、但日志内容颇为不同；下面是一个 Young GC 的例子：\n```\n23.430: [GC pause (young), 0.23094400 secs]\n...\n[Eden: 1286M(1286M)->0B(1212M)\nSurvivors: 78M->152M Heap: 1454M(4096M)->242M(4096M)][times: user=0.85 sys=0.05, real=0.23 secs]\n```\n\n上面日志的内容解析：Young GC 实际占用 230 毫秒、其中 GC 线程占用 850 毫秒的 CPU 时间\nE：内存占用从 1286MB 变成 0、都被移出\nS：从 78M 增长到了 152M、说明从 Eden 移过来 74M\nHeap:占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间\n很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨\n\n并发阶段：\n\n一个并发 G1 回收周期前后内存占用情况如下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120816584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上面的图表可以看出以下几点：\n1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用\n2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域\n3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收\n\nG1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：\n\n> 50.541: [GC pause (young) (initial-mark), 0.27767100 secs][eden: 1220m(1220m)->0b(1220m) survivors: 144m->144m heap: 3242m(4096m)->2093m(4096m)] [Times: user=1.02 sys=0.04, real=0.28\n>\n> > secs]\n\n上面的日志表明发生了 YGC、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。\n日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，\nG1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20%的 CPU，暂停时间相应的略微变长了些。\n\n接下来，G1 开始扫描根区域、日志示例：\n\n```\n50.819: [GC concurrent-root-region-scan-start]\n51.408: [GC concurrent-root-region-scan-end, 0.5890230]\n```\n\n一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候\n满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的：\n\n```\n> 350.994: [GC pause (young)\n> 351.093: [GC concurrent-root-region-scan-end, 0.6100090]\n> 351.093: [GC concurrent-mark-start],0.37559600 secs]\n```\n\nGC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是 100 毫秒。\n在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：\n\n```\n111.382: [GC concurrent-mark-start] ....\n120.905: [GC concurrent-mark-end, 9.5225160 sec]\n```\n\n并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：\n\n```\n> 120.910: [GC remark 120.959: [GC ref-PRC, 0.0000890 secs], 0.0718990 secs][times: user=0.23 sys=0.01, real=0.08 secs]\n> 120.985: [GC cleanup 3510M->3434M(4096M), 0.0111040 secs][times: user=0.04 sys=0.00, real=0.01 secs]\n```\n\n这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：\n```\n120.996: [GC concurrent-cleanup-start]\n120.996: [GC concurrent-cleanup-end, 0.0004520]\n```\n到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X），实际空间释放较少。\n\n混合 GC：\n\n接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：\n\n![这里写图片描述](http://img.blog.csdn.net/20170729120910552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：\n\n> 79.826: [GC pause (mixed), 0.26161600 secs] .... [Eden: 1222M(1222M)->0B(1220M) Survivors: 142M->144M Heap:\n> 3200M(4096M)->1964M(4096M)][times: user=1.01 sys=0.00, real=0.26 secs]\n> 上面的日志可以注意到 Eden 释放了 1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当 O 区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.\n> 后续分开介绍：。。\n\n## 参考\n深入理解 java 虚拟机\nhttp://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/\n","slug":"language/jvm/JVM垃圾回收","published":1,"date":"2021-07-31T09:04:32.037Z","updated":"2021-07-31T09:04:32.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bz000hy2uk74un1jvu","content":"<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p> jvm要进行垃圾回收粗略分为两个步骤：找出需要清理的内存(无效的内存区域) ， 清理无效的内存区域<br> 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收所关注的是这部分内存。</p>\n<h2 id=\"2-无效内存区域的查找\"><a href=\"#2-无效内存区域的查找\" class=\"headerlink\" title=\"2. 无效内存区域的查找\"></a>2. 无效内存区域的查找</h2><h3 id=\"2-1-概要\"><a href=\"#2-1-概要\" class=\"headerlink\" title=\"2.1 概要\"></a>2.1 概要</h3><p>Java堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”。判断方法有引用计数器法和根搜索算法等。</p>\n<h4 id=\"2-1-1-引用计数算法\"><a href=\"#2-1-1-引用计数算法\" class=\"headerlink\" title=\"2.1.1 引用计数算法\"></a>2.1.1 引用计数算法</h4><p>简单解释为给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当该引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。客观地说，引用计数算法（ReferenceCounting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class=\"line\"><span class=\"comment\"> *<span class=\"doctag\">@authorzzm</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span></span>&#123;　　</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Object instance=<span class=\"keyword\">null</span>;　　 </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;　　</span><br><span class=\"line\">\t<span class=\"comment\">/**　　</span></span><br><span class=\"line\"><span class=\"comment\">\t*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过　　</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span>　　</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span>*_1MB];　　</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tReferenceCountingGC objA = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\">\tReferenceCountingGC objB = newReferenceCountingGC();</span><br><span class=\"line\">\tobjA.instance = objB;</span><br><span class=\"line\">\tobjB.instance = objA;</span><br><span class=\"line\">\tobjA = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">\tobjB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//假设在这行发生GC，那么objA和objB是否能被回收？</span></span><br><span class=\"line\">\tSystem.gc();　　</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行结果：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[FullGC(System)</span><br><span class=\"line\">[Tenured:0K-&gt;210K(10240K),0.0149142secs]</span><br><span class=\"line\">4603K-&gt;210K(19456K),</span><br><span class=\"line\">[Perm:2999K-&gt;2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]</span><br><span class=\"line\">Heapdefnewgenerationtotal9216K,used82K</span><br><span class=\"line\">[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Edenspace8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)</span><br><span class=\"line\">fromspace1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)</span><br><span class=\"line\">tospace1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)</span><br><span class=\"line\">tenuredgenerationtotal10240K,used210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)</span><br><span class=\"line\">thespace10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)</span><br><span class=\"line\">compactingpermgentotal21248K,</span><br><span class=\"line\">used3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)</span><br><span class=\"line\">thespace21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)</span><br><span class=\"line\">Nosharedspacesconfigured.</span><br></pre></td></tr></table></figure>\n\n<p>代码中testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们，为引用计数器的缺陷。但从运行结果中可以清楚地看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>\n<h4 id=\"2-1-2-根搜索算法\"><a href=\"#2-1-2-根搜索算法\" class=\"headerlink\" title=\"2.1.2 根搜索算法\"></a>2.1.2 根搜索算法</h4><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GCRootsTracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170728135643324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。<br>在Java语言里，可作为GCRoots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>\n</ul>\n<h3 id=\"2-2-java的引用类型\"><a href=\"#2-2-java的引用类型\" class=\"headerlink\" title=\"2.2 java的引用类型\"></a>2.2 java的引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br>JDK1.2之后，Java对引用的概念进行了扩充，并且引用强度不同。如下</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>概述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用（StrongReference）</td>\n<td>强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</td>\n</tr>\n<tr>\n<td>软引用（SoftReference）</td>\n<td>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用</td>\n</tr>\n<tr>\n<td>弱引用（WeakReference）</td>\n<td>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</td>\n</tr>\n<tr>\n<td>虚引用（PhantomReference）</td>\n<td>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-对象自救\"><a href=\"#2-3-对象自救\" class=\"headerlink\" title=\"2.3 对象自救\"></a>2.3 对象自救</h3><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经经历两次标记过程：如果对象在进行根搜索后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***此代码演示了两点：</span></span><br><span class=\"line\"><span class=\"comment\"> *1.对象可以在被GC时自我拯救。</span></span><br><span class=\"line\"><span class=\"comment\"> *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class=\"line\"><span class=\"comment\"> *<span class=\"doctag\">@authorzzm</span></span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC(); <span class=\"comment\">//对象 第一次 成功 拯救 自己</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc(); <span class=\"comment\">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; no, i am dead :(&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 下面 这段 代码 与 上面 的 完全 相同， 但是 这次 自救 却 失败 了</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc(); <span class=\"comment\">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; no, i am dead :(&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; yes, i am still alive :)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; finalize mehtod executed!&quot;</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\">finalize mehtod executed! </span><br><span class=\"line\">yes, i am still alive :) </span><br><span class=\"line\">no, i am dead :(</span><br></pre></td></tr></table></figure>\n\n<p>从代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。代码中一次对象自我拯救的演示，在运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p>\n<h3 id=\"2-4-回收方法区\"><a href=\"#2-4-回收方法区\" class=\"headerlink\" title=\"2.4 回收方法区\"></a>2.4 回收方法区</h3><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。<br>java中同时满足下面3个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。<br>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类的加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，但-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h2 id=\"3-清理无效内存\"><a href=\"#3-清理无效内存\" class=\"headerlink\" title=\"3. 清理无效内存\"></a>3. 清理无效内存</h2><h3 id=\"3-1-垃圾收集算法\"><a href=\"#3-1-垃圾收集算法\" class=\"headerlink\" title=\"3.1 垃圾收集算法\"></a>3.1 垃圾收集算法</h3><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。</p>\n<h4 id=\"3-1-1-标记-清除算法\"><a href=\"#3-1-1-标记-清除算法\" class=\"headerlink\" title=\"3.1.1 标记-清除算法\"></a>3.1.1 标记-清除算法</h4><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>它的主要缺点有两个：</p>\n<ul>\n<li>一个是效率问题，标记和清除过程的效率都不高；</li>\n<li>一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>如下图为执行标记清除算法后的内存区域：</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20170729100915368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-1-2-标记-整理算法\"><a href=\"#3-1-2-标记-整理算法\" class=\"headerlink\" title=\"3.1.2 标记-整理算法\"></a>3.1.2 标记-整理算法</h4><p>标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。<br>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。<br>如下图为执行标记清除算法后的内存区域：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729100943066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####3.1.3 复制算法</p>\n<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。<br>复制算法执行后的内存区域：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729101006020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-1-4-分代收集算法\"><a href=\"#3-1-4-分代收集算法\" class=\"headerlink\" title=\"3.1.4 分代收集算法\"></a>3.1.4 分代收集算法</h4><p>分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>\n<h3 id=\"3-2-垃圾收集器\"><a href=\"#3-2-垃圾收集器\" class=\"headerlink\" title=\"3.2 垃圾收集器\"></a>3.2 垃圾收集器</h3><p>垃圾收集器对比</p>\n<table>\n<thead>\n<tr>\n<th>垃圾收集器</th>\n<th>解释</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serial收集器</td>\n<td>新生代复制算法，老年代采用标记整理算法，Serial收集器到JDK1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。</td>\n<td>它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</td>\n</tr>\n<tr>\n<td>ParNew收集器</td>\n<td>新生代复制算法，老年代采用标记整理算法，ParNew收集器其实就是Serial收集器的多线程版本</td>\n<td>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</td>\n</tr>\n<tr>\n<td>ParallelScavenge收集器</td>\n<td>新生代收集器采用复制算法</td>\n<td>Parallel Scavenge 收集 器 的 特点 是它 的 关注 点 与其 他 收集 器 不同， CMS 等 收集 器 的 关注 点 尽可能 地 缩短 垃圾 收集 时 用户 线程 的 停顿 时间， 而 Parallel Scavenge 收集 器 的 目标 则是 达到 一个 可 控制 的 吞吐量（ Throughput）。</td>\n</tr>\n<tr>\n<td>Serial Old 收集 器</td>\n<td>Serial Old 是 Serial 收集 器 的 老年 代 版本 标记-整理算法</td>\n<td>这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用</td>\n</tr>\n<tr>\n<td>Parallel Old 收集 器</td>\n<td>Parallel Scavenge 收集 器 的 老年 代 版本 标记-整理算法</td>\n<td>注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。</td>\n</tr>\n<tr>\n<td>CMS收集器</td>\n<td>CMS（ConcurrentMarkSweep）针对老年代进行回收的GC，标记-清除算法</td>\n<td>收集器是一种以获取最短回收停顿时间为目标的收集器</td>\n</tr>\n<tr>\n<td>G1收集器</td>\n<td>内存结构变更，相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。</td>\n<td>服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器。</td>\n</tr>\n</tbody></table>\n<p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。<br>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于SunHotSpot虚拟机1.6版Update22，这个虚拟机包含的所有收集器如图所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221643962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>HotSpotJVM1.6的垃圾收集器展示了7种作用于不同分代的收集器（包括JDK1.6_Update14后引入的EarlyAccess版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。<br>####3.2.1 Serial收集器<br>         Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？Serial / Serial Old收集器的运行过程如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221849904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>从 JDK 1.3 开始，一直到现在最新的 JDK 1.7，HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）乃至 GC 收集器的最前沿成果 Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RTSJ 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p>\n<p>写到这里，笔者似乎已经把 Serial 收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p>\n<h4 id=\"3-2-2-ParNew收集器\"><a href=\"#3-2-2-ParNew收集器\" class=\"headerlink\" title=\"3.2.2 ParNew收集器\"></a>3.2.2 ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221941057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。</p>\n<p>不幸的是，它作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个。ParNew 收集器也是使用 -XX: +UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。</p>\n<p>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p>\n<p>注意 从 ParNew 收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，他们可以解释为： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个 CPU 上。</p>\n<h4 id=\"3-2-3-ParallelScavenge收集器\"><a href=\"#3-2-3-ParallelScavenge收集器\" class=\"headerlink\" title=\"3.2.3 ParallelScavenge收集器\"></a>3.2.3 ParallelScavenge收集器</h4><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p>\n<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>\n<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\n<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的-XX:GCTimeRatio 参数。</p>\n<p>MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>\n<p>GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），默认值为 99，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。</p>\n<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>\n<p>####3.2.4 Serial Old 收集 器<br>   Serial Old 是 Serial 收集 器 的 老年 代 版本， 它 同样是 一个 单线 程 收集 器， 使用“ 标记- 整理” 算法。 这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用。 如果 在 Server 模式 下， 它 主要 还有 两大 用途： 一个 是在 JDK 1. 5 及 之前 的 版本 中 与 Parallel Scavenge 收集 器 搭配 使用[ 4]， 另外 一个 就是 作为 CMS 收集 器 的 后备 预 案， 在 并发 收集 发生 Concurrent Mode Failure 的 时候 使用。 这 两点 都将 在后 面的 内容 中 详细 讲解。 Serial Old 收集 器 的 工作 过程 如图 所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20170729114927185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####3.2.5 Parallel Old 收集 器<br>  Parallel Old 是 Parallel Scavenge 收集 器 的 老年 代 版本， 使用 多 线程 和“ 标记－整理” 算法。 这个 收集 器 是在 JDK 1. 6 中 才 开始 提供 的， 在此之前， 新生代 的 Parallel Scavenge 收集 器 一直 处于 比较 尴尬 的 状态。 原因 是， 如果 新生代 选择 了 Parallel Scavenge 收集 器， 老年 代 除了 Serial Old（ PS MarkSweep） 收集 器 外 别无选择（ 还 记得 上面 说过 Parallel Scavenge 收集 器 无法 与 CMS 收集 器 配合 工作 吗？）。 由于 单 线程 的 老 年代 Serial Old 收集 器 在 服务 端 应用 性 能上 的“ 拖累”， 即便 使用 了 Parallel Scavenge 收集 器 也 未必 能在 整体 应用 上 获得 吞吐量 最大化 的 效果， 又因 为 老年 代收 集中 无法 充分 利用 服务器 多 CPU 的 处理 能力， 在 老年 代 很大 而且 硬件 比较 高级的 环境 中， 这种 组合 的 吞吐量 甚至 还不 一 定有 ParNew 加 CMS 的 组合“ 给 力”。 直到 Parallel Old 收集 器 出现 后，“ 吞吐量 优先” 收集 器 终于 有了 比较 名副其实 的 应用 组合， 在 注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。 Parallel Old 收集 器 的 工作 过程 如图所示。<br> <img src=\"http://img.blog.csdn.net/20170728222929126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-2-6-CMS收集器\"><a href=\"#3-2-6-CMS收集器\" class=\"headerlink\" title=\"3.2.6 CMS收集器\"></a>3.2.6 CMS收集器</h4><p>CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分如下步骤，<br>包括：</p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(1) 初始标记 (Initial Mark)</td>\n<td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td>\n</tr>\n<tr>\n<td>(2) 并发标记 (Concurrent Marking)</td>\n<td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td>\n</tr>\n<tr>\n<td>(3) 再次标记(Remark)</td>\n<td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td>\n</tr>\n<tr>\n<td>(4) 并发清理(Concurrent Sweep)</td>\n<td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td>\n</tr>\n<tr>\n<td>(5) 重置(Resetting)</td>\n<td>清理数据结构,为下一个并发收集做准备.</td>\n</tr>\n<tr>\n<td>其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。ConcurrentMarkSweep收集器运行示意图：</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"http://img.blog.csdn.net/20170728222952502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p>\n<ul>\n<li>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</li>\n<li>CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时候虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。</li>\n<li>还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。<br>后续分开介绍：</li>\n</ul>\n<h4 id=\"3-2-7-G1收集器G1（GarbageFirst）收集器\"><a href=\"#3-2-7-G1收集器G1（GarbageFirst）收集器\" class=\"headerlink\" title=\"3.2.7.G1收集器G1（GarbageFirst）收集器\"></a>3.2.7.G1收集器G1（GarbageFirst）收集器</h4><p>G1 GC 是 Jdk7 的新特性之一、Jdk7+版本都可以自主配置 G1 作为 JVM GC 选项；作为 JVM GC 算法的一次重大升级、DK7u 后 G1 已相对稳定、且未来计划替代 CMS、所以有必要深入了解下：</p>\n<p>不同于其他的分代回收算法、G1 将堆空间划分成了互相独立的区块。每块区域既有可能属于 O 区、也有可能是 Y 区，且每类区域空间可以是不连续的（对比 CMS 的 O 区和 Y 区都必须是连续的）。这种将 O 区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时 G1 仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729121950668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。<br>平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：</p>\n<p>G1 在压缩空间方面有优势<br>G1 通过将内存空间分成区域（Region）的方式避免内存碎片问题<br>Eden, Survivor, Old 区不再固定、在内存使用效率上来说更灵活<br>G1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象<br>G1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在 STW（stop the world）的时候做<br>G1 会在 Young GC 中使用、而 CMS 只能在 O 区使用<br>就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：</p>\n<p>服务端多核 CPU、JVM 内存占用较大的应用（至少大于 4G）<br>应用在运行过程中会产生大量内存碎片、需要经常压缩空间<br>想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象<br>一次完整 G1GC 的详细过程：</p>\n<p>G1 在运行过程中主要包含如下 4 种操作方式：</p>\n<p>YGC（不同于 CMS）<br>并发阶段<br>混合模式<br>full GC （一般是 G1 出现问题时发生）<br>YGC：</p>\n<p>下面是一次 YGC 前后内存区域是示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120730189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。<br>G1 YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。</p>\n<p>目前淘系的应用大都使用 PrintGCDetails 参数打出 GC 日志、这个参数对 G1 同样有效、但日志内容颇为不同；下面是一个 Young GC 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23.430: [GC pause (young), 0.23094400 secs]</span><br><span class=\"line\">...</span><br><span class=\"line\">[Eden: 1286M(1286M)-&gt;0B(1212M)</span><br><span class=\"line\">Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)][times: user=0.85 sys=0.05, real=0.23 secs]</span><br></pre></td></tr></table></figure>\n\n<p>上面日志的内容解析：Young GC 实际占用 230 毫秒、其中 GC 线程占用 850 毫秒的 CPU 时间<br>E：内存占用从 1286MB 变成 0、都被移出<br>S：从 78M 增长到了 152M、说明从 Eden 移过来 74M<br>Heap:占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间<br>很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨</p>\n<p>并发阶段：</p>\n<p>一个并发 G1 回收周期前后内存占用情况如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120816584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>从上面的图表可以看出以下几点：<br>1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用<br>2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域<br>3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收</p>\n<p>G1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：</p>\n<blockquote>\n<p>50.541: [GC pause (young) (initial-mark), 0.27767100 secs][eden: 1220m(1220m)-&gt;0b(1220m) survivors: 144m-&gt;144m heap: 3242m(4096m)-&gt;2093m(4096m)] [Times: user=1.02 sys=0.04, real=0.28</p>\n<blockquote>\n<p>secs]</p>\n</blockquote>\n</blockquote>\n<p>上面的日志表明发生了 YGC、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。<br>日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，<br>G1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20%的 CPU，暂停时间相应的略微变长了些。</p>\n<p>接下来，G1 开始扫描根区域、日志示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">50.819: [GC concurrent-root-region-scan-start]</span><br><span class=\"line\">51.408: [GC concurrent-root-region-scan-end, 0.5890230]</span><br></pre></td></tr></table></figure>\n\n<p>一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候<br>满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 350.994: [GC pause (young)</span><br><span class=\"line\">&gt; 351.093: [GC concurrent-root-region-scan-end, 0.6100090]</span><br><span class=\"line\">&gt; 351.093: [GC concurrent-mark-start],0.37559600 secs]</span><br></pre></td></tr></table></figure>\n\n<p>GC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是 100 毫秒。<br>在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">111.382: [GC concurrent-mark-start] ....</span><br><span class=\"line\">120.905: [GC concurrent-mark-end, 9.5225160 sec]</span><br></pre></td></tr></table></figure>\n\n<p>并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 120.910: [GC remark 120.959: [GC ref-PRC, 0.0000890 secs], 0.0718990 secs][times: user=0.23 sys=0.01, real=0.08 secs]</span><br><span class=\"line\">&gt; 120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs][times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n\n<p>这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">120.996: [GC concurrent-cleanup-start]</span><br><span class=\"line\">120.996: [GC concurrent-cleanup-end, 0.0004520]</span><br></pre></td></tr></table></figure>\n<p>到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X），实际空间释放较少。</p>\n<p>混合 GC：</p>\n<p>接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120910552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：</p>\n<blockquote>\n<p>79.826: [GC pause (mixed), 0.26161600 secs] …. [Eden: 1222M(1222M)-&gt;0B(1220M) Survivors: 142M-&gt;144M Heap:<br>3200M(4096M)-&gt;1964M(4096M)][times: user=1.01 sys=0.00, real=0.26 secs]<br>上面的日志可以注意到 Eden 释放了 1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当 O 区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.<br>后续分开介绍：。。</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>深入理解 java 虚拟机<br><a href=\"http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/\">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p> jvm要进行垃圾回收粗略分为两个步骤：找出需要清理的内存(无效的内存区域) ， 清理无效的内存区域<br> 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收所关注的是这部分内存。</p>\n<h2 id=\"2-无效内存区域的查找\"><a href=\"#2-无效内存区域的查找\" class=\"headerlink\" title=\"2. 无效内存区域的查找\"></a>2. 无效内存区域的查找</h2><h3 id=\"2-1-概要\"><a href=\"#2-1-概要\" class=\"headerlink\" title=\"2.1 概要\"></a>2.1 概要</h3><p>Java堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”。判断方法有引用计数器法和根搜索算法等。</p>\n<h4 id=\"2-1-1-引用计数算法\"><a href=\"#2-1-1-引用计数算法\" class=\"headerlink\" title=\"2.1.1 引用计数算法\"></a>2.1.1 引用计数算法</h4><p>简单解释为给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当该引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。客观地说，引用计数算法（ReferenceCounting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class=\"line\"><span class=\"comment\"> *<span class=\"doctag\">@authorzzm</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span></span>&#123;　　</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Object instance=<span class=\"keyword\">null</span>;　　 </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;　　</span><br><span class=\"line\">\t<span class=\"comment\">/**　　</span></span><br><span class=\"line\"><span class=\"comment\">\t*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过　　</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span>　　</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span>*_1MB];　　</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tReferenceCountingGC objA = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\">\tReferenceCountingGC objB = newReferenceCountingGC();</span><br><span class=\"line\">\tobjA.instance = objB;</span><br><span class=\"line\">\tobjB.instance = objA;</span><br><span class=\"line\">\tobjA = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">\tobjB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//假设在这行发生GC，那么objA和objB是否能被回收？</span></span><br><span class=\"line\">\tSystem.gc();　　</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行结果：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[FullGC(System)</span><br><span class=\"line\">[Tenured:0K-&gt;210K(10240K),0.0149142secs]</span><br><span class=\"line\">4603K-&gt;210K(19456K),</span><br><span class=\"line\">[Perm:2999K-&gt;2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]</span><br><span class=\"line\">Heapdefnewgenerationtotal9216K,used82K</span><br><span class=\"line\">[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Edenspace8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)</span><br><span class=\"line\">fromspace1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)</span><br><span class=\"line\">tospace1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)</span><br><span class=\"line\">tenuredgenerationtotal10240K,used210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)</span><br><span class=\"line\">thespace10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)</span><br><span class=\"line\">compactingpermgentotal21248K,</span><br><span class=\"line\">used3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)</span><br><span class=\"line\">thespace21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)</span><br><span class=\"line\">Nosharedspacesconfigured.</span><br></pre></td></tr></table></figure>\n\n<p>代码中testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们，为引用计数器的缺陷。但从运行结果中可以清楚地看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>\n<h4 id=\"2-1-2-根搜索算法\"><a href=\"#2-1-2-根搜索算法\" class=\"headerlink\" title=\"2.1.2 根搜索算法\"></a>2.1.2 根搜索算法</h4><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GCRootsTracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170728135643324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。<br>在Java语言里，可作为GCRoots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>\n</ul>\n<h3 id=\"2-2-java的引用类型\"><a href=\"#2-2-java的引用类型\" class=\"headerlink\" title=\"2.2 java的引用类型\"></a>2.2 java的引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br>JDK1.2之后，Java对引用的概念进行了扩充，并且引用强度不同。如下</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>概述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用（StrongReference）</td>\n<td>强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</td>\n</tr>\n<tr>\n<td>软引用（SoftReference）</td>\n<td>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用</td>\n</tr>\n<tr>\n<td>弱引用（WeakReference）</td>\n<td>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</td>\n</tr>\n<tr>\n<td>虚引用（PhantomReference）</td>\n<td>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-对象自救\"><a href=\"#2-3-对象自救\" class=\"headerlink\" title=\"2.3 对象自救\"></a>2.3 对象自救</h3><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经经历两次标记过程：如果对象在进行根搜索后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***此代码演示了两点：</span></span><br><span class=\"line\"><span class=\"comment\"> *1.对象可以在被GC时自我拯救。</span></span><br><span class=\"line\"><span class=\"comment\"> *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class=\"line\"><span class=\"comment\"> *<span class=\"doctag\">@authorzzm</span></span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC(); <span class=\"comment\">//对象 第一次 成功 拯救 自己</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc(); <span class=\"comment\">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; no, i am dead :(&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 下面 这段 代码 与 上面 的 完全 相同， 但是 这次 自救 却 失败 了</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc(); <span class=\"comment\">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; no, i am dead :(&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; yes, i am still alive :)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; finalize mehtod executed!&quot;</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\">finalize mehtod executed! </span><br><span class=\"line\">yes, i am still alive :) </span><br><span class=\"line\">no, i am dead :(</span><br></pre></td></tr></table></figure>\n\n<p>从代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。代码中一次对象自我拯救的演示，在运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p>\n<h3 id=\"2-4-回收方法区\"><a href=\"#2-4-回收方法区\" class=\"headerlink\" title=\"2.4 回收方法区\"></a>2.4 回收方法区</h3><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。<br>java中同时满足下面3个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。<br>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类的加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，但-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h2 id=\"3-清理无效内存\"><a href=\"#3-清理无效内存\" class=\"headerlink\" title=\"3. 清理无效内存\"></a>3. 清理无效内存</h2><h3 id=\"3-1-垃圾收集算法\"><a href=\"#3-1-垃圾收集算法\" class=\"headerlink\" title=\"3.1 垃圾收集算法\"></a>3.1 垃圾收集算法</h3><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。</p>\n<h4 id=\"3-1-1-标记-清除算法\"><a href=\"#3-1-1-标记-清除算法\" class=\"headerlink\" title=\"3.1.1 标记-清除算法\"></a>3.1.1 标记-清除算法</h4><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>它的主要缺点有两个：</p>\n<ul>\n<li>一个是效率问题，标记和清除过程的效率都不高；</li>\n<li>一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>如下图为执行标记清除算法后的内存区域：</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20170729100915368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-1-2-标记-整理算法\"><a href=\"#3-1-2-标记-整理算法\" class=\"headerlink\" title=\"3.1.2 标记-整理算法\"></a>3.1.2 标记-整理算法</h4><p>标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。<br>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。<br>如下图为执行标记清除算法后的内存区域：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729100943066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####3.1.3 复制算法</p>\n<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。<br>复制算法执行后的内存区域：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729101006020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-1-4-分代收集算法\"><a href=\"#3-1-4-分代收集算法\" class=\"headerlink\" title=\"3.1.4 分代收集算法\"></a>3.1.4 分代收集算法</h4><p>分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>\n<h3 id=\"3-2-垃圾收集器\"><a href=\"#3-2-垃圾收集器\" class=\"headerlink\" title=\"3.2 垃圾收集器\"></a>3.2 垃圾收集器</h3><p>垃圾收集器对比</p>\n<table>\n<thead>\n<tr>\n<th>垃圾收集器</th>\n<th>解释</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serial收集器</td>\n<td>新生代复制算法，老年代采用标记整理算法，Serial收集器到JDK1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。</td>\n<td>它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</td>\n</tr>\n<tr>\n<td>ParNew收集器</td>\n<td>新生代复制算法，老年代采用标记整理算法，ParNew收集器其实就是Serial收集器的多线程版本</td>\n<td>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</td>\n</tr>\n<tr>\n<td>ParallelScavenge收集器</td>\n<td>新生代收集器采用复制算法</td>\n<td>Parallel Scavenge 收集 器 的 特点 是它 的 关注 点 与其 他 收集 器 不同， CMS 等 收集 器 的 关注 点 尽可能 地 缩短 垃圾 收集 时 用户 线程 的 停顿 时间， 而 Parallel Scavenge 收集 器 的 目标 则是 达到 一个 可 控制 的 吞吐量（ Throughput）。</td>\n</tr>\n<tr>\n<td>Serial Old 收集 器</td>\n<td>Serial Old 是 Serial 收集 器 的 老年 代 版本 标记-整理算法</td>\n<td>这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用</td>\n</tr>\n<tr>\n<td>Parallel Old 收集 器</td>\n<td>Parallel Scavenge 收集 器 的 老年 代 版本 标记-整理算法</td>\n<td>注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。</td>\n</tr>\n<tr>\n<td>CMS收集器</td>\n<td>CMS（ConcurrentMarkSweep）针对老年代进行回收的GC，标记-清除算法</td>\n<td>收集器是一种以获取最短回收停顿时间为目标的收集器</td>\n</tr>\n<tr>\n<td>G1收集器</td>\n<td>内存结构变更，相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。</td>\n<td>服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器。</td>\n</tr>\n</tbody></table>\n<p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。<br>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于SunHotSpot虚拟机1.6版Update22，这个虚拟机包含的所有收集器如图所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221643962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>HotSpotJVM1.6的垃圾收集器展示了7种作用于不同分代的收集器（包括JDK1.6_Update14后引入的EarlyAccess版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。<br>####3.2.1 Serial收集器<br>         Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？Serial / Serial Old收集器的运行过程如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221849904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>从 JDK 1.3 开始，一直到现在最新的 JDK 1.7，HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）乃至 GC 收集器的最前沿成果 Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RTSJ 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p>\n<p>写到这里，笔者似乎已经把 Serial 收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p>\n<h4 id=\"3-2-2-ParNew收集器\"><a href=\"#3-2-2-ParNew收集器\" class=\"headerlink\" title=\"3.2.2 ParNew收集器\"></a>3.2.2 ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下</p>\n<p><img src=\"http://img.blog.csdn.net/20170728221941057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。</p>\n<p>不幸的是，它作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个。ParNew 收集器也是使用 -XX: +UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。</p>\n<p>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p>\n<p>注意 从 ParNew 收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，他们可以解释为： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个 CPU 上。</p>\n<h4 id=\"3-2-3-ParallelScavenge收集器\"><a href=\"#3-2-3-ParallelScavenge收集器\" class=\"headerlink\" title=\"3.2.3 ParallelScavenge收集器\"></a>3.2.3 ParallelScavenge收集器</h4><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p>\n<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>\n<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\n<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的-XX:GCTimeRatio 参数。</p>\n<p>MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>\n<p>GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），默认值为 99，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。</p>\n<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>\n<p>####3.2.4 Serial Old 收集 器<br>   Serial Old 是 Serial 收集 器 的 老年 代 版本， 它 同样是 一个 单线 程 收集 器， 使用“ 标记- 整理” 算法。 这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用。 如果 在 Server 模式 下， 它 主要 还有 两大 用途： 一个 是在 JDK 1. 5 及 之前 的 版本 中 与 Parallel Scavenge 收集 器 搭配 使用[ 4]， 另外 一个 就是 作为 CMS 收集 器 的 后备 预 案， 在 并发 收集 发生 Concurrent Mode Failure 的 时候 使用。 这 两点 都将 在后 面的 内容 中 详细 讲解。 Serial Old 收集 器 的 工作 过程 如图 所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20170729114927185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####3.2.5 Parallel Old 收集 器<br>  Parallel Old 是 Parallel Scavenge 收集 器 的 老年 代 版本， 使用 多 线程 和“ 标记－整理” 算法。 这个 收集 器 是在 JDK 1. 6 中 才 开始 提供 的， 在此之前， 新生代 的 Parallel Scavenge 收集 器 一直 处于 比较 尴尬 的 状态。 原因 是， 如果 新生代 选择 了 Parallel Scavenge 收集 器， 老年 代 除了 Serial Old（ PS MarkSweep） 收集 器 外 别无选择（ 还 记得 上面 说过 Parallel Scavenge 收集 器 无法 与 CMS 收集 器 配合 工作 吗？）。 由于 单 线程 的 老 年代 Serial Old 收集 器 在 服务 端 应用 性 能上 的“ 拖累”， 即便 使用 了 Parallel Scavenge 收集 器 也 未必 能在 整体 应用 上 获得 吞吐量 最大化 的 效果， 又因 为 老年 代收 集中 无法 充分 利用 服务器 多 CPU 的 处理 能力， 在 老年 代 很大 而且 硬件 比较 高级的 环境 中， 这种 组合 的 吞吐量 甚至 还不 一 定有 ParNew 加 CMS 的 组合“ 给 力”。 直到 Parallel Old 收集 器 出现 后，“ 吞吐量 优先” 收集 器 终于 有了 比较 名副其实 的 应用 组合， 在 注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。 Parallel Old 收集 器 的 工作 过程 如图所示。<br> <img src=\"http://img.blog.csdn.net/20170728222929126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"3-2-6-CMS收集器\"><a href=\"#3-2-6-CMS收集器\" class=\"headerlink\" title=\"3.2.6 CMS收集器\"></a>3.2.6 CMS收集器</h4><p>CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分如下步骤，<br>包括：</p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(1) 初始标记 (Initial Mark)</td>\n<td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td>\n</tr>\n<tr>\n<td>(2) 并发标记 (Concurrent Marking)</td>\n<td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td>\n</tr>\n<tr>\n<td>(3) 再次标记(Remark)</td>\n<td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td>\n</tr>\n<tr>\n<td>(4) 并发清理(Concurrent Sweep)</td>\n<td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td>\n</tr>\n<tr>\n<td>(5) 重置(Resetting)</td>\n<td>清理数据结构,为下一个并发收集做准备.</td>\n</tr>\n<tr>\n<td>其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。ConcurrentMarkSweep收集器运行示意图：</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"http://img.blog.csdn.net/20170728222952502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p>\n<ul>\n<li>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</li>\n<li>CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时候虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。</li>\n<li>还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。<br>后续分开介绍：</li>\n</ul>\n<h4 id=\"3-2-7-G1收集器G1（GarbageFirst）收集器\"><a href=\"#3-2-7-G1收集器G1（GarbageFirst）收集器\" class=\"headerlink\" title=\"3.2.7.G1收集器G1（GarbageFirst）收集器\"></a>3.2.7.G1收集器G1（GarbageFirst）收集器</h4><p>G1 GC 是 Jdk7 的新特性之一、Jdk7+版本都可以自主配置 G1 作为 JVM GC 选项；作为 JVM GC 算法的一次重大升级、DK7u 后 G1 已相对稳定、且未来计划替代 CMS、所以有必要深入了解下：</p>\n<p>不同于其他的分代回收算法、G1 将堆空间划分成了互相独立的区块。每块区域既有可能属于 O 区、也有可能是 Y 区，且每类区域空间可以是不连续的（对比 CMS 的 O 区和 Y 区都必须是连续的）。这种将 O 区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时 G1 仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729121950668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。<br>平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：</p>\n<p>G1 在压缩空间方面有优势<br>G1 通过将内存空间分成区域（Region）的方式避免内存碎片问题<br>Eden, Survivor, Old 区不再固定、在内存使用效率上来说更灵活<br>G1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象<br>G1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在 STW（stop the world）的时候做<br>G1 会在 Young GC 中使用、而 CMS 只能在 O 区使用<br>就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：</p>\n<p>服务端多核 CPU、JVM 内存占用较大的应用（至少大于 4G）<br>应用在运行过程中会产生大量内存碎片、需要经常压缩空间<br>想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象<br>一次完整 G1GC 的详细过程：</p>\n<p>G1 在运行过程中主要包含如下 4 种操作方式：</p>\n<p>YGC（不同于 CMS）<br>并发阶段<br>混合模式<br>full GC （一般是 G1 出现问题时发生）<br>YGC：</p>\n<p>下面是一次 YGC 前后内存区域是示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120730189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。<br>G1 YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。</p>\n<p>目前淘系的应用大都使用 PrintGCDetails 参数打出 GC 日志、这个参数对 G1 同样有效、但日志内容颇为不同；下面是一个 Young GC 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23.430: [GC pause (young), 0.23094400 secs]</span><br><span class=\"line\">...</span><br><span class=\"line\">[Eden: 1286M(1286M)-&gt;0B(1212M)</span><br><span class=\"line\">Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)][times: user=0.85 sys=0.05, real=0.23 secs]</span><br></pre></td></tr></table></figure>\n\n<p>上面日志的内容解析：Young GC 实际占用 230 毫秒、其中 GC 线程占用 850 毫秒的 CPU 时间<br>E：内存占用从 1286MB 变成 0、都被移出<br>S：从 78M 增长到了 152M、说明从 Eden 移过来 74M<br>Heap:占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间<br>很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨</p>\n<p>并发阶段：</p>\n<p>一个并发 G1 回收周期前后内存占用情况如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120816584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>从上面的图表可以看出以下几点：<br>1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用<br>2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域<br>3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收</p>\n<p>G1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：</p>\n<blockquote>\n<p>50.541: [GC pause (young) (initial-mark), 0.27767100 secs][eden: 1220m(1220m)-&gt;0b(1220m) survivors: 144m-&gt;144m heap: 3242m(4096m)-&gt;2093m(4096m)] [Times: user=1.02 sys=0.04, real=0.28</p>\n<blockquote>\n<p>secs]</p>\n</blockquote>\n</blockquote>\n<p>上面的日志表明发生了 YGC、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。<br>日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，<br>G1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20%的 CPU，暂停时间相应的略微变长了些。</p>\n<p>接下来，G1 开始扫描根区域、日志示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">50.819: [GC concurrent-root-region-scan-start]</span><br><span class=\"line\">51.408: [GC concurrent-root-region-scan-end, 0.5890230]</span><br></pre></td></tr></table></figure>\n\n<p>一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候<br>满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 350.994: [GC pause (young)</span><br><span class=\"line\">&gt; 351.093: [GC concurrent-root-region-scan-end, 0.6100090]</span><br><span class=\"line\">&gt; 351.093: [GC concurrent-mark-start],0.37559600 secs]</span><br></pre></td></tr></table></figure>\n\n<p>GC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是 100 毫秒。<br>在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">111.382: [GC concurrent-mark-start] ....</span><br><span class=\"line\">120.905: [GC concurrent-mark-end, 9.5225160 sec]</span><br></pre></td></tr></table></figure>\n\n<p>并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 120.910: [GC remark 120.959: [GC ref-PRC, 0.0000890 secs], 0.0718990 secs][times: user=0.23 sys=0.01, real=0.08 secs]</span><br><span class=\"line\">&gt; 120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs][times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n\n<p>这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">120.996: [GC concurrent-cleanup-start]</span><br><span class=\"line\">120.996: [GC concurrent-cleanup-end, 0.0004520]</span><br></pre></td></tr></table></figure>\n<p>到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X），实际空间释放较少。</p>\n<p>混合 GC：</p>\n<p>接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20170729120910552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：</p>\n<blockquote>\n<p>79.826: [GC pause (mixed), 0.26161600 secs] …. [Eden: 1222M(1222M)-&gt;0B(1220M) Survivors: 142M-&gt;144M Heap:<br>3200M(4096M)-&gt;1964M(4096M)][times: user=1.01 sys=0.00, real=0.26 secs]<br>上面的日志可以注意到 Eden 释放了 1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当 O 区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.<br>后续分开介绍：。。</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>深入理解 java 虚拟机<br><a href=\"http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/\">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a></p>\n"},{"title":"JVM软引用和弱引用","_content":"\n#### 一个场景\n```java\n如果有一个值，对应的键已经不再使用了, 将会出现什么情况呢？假定对某个键的最后一次引用已经消亡, \n不再有任何途径引用这个值的对象了, 但是, 由于在程序中的任何部分没有再出现这个键, \n所以, 这个 键/值 对无法从映射中删除.\n\n垃圾收集器怎么处理这样的场景呢? 引用出现了!\n```\n\n\n#### JAVA 中的引用\n**强引用 StrongReference**: 普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略\n\n\n**软引用 SoftReference**: 一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存, 维护一种非强制性的映射关系\n\n\n**弱引用 WeakReference**: 并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系,如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。这个类对象的引用，一般主要是在 major collection 的时候回收，所以它可能在 minor collection 后仍然存在。\n\n\n**虚引用 PhantomReference: **The object is the referent of a PhantomReference, and it has already been selected for collection and its finalizer (if any) has run. The term “reachable” is really a misnomer in this case, as there's no way for you to access the actual object. 不可达, 不影响对象的生命周期, 通过虚引用的 get() 方法永远返回 null.\n\n\n正如您可能猜到的，向对象生命周期图添加三个新的可选状态会造成混乱。尽管文档指出了从强可达到软、弱和虚到回收的逻辑过程，但实际过程取决于程序创建的引用对象。如果创建 WeakReference 但不创建SoftReference，则对象将直接从强可达到弱可达，再从最终确定到收集。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/12487950/1619438588692-902fee26-a911-48f8-8556-09bbe528b41a.png#clientId=u1abc7148-9485-4&from=paste&height=206&id=u6a33dc73&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=656&originalType=binary&size=8628&status=done&style=none&taskId=u0e0ed8d5-e6b2-418d-a350-ed9052bcb93&width=656)\n#### References and Referents\nA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/12487950/1619605033615-5ec8b4a0-689c-4d6f-bdee-effa11da7b26.png#clientId=u406342b3-8a6c-4&from=paste&height=82&id=Qh0bD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=490&originalType=binary&size=3281&status=done&style=none&taskId=u2755513c-92e7-4ec9-9371-4629adea141&width=490)\n#### 引用意义\n垃圾回收时的垃圾判定方式: [垃圾回收](https://rongcloud.yuque.com/ofnwgp/xdbvrt/scix1x) \nJVM 在进行垃圾回收的时候，会判定对象是否还存在引用，它会针对不同的引用类型分别对待。\n弱引用可以用来访问对象，但进行垃圾回收时，如果对象仅有弱引用指向，则仍然会被 GC 回收。\n\n\n\n\n#### 小例子\n```java\n// 软引用和弱引用的一个例子\n\n// 强引用\nString str = new String(\"str-value\");\nSoftReference<String> softRef = new SoftReference<String>(str); // 软引用\nstr = null; \t// 去掉强引用\nSystem.gc(); \t// 垃圾回收器进行回收\nSystem.out.println(softRef.get());\n\n// 强引用\nString abc = new String(\"abc-value\");\nWeakReference<String> weakRef = new WeakReference<String>(abc); // 弱引用\nabc = null;\t\t// 去掉强引用\nSystem.gc(); \t// 垃圾回收器进行回收\nSystem.out.println(weakRef.get());\n\n\n输出:\nstr-value\nnull\n```\n\n\n```java\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ReferenceDemo {\n    public static void main(String[] args) {\n        String a = new String(\"key-a\");\n        String b = new String(\"key-b\");\n\n        Map map = new HashMap();\n        map.put(a, \"aaa\");\n        map.put(b, \"bbb\");\n\n        Map weakmap = new WeakHashMap();\n        weakmap.put(a, \"aaaa\");\n        weakmap.put(b, \"bbbb\");\n\n        map.remove(a);\n        \n        a = null; // 移除 a 的强引用, key-a 也没人引用了; map.size();\n        b = null; // 移除 b 的强引用, key-b 还被 map 引用着 map.get(b); map.get(\"key-b\");\n\n        System.gc();\n\n        Iterator i = map.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry en = (Map.Entry) i.next();\n            System.out.println(\"map:\" + en.getKey() + \":\" + en.getValue());\n        }\n\n        Iterator j = weakmap.entrySet().iterator();\n        while (j.hasNext()) {\n            Map.Entry en = (Map.Entry) j.next();\n            System.out.println(\"weakmap:\" + en.getKey() + \":\" + en.getValue());\n        }\n    }\n}\n\n输出\nmap:key-b:bbb\nweakmap:key-b:bbbb\n```\n\n\n#### 想说的话\n```java\n// 平时使用的缓存存在的问题\n1. 对象都是强引用的\n2. 不确定单个对象占用的 byte size 大小\n3. 无法准确的估算创建缓存的时候为其指定一个准确的大小\n4. JVM 即使报 OOM 也不会清理这些缓存, 失去缓存的意义 => LRU \n\n// 弱引用缓存 WeakHashMap\n1. key 是经过弱引用化处理的, value 不是\n2. 即使不被主动调用 remove, clear 方法，元素也是会有机会清除的\n3. key-value 的清理时机, key 伴随 gc 清理, value 根据 ReferenceQueue 进行清理\n4. ReferenceQueue\n5. 为什么会存在 ReferenceQueue ? \n    我们可以通过 reference.get() 的返回值确定 referent 是否被回收了, \n\t但是现实是我们有大量的引用对象，这么操作是不实际的，一个好的解决方案就出来了 - 引用队列，\n    在构造时将引用与队列相关联，并且在清除引用后将其放在队列上。要发现哪些引用已被清除,\n    可以轮询队列。这可以通过后台线程完成，但是在创建新引用时轮询队列通常更简单(WeakHashMap就是这么做的)\n\t引用队列更像是监听器.\n    \n// 弱引用的特点更适合高速缓存\n\n// 引用的状态\n1. Active: \n\t新创建的实例处于活动状态, 由垃圾收集者进行特殊处理,\n\t收集器检测到引用对象的可访问性已更改为适当的状态后的一段时间，它会将实例的状态更改为挂起或不活动，\n    这取决于创建实例时是否向队列注册了实例, 在前一种情况下，它还将实例添加到挂起引用列表中.\n2. Pending: \n\t挂起引用列表的元素，等待引用处理程序线程排队,未注册的实例从不处于此状态.\n3. Enqueued\n\t在创建实例时向其注册的队列元素. 当实例从其引用队列中移除时,它将变为非活动状态.\n    未注册的实例从不处于此状态\n4. Inactive\n\t一旦实例变为非活动状态,其状态将永远不会再改变.\n```\n\n\n#### 弱引用的应用\nWeakHashMap (源码分析)\n```java\n1. 根据 API 文档，当 Map 中的键不再使用，键对应的键值也将自动在 WeakHashMap 中删除。WeakHashMap 中的键为弱键，和其他 Map 接口的实现有些不同；\n2. 和 HashMap 类似; 但是支持 key 和 value 为 null, 不存在红黑树结构，因为没必要\n3. 同样不是线程安全的，可以使用 Collections.synchronizedMap(Map map) 来使之线程安全\n4. 没有实现 Cloneable, Serializable接口, 没有必要\n\npublic class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> {\n\t// 基本组成属性\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n    private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    private static final Object NULL_KEY = new Object();\n    Entry<K,V>[] table; // 这个 Entry 继承了 WeakReference\n    private int size;\n    private int threshold;\n    private final float loadFactor;\n    \n    /**\n  \t* Reference queue for cleared WeakEntries\n    *\n    * 队列放的是什么 ?\n \t*/\n    private final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n    \n    int modCount;\n}\n\n// 1. put 方法分析\npublic V put(K key, V value) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    \n    // 遍历 table[i] 链表, 如果找到相同的 key 则将老的 value 用新的 value 替换\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n    \n    modCount++;// 修改次数++\n    Entry<K,V> e = tab[i];// 取得链表的第一个元素\n    \n    // 构建新的链表（将新元素放在链表最前面）,同时将 key 注册到引用队列\n    tab[i] = new Entry<>(k, value, queue, h, e); \n    \n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n\nprivate static Object maskNull(Object key) {\n\treturn (key == null) ? NULL_KEY : key;\n}\n\nfinal int hash(Object k) {\n    int h = k.hashCode();\n    \n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n\nprivate Entry<K,V>[] getTable() {\n    expungeStaleEntries();\n    return table;\n}\n\n// 将引用队列里的元素拿出来，修正 table 中的无效数据\nprivate void expungeStaleEntries() {\n    for (Object x; (x = queue.poll()) != null; ) {\n        synchronized (queue) {\n            @SuppressWarnings(\"unchecked\")\n            Entry<K,V> e = (Entry<K,V>) x;// queue 放的是元素, 将要被清理的元素\n            \n            int i = indexFor(e.hash, table.length);// 定位在 table 数组的位置\n\n            Entry<K,V> prev = table[i];// 取得 table [i] 处链表的第一个元素\n            Entry<K,V> p = prev;\n            while (p != null) {// 链表是否为空或者是否是链表的最后一个元素\n                Entry<K,V> next = p.next;\n                if (p == e) { // 找到了要被清理的元素\n                    if (prev == e)// prev 不一定和 p 相同\n                        table[i] = next; // 用下一个元素对 e 元素替换\n                    else\n                        prev.next = next; // 修复链接\n                    // Must not null out e.next;\n                    // stale entries may be in use by a HashIterator\n                    e.value = null; // Help GC\n                    size--;\n                    break;\n                }\n                prev = p; // 没找到要被清理的元素,交换指针,移动位置,继续比对\n                p = next;\n            }\n        }\n    }\n}\n\nEntry(Object key, V value, ReferenceQueue<Object> queue, int hash, Entry<K,V> next) {\n\tsuper(key, queue);\n    this.value = value;\n    this.hash  = hash;\n    this.next  = next;\n}\n\n/**\n * Creates a new weak reference that refers to the given object and is\n * registered with the given queue.\n *\n * @param referent object the new weak reference will refer to\n * @param q the queue with which the reference is to be registered,\n *          or <tt>null</tt> if registration is not required\n *\n * 监听器效果, 如果引用的对象被回收(reference.get() == null)，则将其加入该队列\n */\npublic WeakReference(T referent, ReferenceQueue<? super T> q) {\n\tsuper(referent, q);\n}\n\nReference(T referent, ReferenceQueue<? super T> queue) {\n\tthis.referent = referent;\n    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n}\n```\n\n\n```java\n// 2. get 方法分析\npublic V get(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n\n// 3. remove 方法, 分析过 expungeStaleEntries 方法，该方法就没必要看了\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n\n// 通过分析可以看到 getTable() 经常被调用到，它和 ReferenceQueue 一起完成的对 k-v 的清理工作\n```\n","source":"_posts/language/jvm/JVM软引用和弱引用.md","raw":"---\ntitle: JVM软引用和弱引用\ncategories:\n- java\n---\n\n#### 一个场景\n```java\n如果有一个值，对应的键已经不再使用了, 将会出现什么情况呢？假定对某个键的最后一次引用已经消亡, \n不再有任何途径引用这个值的对象了, 但是, 由于在程序中的任何部分没有再出现这个键, \n所以, 这个 键/值 对无法从映射中删除.\n\n垃圾收集器怎么处理这样的场景呢? 引用出现了!\n```\n\n\n#### JAVA 中的引用\n**强引用 StrongReference**: 普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略\n\n\n**软引用 SoftReference**: 一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存, 维护一种非强制性的映射关系\n\n\n**弱引用 WeakReference**: 并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系,如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。这个类对象的引用，一般主要是在 major collection 的时候回收，所以它可能在 minor collection 后仍然存在。\n\n\n**虚引用 PhantomReference: **The object is the referent of a PhantomReference, and it has already been selected for collection and its finalizer (if any) has run. The term “reachable” is really a misnomer in this case, as there's no way for you to access the actual object. 不可达, 不影响对象的生命周期, 通过虚引用的 get() 方法永远返回 null.\n\n\n正如您可能猜到的，向对象生命周期图添加三个新的可选状态会造成混乱。尽管文档指出了从强可达到软、弱和虚到回收的逻辑过程，但实际过程取决于程序创建的引用对象。如果创建 WeakReference 但不创建SoftReference，则对象将直接从强可达到弱可达，再从最终确定到收集。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/12487950/1619438588692-902fee26-a911-48f8-8556-09bbe528b41a.png#clientId=u1abc7148-9485-4&from=paste&height=206&id=u6a33dc73&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=656&originalType=binary&size=8628&status=done&style=none&taskId=u0e0ed8d5-e6b2-418d-a350-ed9052bcb93&width=656)\n#### References and Referents\nA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/12487950/1619605033615-5ec8b4a0-689c-4d6f-bdee-effa11da7b26.png#clientId=u406342b3-8a6c-4&from=paste&height=82&id=Qh0bD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=490&originalType=binary&size=3281&status=done&style=none&taskId=u2755513c-92e7-4ec9-9371-4629adea141&width=490)\n#### 引用意义\n垃圾回收时的垃圾判定方式: [垃圾回收](https://rongcloud.yuque.com/ofnwgp/xdbvrt/scix1x) \nJVM 在进行垃圾回收的时候，会判定对象是否还存在引用，它会针对不同的引用类型分别对待。\n弱引用可以用来访问对象，但进行垃圾回收时，如果对象仅有弱引用指向，则仍然会被 GC 回收。\n\n\n\n\n#### 小例子\n```java\n// 软引用和弱引用的一个例子\n\n// 强引用\nString str = new String(\"str-value\");\nSoftReference<String> softRef = new SoftReference<String>(str); // 软引用\nstr = null; \t// 去掉强引用\nSystem.gc(); \t// 垃圾回收器进行回收\nSystem.out.println(softRef.get());\n\n// 强引用\nString abc = new String(\"abc-value\");\nWeakReference<String> weakRef = new WeakReference<String>(abc); // 弱引用\nabc = null;\t\t// 去掉强引用\nSystem.gc(); \t// 垃圾回收器进行回收\nSystem.out.println(weakRef.get());\n\n\n输出:\nstr-value\nnull\n```\n\n\n```java\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ReferenceDemo {\n    public static void main(String[] args) {\n        String a = new String(\"key-a\");\n        String b = new String(\"key-b\");\n\n        Map map = new HashMap();\n        map.put(a, \"aaa\");\n        map.put(b, \"bbb\");\n\n        Map weakmap = new WeakHashMap();\n        weakmap.put(a, \"aaaa\");\n        weakmap.put(b, \"bbbb\");\n\n        map.remove(a);\n        \n        a = null; // 移除 a 的强引用, key-a 也没人引用了; map.size();\n        b = null; // 移除 b 的强引用, key-b 还被 map 引用着 map.get(b); map.get(\"key-b\");\n\n        System.gc();\n\n        Iterator i = map.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry en = (Map.Entry) i.next();\n            System.out.println(\"map:\" + en.getKey() + \":\" + en.getValue());\n        }\n\n        Iterator j = weakmap.entrySet().iterator();\n        while (j.hasNext()) {\n            Map.Entry en = (Map.Entry) j.next();\n            System.out.println(\"weakmap:\" + en.getKey() + \":\" + en.getValue());\n        }\n    }\n}\n\n输出\nmap:key-b:bbb\nweakmap:key-b:bbbb\n```\n\n\n#### 想说的话\n```java\n// 平时使用的缓存存在的问题\n1. 对象都是强引用的\n2. 不确定单个对象占用的 byte size 大小\n3. 无法准确的估算创建缓存的时候为其指定一个准确的大小\n4. JVM 即使报 OOM 也不会清理这些缓存, 失去缓存的意义 => LRU \n\n// 弱引用缓存 WeakHashMap\n1. key 是经过弱引用化处理的, value 不是\n2. 即使不被主动调用 remove, clear 方法，元素也是会有机会清除的\n3. key-value 的清理时机, key 伴随 gc 清理, value 根据 ReferenceQueue 进行清理\n4. ReferenceQueue\n5. 为什么会存在 ReferenceQueue ? \n    我们可以通过 reference.get() 的返回值确定 referent 是否被回收了, \n\t但是现实是我们有大量的引用对象，这么操作是不实际的，一个好的解决方案就出来了 - 引用队列，\n    在构造时将引用与队列相关联，并且在清除引用后将其放在队列上。要发现哪些引用已被清除,\n    可以轮询队列。这可以通过后台线程完成，但是在创建新引用时轮询队列通常更简单(WeakHashMap就是这么做的)\n\t引用队列更像是监听器.\n    \n// 弱引用的特点更适合高速缓存\n\n// 引用的状态\n1. Active: \n\t新创建的实例处于活动状态, 由垃圾收集者进行特殊处理,\n\t收集器检测到引用对象的可访问性已更改为适当的状态后的一段时间，它会将实例的状态更改为挂起或不活动，\n    这取决于创建实例时是否向队列注册了实例, 在前一种情况下，它还将实例添加到挂起引用列表中.\n2. Pending: \n\t挂起引用列表的元素，等待引用处理程序线程排队,未注册的实例从不处于此状态.\n3. Enqueued\n\t在创建实例时向其注册的队列元素. 当实例从其引用队列中移除时,它将变为非活动状态.\n    未注册的实例从不处于此状态\n4. Inactive\n\t一旦实例变为非活动状态,其状态将永远不会再改变.\n```\n\n\n#### 弱引用的应用\nWeakHashMap (源码分析)\n```java\n1. 根据 API 文档，当 Map 中的键不再使用，键对应的键值也将自动在 WeakHashMap 中删除。WeakHashMap 中的键为弱键，和其他 Map 接口的实现有些不同；\n2. 和 HashMap 类似; 但是支持 key 和 value 为 null, 不存在红黑树结构，因为没必要\n3. 同样不是线程安全的，可以使用 Collections.synchronizedMap(Map map) 来使之线程安全\n4. 没有实现 Cloneable, Serializable接口, 没有必要\n\npublic class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> {\n\t// 基本组成属性\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n    private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    private static final Object NULL_KEY = new Object();\n    Entry<K,V>[] table; // 这个 Entry 继承了 WeakReference\n    private int size;\n    private int threshold;\n    private final float loadFactor;\n    \n    /**\n  \t* Reference queue for cleared WeakEntries\n    *\n    * 队列放的是什么 ?\n \t*/\n    private final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n    \n    int modCount;\n}\n\n// 1. put 方法分析\npublic V put(K key, V value) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    \n    // 遍历 table[i] 链表, 如果找到相同的 key 则将老的 value 用新的 value 替换\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n    \n    modCount++;// 修改次数++\n    Entry<K,V> e = tab[i];// 取得链表的第一个元素\n    \n    // 构建新的链表（将新元素放在链表最前面）,同时将 key 注册到引用队列\n    tab[i] = new Entry<>(k, value, queue, h, e); \n    \n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n\nprivate static Object maskNull(Object key) {\n\treturn (key == null) ? NULL_KEY : key;\n}\n\nfinal int hash(Object k) {\n    int h = k.hashCode();\n    \n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n\nprivate Entry<K,V>[] getTable() {\n    expungeStaleEntries();\n    return table;\n}\n\n// 将引用队列里的元素拿出来，修正 table 中的无效数据\nprivate void expungeStaleEntries() {\n    for (Object x; (x = queue.poll()) != null; ) {\n        synchronized (queue) {\n            @SuppressWarnings(\"unchecked\")\n            Entry<K,V> e = (Entry<K,V>) x;// queue 放的是元素, 将要被清理的元素\n            \n            int i = indexFor(e.hash, table.length);// 定位在 table 数组的位置\n\n            Entry<K,V> prev = table[i];// 取得 table [i] 处链表的第一个元素\n            Entry<K,V> p = prev;\n            while (p != null) {// 链表是否为空或者是否是链表的最后一个元素\n                Entry<K,V> next = p.next;\n                if (p == e) { // 找到了要被清理的元素\n                    if (prev == e)// prev 不一定和 p 相同\n                        table[i] = next; // 用下一个元素对 e 元素替换\n                    else\n                        prev.next = next; // 修复链接\n                    // Must not null out e.next;\n                    // stale entries may be in use by a HashIterator\n                    e.value = null; // Help GC\n                    size--;\n                    break;\n                }\n                prev = p; // 没找到要被清理的元素,交换指针,移动位置,继续比对\n                p = next;\n            }\n        }\n    }\n}\n\nEntry(Object key, V value, ReferenceQueue<Object> queue, int hash, Entry<K,V> next) {\n\tsuper(key, queue);\n    this.value = value;\n    this.hash  = hash;\n    this.next  = next;\n}\n\n/**\n * Creates a new weak reference that refers to the given object and is\n * registered with the given queue.\n *\n * @param referent object the new weak reference will refer to\n * @param q the queue with which the reference is to be registered,\n *          or <tt>null</tt> if registration is not required\n *\n * 监听器效果, 如果引用的对象被回收(reference.get() == null)，则将其加入该队列\n */\npublic WeakReference(T referent, ReferenceQueue<? super T> q) {\n\tsuper(referent, q);\n}\n\nReference(T referent, ReferenceQueue<? super T> queue) {\n\tthis.referent = referent;\n    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n}\n```\n\n\n```java\n// 2. get 方法分析\npublic V get(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n\n// 3. remove 方法, 分析过 expungeStaleEntries 方法，该方法就没必要看了\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n\n// 通过分析可以看到 getTable() 经常被调用到，它和 ReferenceQueue 一起完成的对 k-v 的清理工作\n```\n","slug":"language/jvm/JVM软引用和弱引用","published":1,"date":"2021-07-31T09:04:32.030Z","updated":"2021-07-31T09:04:32.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2bz000jy2uke08y8hg1","content":"<h4 id=\"一个场景\"><a href=\"#一个场景\" class=\"headerlink\" title=\"一个场景\"></a>一个场景</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果有一个值，对应的键已经不再使用了, 将会出现什么情况呢？假定对某个键的最后一次引用已经消亡, </span><br><span class=\"line\">不再有任何途径引用这个值的对象了, 但是, 由于在程序中的任何部分没有再出现这个键, </span><br><span class=\"line\">所以, 这个 键/值 对无法从映射中删除.</span><br><span class=\"line\"></span><br><span class=\"line\">垃圾收集器怎么处理这样的场景呢? 引用出现了!</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"JAVA-中的引用\"><a href=\"#JAVA-中的引用\" class=\"headerlink\" title=\"JAVA 中的引用\"></a>JAVA 中的引用</h4><p><strong>强引用 StrongReference</strong>: 普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略</p>\n<p><strong>软引用 SoftReference</strong>: 一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存, 维护一种非强制性的映射关系</p>\n<p><strong>弱引用 WeakReference</strong>: 并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系,如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。这个类对象的引用，一般主要是在 major collection 的时候回收，所以它可能在 minor collection 后仍然存在。</p>\n<p>**虚引用 PhantomReference: **The object is the referent of a PhantomReference, and it has already been selected for collection and its finalizer (if any) has run. The term “reachable” is really a misnomer in this case, as there’s no way for you to access the actual object. 不可达, 不影响对象的生命周期, 通过虚引用的 get() 方法永远返回 null.</p>\n<p>正如您可能猜到的，向对象生命周期图添加三个新的可选状态会造成混乱。尽管文档指出了从强可达到软、弱和虚到回收的逻辑过程，但实际过程取决于程序创建的引用对象。如果创建 WeakReference 但不创建SoftReference，则对象将直接从强可达到弱可达，再从最终确定到收集。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/12487950/1619438588692-902fee26-a911-48f8-8556-09bbe528b41a.png#clientId=u1abc7148-9485-4&from=paste&height=206&id=u6a33dc73&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=656&originalType=binary&size=8628&status=done&style=none&taskId=u0e0ed8d5-e6b2-418d-a350-ed9052bcb93&width=656\" alt=\"image.png\"></p>\n<h4 id=\"References-and-Referents\"><a href=\"#References-and-Referents\" class=\"headerlink\" title=\"References and Referents\"></a>References and Referents</h4><p>A reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/12487950/1619605033615-5ec8b4a0-689c-4d6f-bdee-effa11da7b26.png#clientId=u406342b3-8a6c-4&from=paste&height=82&id=Qh0bD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=490&originalType=binary&size=3281&status=done&style=none&taskId=u2755513c-92e7-4ec9-9371-4629adea141&width=490\" alt=\"image.png\"></p>\n<h4 id=\"引用意义\"><a href=\"#引用意义\" class=\"headerlink\" title=\"引用意义\"></a>引用意义</h4><p>垃圾回收时的垃圾判定方式: <a href=\"https://rongcloud.yuque.com/ofnwgp/xdbvrt/scix1x\">垃圾回收</a><br>JVM 在进行垃圾回收的时候，会判定对象是否还存在引用，它会针对不同的引用类型分别对待。<br>弱引用可以用来访问对象，但进行垃圾回收时，如果对象仅有弱引用指向，则仍然会被 GC 回收。</p>\n<h4 id=\"小例子\"><a href=\"#小例子\" class=\"headerlink\" title=\"小例子\"></a>小例子</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 软引用和弱引用的一个例子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;str-value&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str); <span class=\"comment\">// 软引用</span></span><br><span class=\"line\">str = <span class=\"keyword\">null</span>; \t<span class=\"comment\">// 去掉强引用</span></span><br><span class=\"line\">System.gc(); \t<span class=\"comment\">// 垃圾回收器进行回收</span></span><br><span class=\"line\">System.out.println(softRef.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\">String abc = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc-value&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(abc); <span class=\"comment\">// 弱引用</span></span><br><span class=\"line\">abc = <span class=\"keyword\">null</span>;\t\t<span class=\"comment\">// 去掉强引用</span></span><br><span class=\"line\">System.gc(); \t<span class=\"comment\">// 垃圾回收器进行回收</span></span><br><span class=\"line\">System.out.println(weakRef.get());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">str-value</span><br><span class=\"line\"><span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.WeakHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;key-a&quot;</span>);</span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;key-b&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        map.put(a, <span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        map.put(b, <span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map weakmap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\">        weakmap.put(a, <span class=\"string\">&quot;aaaa&quot;</span>);</span><br><span class=\"line\">        weakmap.put(b, <span class=\"string\">&quot;bbbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        map.remove(a);</span><br><span class=\"line\">        </span><br><span class=\"line\">        a = <span class=\"keyword\">null</span>; <span class=\"comment\">// 移除 a 的强引用, key-a 也没人引用了; map.size();</span></span><br><span class=\"line\">        b = <span class=\"keyword\">null</span>; <span class=\"comment\">// 移除 b 的强引用, key-b 还被 map 引用着 map.get(b); map.get(&quot;key-b&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator i = map.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry) i.next();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;map:&quot;</span> + en.getKey() + <span class=\"string\">&quot;:&quot;</span> + en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator j = weakmap.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry) j.next();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;weakmap:&quot;</span> + en.getKey() + <span class=\"string\">&quot;:&quot;</span> + en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出</span><br><span class=\"line\">map:key-b:bbb</span><br><span class=\"line\">weakmap:key-b:bbbb</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 平时使用的缓存存在的问题</span></span><br><span class=\"line\"><span class=\"number\">1.</span> 对象都是强引用的</span><br><span class=\"line\"><span class=\"number\">2.</span> 不确定单个对象占用的 <span class=\"keyword\">byte</span> size 大小</span><br><span class=\"line\"><span class=\"number\">3.</span> 无法准确的估算创建缓存的时候为其指定一个准确的大小</span><br><span class=\"line\"><span class=\"number\">4.</span> JVM 即使报 OOM 也不会清理这些缓存, 失去缓存的意义 =&gt; LRU </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弱引用缓存 WeakHashMap</span></span><br><span class=\"line\"><span class=\"number\">1.</span> key 是经过弱引用化处理的, value 不是</span><br><span class=\"line\"><span class=\"number\">2.</span> 即使不被主动调用 remove, clear 方法，元素也是会有机会清除的</span><br><span class=\"line\"><span class=\"number\">3.</span> key-value 的清理时机, key 伴随 gc 清理, value 根据 ReferenceQueue 进行清理</span><br><span class=\"line\"><span class=\"number\">4.</span> ReferenceQueue</span><br><span class=\"line\"><span class=\"number\">5.</span> 为什么会存在 ReferenceQueue ? </span><br><span class=\"line\">    我们可以通过 reference.get() 的返回值确定 referent 是否被回收了, </span><br><span class=\"line\">\t但是现实是我们有大量的引用对象，这么操作是不实际的，一个好的解决方案就出来了 - 引用队列，</span><br><span class=\"line\">    在构造时将引用与队列相关联，并且在清除引用后将其放在队列上。要发现哪些引用已被清除,</span><br><span class=\"line\">    可以轮询队列。这可以通过后台线程完成，但是在创建新引用时轮询队列通常更简单(WeakHashMap就是这么做的)</span><br><span class=\"line\">\t引用队列更像是监听器.</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 弱引用的特点更适合高速缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用的状态</span></span><br><span class=\"line\"><span class=\"number\">1.</span> Active: </span><br><span class=\"line\">\t新创建的实例处于活动状态, 由垃圾收集者进行特殊处理,</span><br><span class=\"line\">\t收集器检测到引用对象的可访问性已更改为适当的状态后的一段时间，它会将实例的状态更改为挂起或不活动，</span><br><span class=\"line\">    这取决于创建实例时是否向队列注册了实例, 在前一种情况下，它还将实例添加到挂起引用列表中.</span><br><span class=\"line\"><span class=\"number\">2.</span> Pending: </span><br><span class=\"line\">\t挂起引用列表的元素，等待引用处理程序线程排队,未注册的实例从不处于此状态.</span><br><span class=\"line\"><span class=\"number\">3.</span> Enqueued</span><br><span class=\"line\">\t在创建实例时向其注册的队列元素. 当实例从其引用队列中移除时,它将变为非活动状态.</span><br><span class=\"line\">    未注册的实例从不处于此状态</span><br><span class=\"line\"><span class=\"number\">4.</span> Inactive</span><br><span class=\"line\">\t一旦实例变为非活动状态,其状态将永远不会再改变.</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"弱引用的应用\"><a href=\"#弱引用的应用\" class=\"headerlink\" title=\"弱引用的应用\"></a>弱引用的应用</h4><p>WeakHashMap (源码分析)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 根据 API 文档，当 Map 中的键不再使用，键对应的键值也将自动在 WeakHashMap 中删除。WeakHashMap 中的键为弱键，和其他 Map 接口的实现有些不同；</span><br><span class=\"line\"><span class=\"number\">2.</span> 和 HashMap 类似; 但是支持 key 和 value 为 <span class=\"keyword\">null</span>, 不存在红黑树结构，因为没必要</span><br><span class=\"line\"><span class=\"number\">3.</span> 同样不是线程安全的，可以使用 Collections.synchronizedMap(Map map) 来使之线程安全</span><br><span class=\"line\"><span class=\"number\">4.</span> 没有实现 Cloneable, Serializable接口, 没有必要</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基本组成属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] table; <span class=\"comment\">// 这个 Entry 继承了 WeakReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  \t* Reference queue for cleared WeakEntries</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * 队列放的是什么 ?</span></span><br><span class=\"line\"><span class=\"comment\"> \t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. put 方法分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遍历 table[i] 链表, 如果找到相同的 key 则将老的 value 用新的 value 替换</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modCount++;<span class=\"comment\">// 修改次数++</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];<span class=\"comment\">// 取得链表的第一个元素</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构建新的链表（将新元素放在链表最前面）,同时将 key 注册到引用队列</span></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? NULL_KEY : key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = k.hashCode();</span><br><span class=\"line\">    </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将引用队列里的元素拿出来，修正 table 中的无效数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<span class=\"comment\">// queue 放的是元素, 将要被清理的元素</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, table.length);<span class=\"comment\">// 定位在 table 数组的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">// 取得 table [i] 处链表的第一个元素</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">// 链表是否为空或者是否是链表的最后一个元素</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123; <span class=\"comment\">// 找到了要被清理的元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)<span class=\"comment\">// prev 不一定和 p 相同</span></span><br><span class=\"line\">                        table[i] = next; <span class=\"comment\">// 用下一个元素对 e 元素替换</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next; <span class=\"comment\">// 修复链接</span></span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p; <span class=\"comment\">// 没找到要被清理的元素,交换指针,移动位置,继续比对</span></span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a new weak reference that refers to the given object and is</span></span><br><span class=\"line\"><span class=\"comment\"> * registered with the given queue.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> referent object the new weak reference will refer to</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class=\"line\"><span class=\"comment\"> *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 监听器效果, 如果引用的对象被回收(reference.get() == null)，则将其加入该队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Reference(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.referent = referent;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = (queue == <span class=\"keyword\">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2. get 方法分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. remove 方法, 分析过 expungeStaleEntries 方法，该方法就没必要看了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过分析可以看到 getTable() 经常被调用到，它和 ReferenceQueue 一起完成的对 k-v 的清理工作</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一个场景\"><a href=\"#一个场景\" class=\"headerlink\" title=\"一个场景\"></a>一个场景</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果有一个值，对应的键已经不再使用了, 将会出现什么情况呢？假定对某个键的最后一次引用已经消亡, </span><br><span class=\"line\">不再有任何途径引用这个值的对象了, 但是, 由于在程序中的任何部分没有再出现这个键, </span><br><span class=\"line\">所以, 这个 键/值 对无法从映射中删除.</span><br><span class=\"line\"></span><br><span class=\"line\">垃圾收集器怎么处理这样的场景呢? 引用出现了!</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"JAVA-中的引用\"><a href=\"#JAVA-中的引用\" class=\"headerlink\" title=\"JAVA 中的引用\"></a>JAVA 中的引用</h4><p><strong>强引用 StrongReference</strong>: 普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略</p>\n<p><strong>软引用 SoftReference</strong>: 一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存, 维护一种非强制性的映射关系</p>\n<p><strong>弱引用 WeakReference</strong>: 并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系,如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。这个类对象的引用，一般主要是在 major collection 的时候回收，所以它可能在 minor collection 后仍然存在。</p>\n<p>**虚引用 PhantomReference: **The object is the referent of a PhantomReference, and it has already been selected for collection and its finalizer (if any) has run. The term “reachable” is really a misnomer in this case, as there’s no way for you to access the actual object. 不可达, 不影响对象的生命周期, 通过虚引用的 get() 方法永远返回 null.</p>\n<p>正如您可能猜到的，向对象生命周期图添加三个新的可选状态会造成混乱。尽管文档指出了从强可达到软、弱和虚到回收的逻辑过程，但实际过程取决于程序创建的引用对象。如果创建 WeakReference 但不创建SoftReference，则对象将直接从强可达到弱可达，再从最终确定到收集。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/12487950/1619438588692-902fee26-a911-48f8-8556-09bbe528b41a.png#clientId=u1abc7148-9485-4&from=paste&height=206&id=u6a33dc73&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=656&originalType=binary&size=8628&status=done&style=none&taskId=u0e0ed8d5-e6b2-418d-a350-ed9052bcb93&width=656\" alt=\"image.png\"></p>\n<h4 id=\"References-and-Referents\"><a href=\"#References-and-Referents\" class=\"headerlink\" title=\"References and Referents\"></a>References and Referents</h4><p>A reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/12487950/1619605033615-5ec8b4a0-689c-4d6f-bdee-effa11da7b26.png#clientId=u406342b3-8a6c-4&from=paste&height=82&id=Qh0bD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=490&originalType=binary&size=3281&status=done&style=none&taskId=u2755513c-92e7-4ec9-9371-4629adea141&width=490\" alt=\"image.png\"></p>\n<h4 id=\"引用意义\"><a href=\"#引用意义\" class=\"headerlink\" title=\"引用意义\"></a>引用意义</h4><p>垃圾回收时的垃圾判定方式: <a href=\"https://rongcloud.yuque.com/ofnwgp/xdbvrt/scix1x\">垃圾回收</a><br>JVM 在进行垃圾回收的时候，会判定对象是否还存在引用，它会针对不同的引用类型分别对待。<br>弱引用可以用来访问对象，但进行垃圾回收时，如果对象仅有弱引用指向，则仍然会被 GC 回收。</p>\n<h4 id=\"小例子\"><a href=\"#小例子\" class=\"headerlink\" title=\"小例子\"></a>小例子</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 软引用和弱引用的一个例子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;str-value&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str); <span class=\"comment\">// 软引用</span></span><br><span class=\"line\">str = <span class=\"keyword\">null</span>; \t<span class=\"comment\">// 去掉强引用</span></span><br><span class=\"line\">System.gc(); \t<span class=\"comment\">// 垃圾回收器进行回收</span></span><br><span class=\"line\">System.out.println(softRef.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\">String abc = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc-value&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(abc); <span class=\"comment\">// 弱引用</span></span><br><span class=\"line\">abc = <span class=\"keyword\">null</span>;\t\t<span class=\"comment\">// 去掉强引用</span></span><br><span class=\"line\">System.gc(); \t<span class=\"comment\">// 垃圾回收器进行回收</span></span><br><span class=\"line\">System.out.println(weakRef.get());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">str-value</span><br><span class=\"line\"><span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.WeakHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;key-a&quot;</span>);</span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;key-b&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        map.put(a, <span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        map.put(b, <span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map weakmap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\">        weakmap.put(a, <span class=\"string\">&quot;aaaa&quot;</span>);</span><br><span class=\"line\">        weakmap.put(b, <span class=\"string\">&quot;bbbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        map.remove(a);</span><br><span class=\"line\">        </span><br><span class=\"line\">        a = <span class=\"keyword\">null</span>; <span class=\"comment\">// 移除 a 的强引用, key-a 也没人引用了; map.size();</span></span><br><span class=\"line\">        b = <span class=\"keyword\">null</span>; <span class=\"comment\">// 移除 b 的强引用, key-b 还被 map 引用着 map.get(b); map.get(&quot;key-b&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator i = map.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry) i.next();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;map:&quot;</span> + en.getKey() + <span class=\"string\">&quot;:&quot;</span> + en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator j = weakmap.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry) j.next();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;weakmap:&quot;</span> + en.getKey() + <span class=\"string\">&quot;:&quot;</span> + en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出</span><br><span class=\"line\">map:key-b:bbb</span><br><span class=\"line\">weakmap:key-b:bbbb</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 平时使用的缓存存在的问题</span></span><br><span class=\"line\"><span class=\"number\">1.</span> 对象都是强引用的</span><br><span class=\"line\"><span class=\"number\">2.</span> 不确定单个对象占用的 <span class=\"keyword\">byte</span> size 大小</span><br><span class=\"line\"><span class=\"number\">3.</span> 无法准确的估算创建缓存的时候为其指定一个准确的大小</span><br><span class=\"line\"><span class=\"number\">4.</span> JVM 即使报 OOM 也不会清理这些缓存, 失去缓存的意义 =&gt; LRU </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弱引用缓存 WeakHashMap</span></span><br><span class=\"line\"><span class=\"number\">1.</span> key 是经过弱引用化处理的, value 不是</span><br><span class=\"line\"><span class=\"number\">2.</span> 即使不被主动调用 remove, clear 方法，元素也是会有机会清除的</span><br><span class=\"line\"><span class=\"number\">3.</span> key-value 的清理时机, key 伴随 gc 清理, value 根据 ReferenceQueue 进行清理</span><br><span class=\"line\"><span class=\"number\">4.</span> ReferenceQueue</span><br><span class=\"line\"><span class=\"number\">5.</span> 为什么会存在 ReferenceQueue ? </span><br><span class=\"line\">    我们可以通过 reference.get() 的返回值确定 referent 是否被回收了, </span><br><span class=\"line\">\t但是现实是我们有大量的引用对象，这么操作是不实际的，一个好的解决方案就出来了 - 引用队列，</span><br><span class=\"line\">    在构造时将引用与队列相关联，并且在清除引用后将其放在队列上。要发现哪些引用已被清除,</span><br><span class=\"line\">    可以轮询队列。这可以通过后台线程完成，但是在创建新引用时轮询队列通常更简单(WeakHashMap就是这么做的)</span><br><span class=\"line\">\t引用队列更像是监听器.</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 弱引用的特点更适合高速缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用的状态</span></span><br><span class=\"line\"><span class=\"number\">1.</span> Active: </span><br><span class=\"line\">\t新创建的实例处于活动状态, 由垃圾收集者进行特殊处理,</span><br><span class=\"line\">\t收集器检测到引用对象的可访问性已更改为适当的状态后的一段时间，它会将实例的状态更改为挂起或不活动，</span><br><span class=\"line\">    这取决于创建实例时是否向队列注册了实例, 在前一种情况下，它还将实例添加到挂起引用列表中.</span><br><span class=\"line\"><span class=\"number\">2.</span> Pending: </span><br><span class=\"line\">\t挂起引用列表的元素，等待引用处理程序线程排队,未注册的实例从不处于此状态.</span><br><span class=\"line\"><span class=\"number\">3.</span> Enqueued</span><br><span class=\"line\">\t在创建实例时向其注册的队列元素. 当实例从其引用队列中移除时,它将变为非活动状态.</span><br><span class=\"line\">    未注册的实例从不处于此状态</span><br><span class=\"line\"><span class=\"number\">4.</span> Inactive</span><br><span class=\"line\">\t一旦实例变为非活动状态,其状态将永远不会再改变.</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"弱引用的应用\"><a href=\"#弱引用的应用\" class=\"headerlink\" title=\"弱引用的应用\"></a>弱引用的应用</h4><p>WeakHashMap (源码分析)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 根据 API 文档，当 Map 中的键不再使用，键对应的键值也将自动在 WeakHashMap 中删除。WeakHashMap 中的键为弱键，和其他 Map 接口的实现有些不同；</span><br><span class=\"line\"><span class=\"number\">2.</span> 和 HashMap 类似; 但是支持 key 和 value 为 <span class=\"keyword\">null</span>, 不存在红黑树结构，因为没必要</span><br><span class=\"line\"><span class=\"number\">3.</span> 同样不是线程安全的，可以使用 Collections.synchronizedMap(Map map) 来使之线程安全</span><br><span class=\"line\"><span class=\"number\">4.</span> 没有实现 Cloneable, Serializable接口, 没有必要</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基本组成属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] table; <span class=\"comment\">// 这个 Entry 继承了 WeakReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  \t* Reference queue for cleared WeakEntries</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * 队列放的是什么 ?</span></span><br><span class=\"line\"><span class=\"comment\"> \t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. put 方法分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遍历 table[i] 链表, 如果找到相同的 key 则将老的 value 用新的 value 替换</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modCount++;<span class=\"comment\">// 修改次数++</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];<span class=\"comment\">// 取得链表的第一个元素</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构建新的链表（将新元素放在链表最前面）,同时将 key 注册到引用队列</span></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? NULL_KEY : key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = k.hashCode();</span><br><span class=\"line\">    </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将引用队列里的元素拿出来，修正 table 中的无效数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<span class=\"comment\">// queue 放的是元素, 将要被清理的元素</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, table.length);<span class=\"comment\">// 定位在 table 数组的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">// 取得 table [i] 处链表的第一个元素</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">// 链表是否为空或者是否是链表的最后一个元素</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123; <span class=\"comment\">// 找到了要被清理的元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)<span class=\"comment\">// prev 不一定和 p 相同</span></span><br><span class=\"line\">                        table[i] = next; <span class=\"comment\">// 用下一个元素对 e 元素替换</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next; <span class=\"comment\">// 修复链接</span></span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p; <span class=\"comment\">// 没找到要被清理的元素,交换指针,移动位置,继续比对</span></span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a new weak reference that refers to the given object and is</span></span><br><span class=\"line\"><span class=\"comment\"> * registered with the given queue.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> referent object the new weak reference will refer to</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class=\"line\"><span class=\"comment\"> *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 监听器效果, 如果引用的对象被回收(reference.get() == null)，则将其加入该队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Reference(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.referent = referent;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = (queue == <span class=\"keyword\">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2. get 方法分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. remove 方法, 分析过 expungeStaleEntries 方法，该方法就没必要看了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过分析可以看到 getTable() 经常被调用到，它和 ReferenceQueue 一起完成的对 k-v 的清理工作</span></span><br></pre></td></tr></table></figure>\n"},{"title":"JVM类加载机制","_content":"\n# 类加载机制\n\n### 1. 类的加载过程\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7 个阶段。其中准备、验证、解析 3 个部分统称为连接（Linking）。如图所示:\n\n```\ngraph LR\n加载-->验证\n验证-->准备\n准备-->解析\n解析-->初始化\n初始化-->使用\n使用-->卸载\n```\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已 HotSpot 为基准。\n\n#### 1.1 加载\n\n虚拟机在加载阶段需要完成三件事:\n\n1. 通过一个类的全限定名来获取定义此类的二进制字节流，如 Class 文件,网络,动态生成,数据库等\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\n   加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。\n\n#### 1.2 验证\n\n验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，验证阶段大致会完成 4 个阶段的检验动作：\n\n1. 文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。\n2. 元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n4. 符号引用验证：确保解析动作能正确执行。\n   验证阶段可能抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、 java. lang. NoSuchFieldError、\n   验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n\n#### 1.3 准备\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值.\n\n如下定义:public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123.因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。\n\n如下定义：public static final int value=123; 即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，所以标注为 final 之后，value 的值在准备阶段初始化为 123 而非 0.\n\n#### 1.4 解析\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析针对如下 7 类符号引用进行：\n\n> 类或接口\n> 字段\n> 类方法\n> 接口方法\n> 方法类型\n> 方法句柄\n> 调用点限定符\n\n#### 1.5 初始化\n\n类初始化阶段是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。\n\n在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。我们放到后面再讲<clinit>()方法是怎么生成的，在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节，这部分相对更贴近于普通的程序开发人员[7]：\n·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。\n·<clinit>()方法与类的构造函数（或者说实例构造器<clinit>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是 java.lang.Object。\n·由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码执行字段 B 的值将会是 2 而不是 1。\n<clinit>()方法执行顺序：\n\n```java\npackage sf.jvm.load;\n class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n     public int getA(){\n         return A;\n     }\n}\nclass Sub extends Parent {\n     public static int B = A;\n     public int getB(){\n         return B;\n     }\n     public static void main(String[] args) {\n         new Parent();\n        System.out.println(Sub.B);\n        System.out.println(new Sub().getB());\n    }\n}\n/**\n Compiled from \"Parent.java\"\n class sf.jvm.load.Parent {\n public static int A;\n sf.jvm.load.Parent();\n Code:\n 0: aload_0\n 1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n 4: return\n public int getA();\n Code:\n 0: getstatic     #2                  // Field A:I\n 3: ireturn\n static {};\n Code:\n 0: iconst_1\n 1: putstatic     #2                  // Field A:I\n 4: iconst_2\n 5: putstatic     #2                  // Field A:I\n 8: return\n }\n */\n```\n\n·<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。\n·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。\n·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。\n\n```java\npackage sf.jvm.load;\nclass DeadLoopClass {\n    static {\n        //如果不加上这个if语句，编译器将提示\"Initializerdoesnotcompletenormally\"并拒绝编译\n        if (true) {\n            System.out.println(Thread.currentThread() + \"initDeadLoopClass\");\n            while (true) {\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Runnable script = new Runnable() {\n            public void run() {\n                System.out.println(Thread.currentThread() + \"start\");\n                DeadLoopClass dlc = new DeadLoopClass();\n                System.out.println(Thread.currentThread() + \"runover\");\n            }\n        };\n        Thread thread1 = new Thread(script);\n        Thread thread2 = new Thread(script);\n        thread1.start();\n        thread2.start();\n    }\n}\n/**\n *\n \"C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javap.exe\" -c sf.jvm.load.DeadLoopClass\n Compiled from \"DeadLoopClass.java\"\n class sf.jvm.load.DeadLoopClass {\n sf.jvm.load.DeadLoopClass();\n Code:\n 0: aload_0\n 1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n 4: return\n public static void main(java.lang.String[]);\n Code:\n 0: new           #2                  // class sf/jvm/load/DeadLoopClass$1\n 3: dup\n 4: invokespecial #3                  // Method sf/jvm/load/DeadLoopClass$1.\"<init>\":()V\n 7: astore_1\n 8: new           #4                  // class java/lang/Thread\n 11: dup\n 12: aload_1\n 13: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n 16: astore_2\n 17: new           #4                  // class java/lang/Thread\n 20: dup\n 21: aload_1\n 22: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n 25: astore_3\n 26: aload_2\n 27: invokevirtual #6                  // Method java/lang/Thread.start:()V\n 30: aload_3\n 31: invokevirtual #6                  // Method java/lang/Thread.start:()V\n 34: return\n static {};\n Code:\n 0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n 3: new           #8                  // class java/lang/StringBuilder\n 6: dup\n 7: invokespecial #9                  // Method java/lang/StringBuilder.\"<init>\":()V\n 10: invokestatic  #10                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;\n 13: invokevirtual #11                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;\n 16: ldc           #12                 // String initDeadLoopClass\n 18: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n 21: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n 24: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n 27: goto          27\n }\n * */\n```\n\n运行结果如下:\n\n```java\nThread[main,5,main]initDeadLoopClass\n通过分析：一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待.\n线程堆栈如下:\n2017-07-29 20:05:00\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):\n\n\"Monitor Ctrl-Break\" #10 daemon prio=5 os_prio=0 tid=0x0000000018554800 nid=0x4920 runnable [0x00000000190de000]\n   java.lang.Thread.State: RUNNABLE\n        at java.net.DualStackPlainSocketImpl.accept0(Native Method)\n        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)\n        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)\n        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)\n        - locked <0x00000000d79d67c0> (a java.net.SocksSocketImpl)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:545)\n        at java.net.ServerSocket.accept(ServerSocket.java:513)\n        at com.intellij.rt.execution.application.AppMain$1.run(AppMain.java:79)\n        at java.lang.Thread.run(Thread.java:745)\n\n\"Finalizer\" #3 daemon prio=8 os_prio=1 tid=0x00000000027d8800 nid=0x2d14 in Object.wait() [0x000000001837e000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000d7808ee0> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)\n        - locked <0x00000000d7808ee0> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)\n\n\"Reference Handler\" #2 daemon prio=10 os_prio=2 tid=0x00000000027d3000 nid=0x4914 in Object.wait() [0x000000001827f000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000d7806b50> (a java.lang.ref.Reference$Lock)\n        at java.lang.Object.wait(Object.java:502)\n        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n        - locked <0x00000000d7806b50> (a java.lang.ref.Reference$Lock)\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\"main\" #1 prio=5 os_prio=0 tid=0x000000000220e000 nid=0x450c runnable [0x00000000026de000]\n   java.lang.Thread.State: RUNNABLE\n        at sf.jvm.load.DeadLoopClass.<clinit>(DeadLoopClass.java:8)\n        at java.lang.Class.forName0(Native Method)\n        at java.lang.Class.forName(Class.java:264)\n        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:123)\n\"VM Thread\" os_prio=2 tid=0x0000000016ff7000 nid=0x6d4 runnable\n\"GC task thread#0 (ParallelGC)\" os_prio=0 tid=0x00000000026f7800 nid=0x4890 runnable\n\"GC task thread#1 (ParallelGC)\" os_prio=0 tid=0x00000000026f9000 nid=0x4514 runnable\n\"VM Periodic Task Thread\" os_prio=2 tid=0x00000000184e1800 nid=0x4934 waiting on condition\nJNI global references: 15\n```\n\n### 2 类加载器\n\n#### 2.1 　类加载器概述\n\n虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。\n类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 JavaApplet 的需求而被开发出来的。如今 JavaApplet 技术基本上已经死掉[1]，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石。\n类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。\n\n#### 2.2 类加载器的结构\n\n```\ngraph BT\n启动类加载器-->扩展类加载器\n扩展类加载器-->应用类加载器\n应用类加载器-->自定义加载器1\n应用类加载器-->自定义加载器2\n```\n\nJava 虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现[2]，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下三种系统提供的类加载器：：\n引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。\n扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。\n应用程序类加载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。\n除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。\n\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。\n\n破坏双亲委派模型\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK1.2 发布之前。由于双亲委派模型在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，\n双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK1.3 时代放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或 U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。在 JSR-297[4]、JSR-277[5]规范从纸上标准变成真正可运行的程序之前，OSGi 是当前业界“事实上”的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。\n在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：\n\n> （1）将以 java.\\*开头的类，委派给父类加载器加载。\n> （2）否则，将委派列表名单内的类，委派给父类加载器加载。\n> （3）否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。\n> （4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。\n> （5）否则，查找类是否在自己的 FragmentBundle 中，如果在，则委派给 FragmentBundle 的类加载器加载。\n> （6）否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。\n> （7）否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。\n\n虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，自然就明白了类加载器的精粹。\n//TODO\nOSGI\n\n#### 2.3 自定义类加载器实例:\n\n##### 2.3.1 文件加载:\n\n```java\npackage sf.jvm.load.classloader;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\n\npublic class FileSystemClassLoader extends ClassLoader {\n\n  private String rootDir;\n\n  public FileSystemClassLoader(String rootDir) {\n      this.rootDir = rootDir;\n  }\n\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n      byte[] classData = getClassData(name);\n      if (classData == null) {\n          throw new ClassNotFoundException();\n      } else {\n          return defineClass(name, classData, 0, classData.length);\n      }\n  }\n\n  private byte[] getClassData(String className) {\n      String path = classNameToPath(className);\n      try {\n          InputStream ins = new FileInputStream(path);\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          int bufferSize = 4096;\n          byte[] buffer = new byte[bufferSize];\n          int bytesNumRead = 0;\n          while ((bytesNumRead = ins.read(buffer)) != -1) {\n              baos.write(buffer, 0, bytesNumRead);\n          }\n          return baos.toByteArray();\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n      return null;\n  }\n\n  private String classNameToPath(String className) {\n      return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\";\n  }\n\n  public static void main(String[] args) {\n      String classDataRootPath = \"D:\\\\Code\\\\Jcode\\\\notes\\\\java-jlp\\\\java-jvm\\\\target\\\\classes\";\n      FileSystemClassLoader fileSystemClassLoader1 = new FileSystemClassLoader(classDataRootPath);\n      FileSystemClassLoader fileSystemClassLoader2 = new FileSystemClassLoader(classDataRootPath);\n      String className = \"sf.jvm.load.simple.Sample\";\n      try {\n          Class<?> class1 = fileSystemClassLoader1.loadClass(className);\n          Object obj1 = class1.newInstance();\n          Class<?> class2 = fileSystemClassLoader1.loadClass(className);\n          Object obj2 = class2.newInstance();\n          Method setSampleMethod = class1.getMethod(\"setSample\", Object.class);\n          setSampleMethod.invoke(obj1, obj2);\n          Method setSampleMethod2 = class1.getMethod(\"compare\", Object.class);\n          setSampleMethod2.invoke(obj1, obj2);\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n}\n```\n\n##### 2.3.2 网络加载:\n\n```java\npackage sf.jvm.load.classloader;\n\nimport sf.jvm.load.api.ICalculator;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.net.URL;\n\npublic class NetworkClassLoader extends ClassLoader {\n\n  private String rootUrl;\n\n  public NetworkClassLoader(String rootUrl) {\n      this.rootUrl = rootUrl;\n  }\n\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n      byte[] classData = getClassData(name);\n      if (classData == null) {\n          throw new ClassNotFoundException();\n      } else {\n          return defineClass(name, classData, 0, classData.length);\n      }\n  }\n\n  private byte[] getClassData(String className) {\n      String path = classNameToPath(className);\n      try {\n          URL url = new URL(path);\n          InputStream ins = url.openStream();\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          int bufferSize = 4096;\n          byte[] buffer = new byte[bufferSize];\n          int bytesNumRead = 0;\n          while ((bytesNumRead = ins.read(buffer)) != -1) {\n              baos.write(buffer, 0, bytesNumRead);\n          }\n          return baos.toByteArray();\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n      return null;\n  }\n\n  private String classNameToPath(String className) {\n      return rootUrl + \"/\" + className.replace('.', '/') + \".class\";\n  }\n\n  public static void main(String[] args) {\n      String url = \"http://localhost:8080/ClassloaderTest/classes\";\n      NetworkClassLoader ncl = new NetworkClassLoader(url);\n      String basicClassName = \"sf.jvm.load.simple.CalculatorBasic\";\n      String advancedClassName = \"sf.jvm.load.simple.CalculatorAdvanced\";\n      try {\n          Class<?> clazz = ncl.loadClass(basicClassName);\n          ICalculator calculator = (ICalculator) clazz.newInstance();\n          System.out.println(calculator.getVersion());\n          clazz = ncl.loadClass(advancedClassName);\n          calculator = (ICalculator) clazz.newInstance();\n          System.out.println(calculator.getVersion());\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n}\n```\n","source":"_posts/language/jvm/JVM类加载机制.md","raw":"---\ntitle: JVM类加载机制\ncategories:\n- java\n---\n\n# 类加载机制\n\n### 1. 类的加载过程\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7 个阶段。其中准备、验证、解析 3 个部分统称为连接（Linking）。如图所示:\n\n```\ngraph LR\n加载-->验证\n验证-->准备\n准备-->解析\n解析-->初始化\n初始化-->使用\n使用-->卸载\n```\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已 HotSpot 为基准。\n\n#### 1.1 加载\n\n虚拟机在加载阶段需要完成三件事:\n\n1. 通过一个类的全限定名来获取定义此类的二进制字节流，如 Class 文件,网络,动态生成,数据库等\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\n   加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。\n\n#### 1.2 验证\n\n验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，验证阶段大致会完成 4 个阶段的检验动作：\n\n1. 文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。\n2. 元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n4. 符号引用验证：确保解析动作能正确执行。\n   验证阶段可能抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、 java. lang. NoSuchFieldError、\n   验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n\n#### 1.3 准备\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值.\n\n如下定义:public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123.因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。\n\n如下定义：public static final int value=123; 即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，所以标注为 final 之后，value 的值在准备阶段初始化为 123 而非 0.\n\n#### 1.4 解析\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析针对如下 7 类符号引用进行：\n\n> 类或接口\n> 字段\n> 类方法\n> 接口方法\n> 方法类型\n> 方法句柄\n> 调用点限定符\n\n#### 1.5 初始化\n\n类初始化阶段是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。\n\n在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。我们放到后面再讲<clinit>()方法是怎么生成的，在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节，这部分相对更贴近于普通的程序开发人员[7]：\n·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。\n·<clinit>()方法与类的构造函数（或者说实例构造器<clinit>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是 java.lang.Object。\n·由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码执行字段 B 的值将会是 2 而不是 1。\n<clinit>()方法执行顺序：\n\n```java\npackage sf.jvm.load;\n class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n     public int getA(){\n         return A;\n     }\n}\nclass Sub extends Parent {\n     public static int B = A;\n     public int getB(){\n         return B;\n     }\n     public static void main(String[] args) {\n         new Parent();\n        System.out.println(Sub.B);\n        System.out.println(new Sub().getB());\n    }\n}\n/**\n Compiled from \"Parent.java\"\n class sf.jvm.load.Parent {\n public static int A;\n sf.jvm.load.Parent();\n Code:\n 0: aload_0\n 1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n 4: return\n public int getA();\n Code:\n 0: getstatic     #2                  // Field A:I\n 3: ireturn\n static {};\n Code:\n 0: iconst_1\n 1: putstatic     #2                  // Field A:I\n 4: iconst_2\n 5: putstatic     #2                  // Field A:I\n 8: return\n }\n */\n```\n\n·<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。\n·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。\n·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。\n\n```java\npackage sf.jvm.load;\nclass DeadLoopClass {\n    static {\n        //如果不加上这个if语句，编译器将提示\"Initializerdoesnotcompletenormally\"并拒绝编译\n        if (true) {\n            System.out.println(Thread.currentThread() + \"initDeadLoopClass\");\n            while (true) {\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Runnable script = new Runnable() {\n            public void run() {\n                System.out.println(Thread.currentThread() + \"start\");\n                DeadLoopClass dlc = new DeadLoopClass();\n                System.out.println(Thread.currentThread() + \"runover\");\n            }\n        };\n        Thread thread1 = new Thread(script);\n        Thread thread2 = new Thread(script);\n        thread1.start();\n        thread2.start();\n    }\n}\n/**\n *\n \"C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javap.exe\" -c sf.jvm.load.DeadLoopClass\n Compiled from \"DeadLoopClass.java\"\n class sf.jvm.load.DeadLoopClass {\n sf.jvm.load.DeadLoopClass();\n Code:\n 0: aload_0\n 1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n 4: return\n public static void main(java.lang.String[]);\n Code:\n 0: new           #2                  // class sf/jvm/load/DeadLoopClass$1\n 3: dup\n 4: invokespecial #3                  // Method sf/jvm/load/DeadLoopClass$1.\"<init>\":()V\n 7: astore_1\n 8: new           #4                  // class java/lang/Thread\n 11: dup\n 12: aload_1\n 13: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n 16: astore_2\n 17: new           #4                  // class java/lang/Thread\n 20: dup\n 21: aload_1\n 22: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n 25: astore_3\n 26: aload_2\n 27: invokevirtual #6                  // Method java/lang/Thread.start:()V\n 30: aload_3\n 31: invokevirtual #6                  // Method java/lang/Thread.start:()V\n 34: return\n static {};\n Code:\n 0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n 3: new           #8                  // class java/lang/StringBuilder\n 6: dup\n 7: invokespecial #9                  // Method java/lang/StringBuilder.\"<init>\":()V\n 10: invokestatic  #10                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;\n 13: invokevirtual #11                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;\n 16: ldc           #12                 // String initDeadLoopClass\n 18: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n 21: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n 24: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n 27: goto          27\n }\n * */\n```\n\n运行结果如下:\n\n```java\nThread[main,5,main]initDeadLoopClass\n通过分析：一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待.\n线程堆栈如下:\n2017-07-29 20:05:00\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):\n\n\"Monitor Ctrl-Break\" #10 daemon prio=5 os_prio=0 tid=0x0000000018554800 nid=0x4920 runnable [0x00000000190de000]\n   java.lang.Thread.State: RUNNABLE\n        at java.net.DualStackPlainSocketImpl.accept0(Native Method)\n        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)\n        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)\n        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)\n        - locked <0x00000000d79d67c0> (a java.net.SocksSocketImpl)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:545)\n        at java.net.ServerSocket.accept(ServerSocket.java:513)\n        at com.intellij.rt.execution.application.AppMain$1.run(AppMain.java:79)\n        at java.lang.Thread.run(Thread.java:745)\n\n\"Finalizer\" #3 daemon prio=8 os_prio=1 tid=0x00000000027d8800 nid=0x2d14 in Object.wait() [0x000000001837e000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000d7808ee0> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)\n        - locked <0x00000000d7808ee0> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)\n\n\"Reference Handler\" #2 daemon prio=10 os_prio=2 tid=0x00000000027d3000 nid=0x4914 in Object.wait() [0x000000001827f000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000d7806b50> (a java.lang.ref.Reference$Lock)\n        at java.lang.Object.wait(Object.java:502)\n        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n        - locked <0x00000000d7806b50> (a java.lang.ref.Reference$Lock)\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\"main\" #1 prio=5 os_prio=0 tid=0x000000000220e000 nid=0x450c runnable [0x00000000026de000]\n   java.lang.Thread.State: RUNNABLE\n        at sf.jvm.load.DeadLoopClass.<clinit>(DeadLoopClass.java:8)\n        at java.lang.Class.forName0(Native Method)\n        at java.lang.Class.forName(Class.java:264)\n        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:123)\n\"VM Thread\" os_prio=2 tid=0x0000000016ff7000 nid=0x6d4 runnable\n\"GC task thread#0 (ParallelGC)\" os_prio=0 tid=0x00000000026f7800 nid=0x4890 runnable\n\"GC task thread#1 (ParallelGC)\" os_prio=0 tid=0x00000000026f9000 nid=0x4514 runnable\n\"VM Periodic Task Thread\" os_prio=2 tid=0x00000000184e1800 nid=0x4934 waiting on condition\nJNI global references: 15\n```\n\n### 2 类加载器\n\n#### 2.1 　类加载器概述\n\n虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。\n类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 JavaApplet 的需求而被开发出来的。如今 JavaApplet 技术基本上已经死掉[1]，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石。\n类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。\n\n#### 2.2 类加载器的结构\n\n```\ngraph BT\n启动类加载器-->扩展类加载器\n扩展类加载器-->应用类加载器\n应用类加载器-->自定义加载器1\n应用类加载器-->自定义加载器2\n```\n\nJava 虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现[2]，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下三种系统提供的类加载器：：\n引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。\n扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。\n应用程序类加载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。\n除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。\n\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。\n\n破坏双亲委派模型\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK1.2 发布之前。由于双亲委派模型在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，\n双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK1.3 时代放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或 U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。在 JSR-297[4]、JSR-277[5]规范从纸上标准变成真正可运行的程序之前，OSGi 是当前业界“事实上”的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。\n在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：\n\n> （1）将以 java.\\*开头的类，委派给父类加载器加载。\n> （2）否则，将委派列表名单内的类，委派给父类加载器加载。\n> （3）否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。\n> （4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。\n> （5）否则，查找类是否在自己的 FragmentBundle 中，如果在，则委派给 FragmentBundle 的类加载器加载。\n> （6）否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。\n> （7）否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。\n\n虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，自然就明白了类加载器的精粹。\n//TODO\nOSGI\n\n#### 2.3 自定义类加载器实例:\n\n##### 2.3.1 文件加载:\n\n```java\npackage sf.jvm.load.classloader;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\n\npublic class FileSystemClassLoader extends ClassLoader {\n\n  private String rootDir;\n\n  public FileSystemClassLoader(String rootDir) {\n      this.rootDir = rootDir;\n  }\n\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n      byte[] classData = getClassData(name);\n      if (classData == null) {\n          throw new ClassNotFoundException();\n      } else {\n          return defineClass(name, classData, 0, classData.length);\n      }\n  }\n\n  private byte[] getClassData(String className) {\n      String path = classNameToPath(className);\n      try {\n          InputStream ins = new FileInputStream(path);\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          int bufferSize = 4096;\n          byte[] buffer = new byte[bufferSize];\n          int bytesNumRead = 0;\n          while ((bytesNumRead = ins.read(buffer)) != -1) {\n              baos.write(buffer, 0, bytesNumRead);\n          }\n          return baos.toByteArray();\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n      return null;\n  }\n\n  private String classNameToPath(String className) {\n      return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\";\n  }\n\n  public static void main(String[] args) {\n      String classDataRootPath = \"D:\\\\Code\\\\Jcode\\\\notes\\\\java-jlp\\\\java-jvm\\\\target\\\\classes\";\n      FileSystemClassLoader fileSystemClassLoader1 = new FileSystemClassLoader(classDataRootPath);\n      FileSystemClassLoader fileSystemClassLoader2 = new FileSystemClassLoader(classDataRootPath);\n      String className = \"sf.jvm.load.simple.Sample\";\n      try {\n          Class<?> class1 = fileSystemClassLoader1.loadClass(className);\n          Object obj1 = class1.newInstance();\n          Class<?> class2 = fileSystemClassLoader1.loadClass(className);\n          Object obj2 = class2.newInstance();\n          Method setSampleMethod = class1.getMethod(\"setSample\", Object.class);\n          setSampleMethod.invoke(obj1, obj2);\n          Method setSampleMethod2 = class1.getMethod(\"compare\", Object.class);\n          setSampleMethod2.invoke(obj1, obj2);\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n}\n```\n\n##### 2.3.2 网络加载:\n\n```java\npackage sf.jvm.load.classloader;\n\nimport sf.jvm.load.api.ICalculator;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.net.URL;\n\npublic class NetworkClassLoader extends ClassLoader {\n\n  private String rootUrl;\n\n  public NetworkClassLoader(String rootUrl) {\n      this.rootUrl = rootUrl;\n  }\n\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n      byte[] classData = getClassData(name);\n      if (classData == null) {\n          throw new ClassNotFoundException();\n      } else {\n          return defineClass(name, classData, 0, classData.length);\n      }\n  }\n\n  private byte[] getClassData(String className) {\n      String path = classNameToPath(className);\n      try {\n          URL url = new URL(path);\n          InputStream ins = url.openStream();\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          int bufferSize = 4096;\n          byte[] buffer = new byte[bufferSize];\n          int bytesNumRead = 0;\n          while ((bytesNumRead = ins.read(buffer)) != -1) {\n              baos.write(buffer, 0, bytesNumRead);\n          }\n          return baos.toByteArray();\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n      return null;\n  }\n\n  private String classNameToPath(String className) {\n      return rootUrl + \"/\" + className.replace('.', '/') + \".class\";\n  }\n\n  public static void main(String[] args) {\n      String url = \"http://localhost:8080/ClassloaderTest/classes\";\n      NetworkClassLoader ncl = new NetworkClassLoader(url);\n      String basicClassName = \"sf.jvm.load.simple.CalculatorBasic\";\n      String advancedClassName = \"sf.jvm.load.simple.CalculatorAdvanced\";\n      try {\n          Class<?> clazz = ncl.loadClass(basicClassName);\n          ICalculator calculator = (ICalculator) clazz.newInstance();\n          System.out.println(calculator.getVersion());\n          clazz = ncl.loadClass(advancedClassName);\n          calculator = (ICalculator) clazz.newInstance();\n          System.out.println(calculator.getVersion());\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n}\n```\n","slug":"language/jvm/JVM类加载机制","published":1,"date":"2021-07-31T09:04:32.008Z","updated":"2021-07-31T09:04:32.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2c0000ly2ukffoff5z1","content":"<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><h3 id=\"1-类的加载过程\"><a href=\"#1-类的加载过程\" class=\"headerlink\" title=\"1. 类的加载过程\"></a>1. 类的加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7 个阶段。其中准备、验证、解析 3 个部分统称为连接（Linking）。如图所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">加载--&gt;验证</span><br><span class=\"line\">验证--&gt;准备</span><br><span class=\"line\">准备--&gt;解析</span><br><span class=\"line\">解析--&gt;初始化</span><br><span class=\"line\">初始化--&gt;使用</span><br><span class=\"line\">使用--&gt;卸载</span><br></pre></td></tr></table></figure>\n\n<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已 HotSpot 为基准。</p>\n<h4 id=\"1-1-加载\"><a href=\"#1-1-加载\" class=\"headerlink\" title=\"1.1 加载\"></a>1.1 加载</h4><p>虚拟机在加载阶段需要完成三件事:</p>\n<ol>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流，如 Class 文件,网络,动态生成,数据库等</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<br>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</li>\n</ol>\n<h4 id=\"1-2-验证\"><a href=\"#1-2-验证\" class=\"headerlink\" title=\"1.2 验证\"></a>1.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，验证阶段大致会完成 4 个阶段的检验动作：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>\n<li>符号引用验证：确保解析动作能正确执行。<br>验证阶段可能抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、 java. lang. NoSuchFieldError、<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>\n</ol>\n<h4 id=\"1-3-准备\"><a href=\"#1-3-准备\" class=\"headerlink\" title=\"1.3 准备\"></a>1.3 准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值.</p>\n<p>如下定义:public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123.因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</p>\n<p>如下定义：public static final int value=123; 即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，所以标注为 final 之后，value 的值在准备阶段初始化为 123 而非 0.</p>\n<h4 id=\"1-4-解析\"><a href=\"#1-4-解析\" class=\"headerlink\" title=\"1.4 解析\"></a>1.4 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析针对如下 7 类符号引用进行：</p>\n<blockquote>\n<p>类或接口<br>字段<br>类方法<br>接口方法<br>方法类型<br>方法句柄<br>调用点限定符</p>\n</blockquote>\n<h4 id=\"1-5-初始化\"><a href=\"#1-5-初始化\" class=\"headerlink\" title=\"1.5 初始化\"></a>1.5 初始化</h4><p>类初始化阶段是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。</p>\n<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。我们放到后面再讲<clinit>()方法是怎么生成的，在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节，这部分相对更贴近于普通的程序开发人员[7]：<br>·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。<br>·<clinit>()方法与类的构造函数（或者说实例构造器<clinit>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是 java.lang.Object。<br>·由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码执行字段 B 的值将会是 2 而不是 1。<br><clinit>()方法执行顺序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        A = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> B = A;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">        System.out.println(Sub.B);</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> Sub().getB());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Compiled from &quot;Parent.java&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> class sf.jvm.load.Parent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> public static int A;</span></span><br><span class=\"line\"><span class=\"comment\"> sf.jvm.load.Parent();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 4: return</span></span><br><span class=\"line\"><span class=\"comment\"> public int getA();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: getstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 3: ireturn</span></span><br><span class=\"line\"><span class=\"comment\"> static &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: iconst_1</span></span><br><span class=\"line\"><span class=\"comment\"> 1: putstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 4: iconst_2</span></span><br><span class=\"line\"><span class=\"comment\"> 5: putstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 8: return</span></span><br><span class=\"line\"><span class=\"comment\"> &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>·<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。<br>·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。<br>·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLoopClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不加上这个if语句，编译器将提示&quot;Initializerdoesnotcompletenormally&quot;并拒绝编译</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;initDeadLoopClass&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runnable script = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">                DeadLoopClass dlc = <span class=\"keyword\">new</span> DeadLoopClass();</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;runover&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(script);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(script);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> &quot;C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javap.exe&quot; -c sf.jvm.load.DeadLoopClass</span></span><br><span class=\"line\"><span class=\"comment\"> Compiled from &quot;DeadLoopClass.java&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> class sf.jvm.load.DeadLoopClass &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> sf.jvm.load.DeadLoopClass();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 4: return</span></span><br><span class=\"line\"><span class=\"comment\"> public static void main(java.lang.String[]);</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: new           #2                  // class sf/jvm/load/DeadLoopClass$1</span></span><br><span class=\"line\"><span class=\"comment\"> 3: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 4: invokespecial #3                  // Method sf/jvm/load/DeadLoopClass$1.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 7: astore_1</span></span><br><span class=\"line\"><span class=\"comment\"> 8: new           #4                  // class java/lang/Thread</span></span><br><span class=\"line\"><span class=\"comment\"> 11: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 12: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> 13: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 16: astore_2</span></span><br><span class=\"line\"><span class=\"comment\"> 17: new           #4                  // class java/lang/Thread</span></span><br><span class=\"line\"><span class=\"comment\"> 20: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 21: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> 22: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 25: astore_3</span></span><br><span class=\"line\"><span class=\"comment\"> 26: aload_2</span></span><br><span class=\"line\"><span class=\"comment\"> 27: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 30: aload_3</span></span><br><span class=\"line\"><span class=\"comment\"> 31: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 34: return</span></span><br><span class=\"line\"><span class=\"comment\"> static &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\"><span class=\"comment\"> 3: new           #8                  // class java/lang/StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> 6: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 7: invokespecial #9                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 10: invokestatic  #10                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span></span><br><span class=\"line\"><span class=\"comment\"> 13: invokevirtual #11                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;</span></span><br><span class=\"line\"><span class=\"comment\"> 16: ldc           #12                 // String initDeadLoopClass</span></span><br><span class=\"line\"><span class=\"comment\"> 18: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class=\"line\"><span class=\"comment\"> 21: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class=\"line\"><span class=\"comment\"> 24: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 27: goto          27</span></span><br><span class=\"line\"><span class=\"comment\"> &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[main,<span class=\"number\">5</span>,main]initDeadLoopClass</span><br><span class=\"line\">通过分析：一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待.</span><br><span class=\"line\">线程堆栈如下:</span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">07</span>-<span class=\"number\">29</span> <span class=\"number\">20</span>:<span class=\"number\">05</span>:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"function\">Full thread dump Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server <span class=\"title\">VM</span> <span class=\"params\">(<span class=\"number\">25.91</span>-b14 mixed mode)</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">&quot;Monitor Ctrl-Break&quot; #10 daemon prio</span>=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x0000000018554800</span> nid=<span class=\"number\">0x4920</span> runnable [<span class=\"number\">0x00000000190de000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:<span class=\"number\">131</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class=\"number\">409</span>)</span><br><span class=\"line\">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:<span class=\"number\">199</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d79d67c0</span>&gt; (a java.net.SocksSocketImpl)</span><br><span class=\"line\">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class=\"number\">545</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.accept(ServerSocket.java:<span class=\"number\">513</span>)</span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMain$<span class=\"number\">1.</span>run(AppMain.java:<span class=\"number\">79</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Finalizer&quot;</span> #<span class=\"number\">3</span> daemon prio=<span class=\"number\">8</span> os_prio=<span class=\"number\">1</span> tid=<span class=\"number\">0x00000000027d8800</span> nid=<span class=\"number\">0x2d14</span> in Object.wait() [<span class=\"number\">0x000000001837e000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class=\"number\">143</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class=\"number\">164</span>)</span><br><span class=\"line\">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class=\"number\">209</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Reference Handler&quot;</span> #<span class=\"number\">2</span> daemon prio=<span class=\"number\">10</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x00000000027d3000</span> nid=<span class=\"number\">0x4914</span> in Object.wait() [<span class=\"number\">0x000000001827f000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">        at java.lang.Object.wait(Object.java:<span class=\"number\">502</span>)</span><br><span class=\"line\">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class=\"number\">191</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class=\"number\">153</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;main&quot;</span> #<span class=\"number\">1</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x000000000220e000</span> nid=<span class=\"number\">0x450c</span> runnable [<span class=\"number\">0x00000000026de000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at sf.jvm.load.DeadLoopClass.&lt;clinit&gt;(DeadLoopClass.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">        at java.lang.Class.forName0(Native Method)</span><br><span class=\"line\">        at java.lang.Class.forName(Class.java:<span class=\"number\">264</span>)</span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class=\"number\">123</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;VM Thread&quot;</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x0000000016ff7000</span> nid=<span class=\"number\">0x6d4</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00000000026f7800</span> nid=<span class=\"number\">0x4890</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#1 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00000000026f9000</span> nid=<span class=\"number\">0x4514</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x00000000184e1800</span> nid=<span class=\"number\">0x4934</span> waiting on condition</span><br><span class=\"line\">JNI global references: <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2 类加载器\"></a>2 类加载器</h3><h4 id=\"2-1-类加载器概述\"><a href=\"#2-1-类加载器概述\" class=\"headerlink\" title=\"2.1 　类加载器概述\"></a>2.1 　类加载器概述</h4><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。<br>类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 JavaApplet 的需求而被开发出来的。如今 JavaApplet 技术基本上已经死掉[1]，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石。<br>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>\n<h4 id=\"2-2-类加载器的结构\"><a href=\"#2-2-类加载器的结构\" class=\"headerlink\" title=\"2.2 类加载器的结构\"></a>2.2 类加载器的结构</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph BT</span><br><span class=\"line\">启动类加载器--&gt;扩展类加载器</span><br><span class=\"line\">扩展类加载器--&gt;应用类加载器</span><br><span class=\"line\">应用类加载器--&gt;自定义加载器1</span><br><span class=\"line\">应用类加载器--&gt;自定义加载器2</span><br></pre></td></tr></table></figure>\n\n<p>Java 虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现[2]，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下三种系统提供的类加载器：：<br>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。<br>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>应用程序类加载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。</p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>\n<p>破坏双亲委派模型<br>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK1.2 发布之前。由于双亲委派模型在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，<br>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK1.3 时代放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或 U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。在 JSR-297[4]、JSR-277[5]规范从纸上标准变成真正可运行的程序之前，OSGi 是当前业界“事实上”的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。<br>在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>\n<blockquote>\n<p>（1）将以 java.*开头的类，委派给父类加载器加载。<br>（2）否则，将委派列表名单内的类，委派给父类加载器加载。<br>（3）否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。<br>（4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。<br>（5）否则，查找类是否在自己的 FragmentBundle 中，如果在，则委派给 FragmentBundle 的类加载器加载。<br>（6）否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。<br>（7）否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>\n</blockquote>\n<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，自然就明白了类加载器的精粹。<br>//TODO<br>OSGI</p>\n<h4 id=\"2-3-自定义类加载器实例\"><a href=\"#2-3-自定义类加载器实例\" class=\"headerlink\" title=\"2.3 自定义类加载器实例:\"></a>2.3 自定义类加载器实例:</h4><h5 id=\"2-3-1-文件加载\"><a href=\"#2-3-1-文件加载\" class=\"headerlink\" title=\"2.3.1 文件加载:\"></a>2.3.1 文件加载:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load.classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String rootDir;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemClassLoader</span><span class=\"params\">(String rootDir)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.rootDir = rootDir;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getClassData(String className) &#123;</span><br><span class=\"line\">      String path = classNameToPath(className);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          InputStream ins = <span class=\"keyword\">new</span> FileInputStream(path);</span><br><span class=\"line\">          ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">          <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bufferSize];</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bytesNumRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              baos.write(buffer, <span class=\"number\">0</span>, bytesNumRead);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> baos.toByteArray();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">classNameToPath</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rootDir + File.separatorChar + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, File.separatorChar) + <span class=\"string\">&quot;.class&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      String classDataRootPath = <span class=\"string\">&quot;D:\\\\Code\\\\Jcode\\\\notes\\\\java-jlp\\\\java-jvm\\\\target\\\\classes&quot;</span>;</span><br><span class=\"line\">      FileSystemClassLoader fileSystemClassLoader1 = <span class=\"keyword\">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class=\"line\">      FileSystemClassLoader fileSystemClassLoader2 = <span class=\"keyword\">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class=\"line\">      String className = <span class=\"string\">&quot;sf.jvm.load.simple.Sample&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class&lt;?&gt; class1 = fileSystemClassLoader1.loadClass(className);</span><br><span class=\"line\">          Object obj1 = class1.newInstance();</span><br><span class=\"line\">          Class&lt;?&gt; class2 = fileSystemClassLoader1.loadClass(className);</span><br><span class=\"line\">          Object obj2 = class2.newInstance();</span><br><span class=\"line\">          Method setSampleMethod = class1.getMethod(<span class=\"string\">&quot;setSample&quot;</span>, Object.class);</span><br><span class=\"line\">          setSampleMethod.invoke(obj1, obj2);</span><br><span class=\"line\">          Method setSampleMethod2 = class1.getMethod(<span class=\"string\">&quot;compare&quot;</span>, Object.class);</span><br><span class=\"line\">          setSampleMethod2.invoke(obj1, obj2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-2-网络加载\"><a href=\"#2-3-2-网络加载\" class=\"headerlink\" title=\"2.3.2 网络加载:\"></a>2.3.2 网络加载:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load.classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sf.jvm.load.api.ICalculator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String rootUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkClassLoader</span><span class=\"params\">(String rootUrl)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.rootUrl = rootUrl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getClassData(String className) &#123;</span><br><span class=\"line\">      String path = classNameToPath(className);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          URL url = <span class=\"keyword\">new</span> URL(path);</span><br><span class=\"line\">          InputStream ins = url.openStream();</span><br><span class=\"line\">          ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">          <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bufferSize];</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bytesNumRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              baos.write(buffer, <span class=\"number\">0</span>, bytesNumRead);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> baos.toByteArray();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">classNameToPath</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rootUrl + <span class=\"string\">&quot;/&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"string\">&quot;.class&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      String url = <span class=\"string\">&quot;http://localhost:8080/ClassloaderTest/classes&quot;</span>;</span><br><span class=\"line\">      NetworkClassLoader ncl = <span class=\"keyword\">new</span> NetworkClassLoader(url);</span><br><span class=\"line\">      String basicClassName = <span class=\"string\">&quot;sf.jvm.load.simple.CalculatorBasic&quot;</span>;</span><br><span class=\"line\">      String advancedClassName = <span class=\"string\">&quot;sf.jvm.load.simple.CalculatorAdvanced&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class=\"line\">          ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class=\"line\">          System.out.println(calculator.getVersion());</span><br><span class=\"line\">          clazz = ncl.loadClass(advancedClassName);</span><br><span class=\"line\">          calculator = (ICalculator) clazz.newInstance();</span><br><span class=\"line\">          System.out.println(calculator.getVersion());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><h3 id=\"1-类的加载过程\"><a href=\"#1-类的加载过程\" class=\"headerlink\" title=\"1. 类的加载过程\"></a>1. 类的加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7 个阶段。其中准备、验证、解析 3 个部分统称为连接（Linking）。如图所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">加载--&gt;验证</span><br><span class=\"line\">验证--&gt;准备</span><br><span class=\"line\">准备--&gt;解析</span><br><span class=\"line\">解析--&gt;初始化</span><br><span class=\"line\">初始化--&gt;使用</span><br><span class=\"line\">使用--&gt;卸载</span><br></pre></td></tr></table></figure>\n\n<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已 HotSpot 为基准。</p>\n<h4 id=\"1-1-加载\"><a href=\"#1-1-加载\" class=\"headerlink\" title=\"1.1 加载\"></a>1.1 加载</h4><p>虚拟机在加载阶段需要完成三件事:</p>\n<ol>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流，如 Class 文件,网络,动态生成,数据库等</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<br>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</li>\n</ol>\n<h4 id=\"1-2-验证\"><a href=\"#1-2-验证\" class=\"headerlink\" title=\"1.2 验证\"></a>1.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，验证阶段大致会完成 4 个阶段的检验动作：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>\n<li>符号引用验证：确保解析动作能正确执行。<br>验证阶段可能抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、 java. lang. NoSuchFieldError、<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>\n</ol>\n<h4 id=\"1-3-准备\"><a href=\"#1-3-准备\" class=\"headerlink\" title=\"1.3 准备\"></a>1.3 准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值.</p>\n<p>如下定义:public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123.因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</p>\n<p>如下定义：public static final int value=123; 即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，所以标注为 final 之后，value 的值在准备阶段初始化为 123 而非 0.</p>\n<h4 id=\"1-4-解析\"><a href=\"#1-4-解析\" class=\"headerlink\" title=\"1.4 解析\"></a>1.4 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析针对如下 7 类符号引用进行：</p>\n<blockquote>\n<p>类或接口<br>字段<br>类方法<br>接口方法<br>方法类型<br>方法句柄<br>调用点限定符</p>\n</blockquote>\n<h4 id=\"1-5-初始化\"><a href=\"#1-5-初始化\" class=\"headerlink\" title=\"1.5 初始化\"></a>1.5 初始化</h4><p>类初始化阶段是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。</p>\n<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。我们放到后面再讲<clinit>()方法是怎么生成的，在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节，这部分相对更贴近于普通的程序开发人员[7]：<br>·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。<br>·<clinit>()方法与类的构造函数（或者说实例构造器<clinit>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是 java.lang.Object。<br>·由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码执行字段 B 的值将会是 2 而不是 1。<br><clinit>()方法执行顺序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        A = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> B = A;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">        System.out.println(Sub.B);</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> Sub().getB());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Compiled from &quot;Parent.java&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> class sf.jvm.load.Parent &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> public static int A;</span></span><br><span class=\"line\"><span class=\"comment\"> sf.jvm.load.Parent();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 4: return</span></span><br><span class=\"line\"><span class=\"comment\"> public int getA();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: getstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 3: ireturn</span></span><br><span class=\"line\"><span class=\"comment\"> static &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: iconst_1</span></span><br><span class=\"line\"><span class=\"comment\"> 1: putstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 4: iconst_2</span></span><br><span class=\"line\"><span class=\"comment\"> 5: putstatic     #2                  // Field A:I</span></span><br><span class=\"line\"><span class=\"comment\"> 8: return</span></span><br><span class=\"line\"><span class=\"comment\"> &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>·<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。<br>·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。<br>·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLoopClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不加上这个if语句，编译器将提示&quot;Initializerdoesnotcompletenormally&quot;并拒绝编译</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;initDeadLoopClass&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runnable script = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">                DeadLoopClass dlc = <span class=\"keyword\">new</span> DeadLoopClass();</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;runover&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(script);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(script);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> &quot;C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javap.exe&quot; -c sf.jvm.load.DeadLoopClass</span></span><br><span class=\"line\"><span class=\"comment\"> Compiled from &quot;DeadLoopClass.java&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> class sf.jvm.load.DeadLoopClass &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> sf.jvm.load.DeadLoopClass();</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 4: return</span></span><br><span class=\"line\"><span class=\"comment\"> public static void main(java.lang.String[]);</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: new           #2                  // class sf/jvm/load/DeadLoopClass$1</span></span><br><span class=\"line\"><span class=\"comment\"> 3: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 4: invokespecial #3                  // Method sf/jvm/load/DeadLoopClass$1.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 7: astore_1</span></span><br><span class=\"line\"><span class=\"comment\"> 8: new           #4                  // class java/lang/Thread</span></span><br><span class=\"line\"><span class=\"comment\"> 11: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 12: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> 13: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 16: astore_2</span></span><br><span class=\"line\"><span class=\"comment\"> 17: new           #4                  // class java/lang/Thread</span></span><br><span class=\"line\"><span class=\"comment\"> 20: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 21: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> 22: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 25: astore_3</span></span><br><span class=\"line\"><span class=\"comment\"> 26: aload_2</span></span><br><span class=\"line\"><span class=\"comment\"> 27: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 30: aload_3</span></span><br><span class=\"line\"><span class=\"comment\"> 31: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 34: return</span></span><br><span class=\"line\"><span class=\"comment\"> static &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> Code:</span></span><br><span class=\"line\"><span class=\"comment\"> 0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\"><span class=\"comment\"> 3: new           #8                  // class java/lang/StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> 6: dup</span></span><br><span class=\"line\"><span class=\"comment\"> 7: invokespecial #9                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\"><span class=\"comment\"> 10: invokestatic  #10                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span></span><br><span class=\"line\"><span class=\"comment\"> 13: invokevirtual #11                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;</span></span><br><span class=\"line\"><span class=\"comment\"> 16: ldc           #12                 // String initDeadLoopClass</span></span><br><span class=\"line\"><span class=\"comment\"> 18: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class=\"line\"><span class=\"comment\"> 21: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class=\"line\"><span class=\"comment\"> 24: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\"><span class=\"comment\"> 27: goto          27</span></span><br><span class=\"line\"><span class=\"comment\"> &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[main,<span class=\"number\">5</span>,main]initDeadLoopClass</span><br><span class=\"line\">通过分析：一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待.</span><br><span class=\"line\">线程堆栈如下:</span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">07</span>-<span class=\"number\">29</span> <span class=\"number\">20</span>:<span class=\"number\">05</span>:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"function\">Full thread dump Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server <span class=\"title\">VM</span> <span class=\"params\">(<span class=\"number\">25.91</span>-b14 mixed mode)</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">&quot;Monitor Ctrl-Break&quot; #10 daemon prio</span>=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x0000000018554800</span> nid=<span class=\"number\">0x4920</span> runnable [<span class=\"number\">0x00000000190de000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:<span class=\"number\">131</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class=\"number\">409</span>)</span><br><span class=\"line\">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:<span class=\"number\">199</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d79d67c0</span>&gt; (a java.net.SocksSocketImpl)</span><br><span class=\"line\">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class=\"number\">545</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.accept(ServerSocket.java:<span class=\"number\">513</span>)</span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMain$<span class=\"number\">1.</span>run(AppMain.java:<span class=\"number\">79</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Finalizer&quot;</span> #<span class=\"number\">3</span> daemon prio=<span class=\"number\">8</span> os_prio=<span class=\"number\">1</span> tid=<span class=\"number\">0x00000000027d8800</span> nid=<span class=\"number\">0x2d14</span> in Object.wait() [<span class=\"number\">0x000000001837e000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class=\"number\">143</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class=\"number\">164</span>)</span><br><span class=\"line\">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class=\"number\">209</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Reference Handler&quot;</span> #<span class=\"number\">2</span> daemon prio=<span class=\"number\">10</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x00000000027d3000</span> nid=<span class=\"number\">0x4914</span> in Object.wait() [<span class=\"number\">0x000000001827f000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">        at java.lang.Object.wait(Object.java:<span class=\"number\">502</span>)</span><br><span class=\"line\">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class=\"number\">191</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class=\"number\">153</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;main&quot;</span> #<span class=\"number\">1</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x000000000220e000</span> nid=<span class=\"number\">0x450c</span> runnable [<span class=\"number\">0x00000000026de000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at sf.jvm.load.DeadLoopClass.&lt;clinit&gt;(DeadLoopClass.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">        at java.lang.Class.forName0(Native Method)</span><br><span class=\"line\">        at java.lang.Class.forName(Class.java:<span class=\"number\">264</span>)</span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class=\"number\">123</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;VM Thread&quot;</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x0000000016ff7000</span> nid=<span class=\"number\">0x6d4</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00000000026f7800</span> nid=<span class=\"number\">0x4890</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#1 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00000000026f9000</span> nid=<span class=\"number\">0x4514</span> runnable</span><br><span class=\"line\"><span class=\"string\">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class=\"number\">2</span> tid=<span class=\"number\">0x00000000184e1800</span> nid=<span class=\"number\">0x4934</span> waiting on condition</span><br><span class=\"line\">JNI global references: <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2 类加载器\"></a>2 类加载器</h3><h4 id=\"2-1-类加载器概述\"><a href=\"#2-1-类加载器概述\" class=\"headerlink\" title=\"2.1 　类加载器概述\"></a>2.1 　类加载器概述</h4><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。<br>类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 JavaApplet 的需求而被开发出来的。如今 JavaApplet 技术基本上已经死掉[1]，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石。<br>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>\n<h4 id=\"2-2-类加载器的结构\"><a href=\"#2-2-类加载器的结构\" class=\"headerlink\" title=\"2.2 类加载器的结构\"></a>2.2 类加载器的结构</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph BT</span><br><span class=\"line\">启动类加载器--&gt;扩展类加载器</span><br><span class=\"line\">扩展类加载器--&gt;应用类加载器</span><br><span class=\"line\">应用类加载器--&gt;自定义加载器1</span><br><span class=\"line\">应用类加载器--&gt;自定义加载器2</span><br></pre></td></tr></table></figure>\n\n<p>Java 虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现[2]，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下三种系统提供的类加载器：：<br>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。<br>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>应用程序类加载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。</p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>\n<p>破坏双亲委派模型<br>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK1.2 发布之前。由于双亲委派模型在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，<br>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK1.3 时代放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或 U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。在 JSR-297[4]、JSR-277[5]规范从纸上标准变成真正可运行的程序之前，OSGi 是当前业界“事实上”的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。<br>在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>\n<blockquote>\n<p>（1）将以 java.*开头的类，委派给父类加载器加载。<br>（2）否则，将委派列表名单内的类，委派给父类加载器加载。<br>（3）否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。<br>（4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。<br>（5）否则，查找类是否在自己的 FragmentBundle 中，如果在，则委派给 FragmentBundle 的类加载器加载。<br>（6）否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。<br>（7）否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>\n</blockquote>\n<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，自然就明白了类加载器的精粹。<br>//TODO<br>OSGI</p>\n<h4 id=\"2-3-自定义类加载器实例\"><a href=\"#2-3-自定义类加载器实例\" class=\"headerlink\" title=\"2.3 自定义类加载器实例:\"></a>2.3 自定义类加载器实例:</h4><h5 id=\"2-3-1-文件加载\"><a href=\"#2-3-1-文件加载\" class=\"headerlink\" title=\"2.3.1 文件加载:\"></a>2.3.1 文件加载:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load.classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String rootDir;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemClassLoader</span><span class=\"params\">(String rootDir)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.rootDir = rootDir;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getClassData(String className) &#123;</span><br><span class=\"line\">      String path = classNameToPath(className);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          InputStream ins = <span class=\"keyword\">new</span> FileInputStream(path);</span><br><span class=\"line\">          ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">          <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bufferSize];</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bytesNumRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              baos.write(buffer, <span class=\"number\">0</span>, bytesNumRead);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> baos.toByteArray();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">classNameToPath</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rootDir + File.separatorChar + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, File.separatorChar) + <span class=\"string\">&quot;.class&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      String classDataRootPath = <span class=\"string\">&quot;D:\\\\Code\\\\Jcode\\\\notes\\\\java-jlp\\\\java-jvm\\\\target\\\\classes&quot;</span>;</span><br><span class=\"line\">      FileSystemClassLoader fileSystemClassLoader1 = <span class=\"keyword\">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class=\"line\">      FileSystemClassLoader fileSystemClassLoader2 = <span class=\"keyword\">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class=\"line\">      String className = <span class=\"string\">&quot;sf.jvm.load.simple.Sample&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class&lt;?&gt; class1 = fileSystemClassLoader1.loadClass(className);</span><br><span class=\"line\">          Object obj1 = class1.newInstance();</span><br><span class=\"line\">          Class&lt;?&gt; class2 = fileSystemClassLoader1.loadClass(className);</span><br><span class=\"line\">          Object obj2 = class2.newInstance();</span><br><span class=\"line\">          Method setSampleMethod = class1.getMethod(<span class=\"string\">&quot;setSample&quot;</span>, Object.class);</span><br><span class=\"line\">          setSampleMethod.invoke(obj1, obj2);</span><br><span class=\"line\">          Method setSampleMethod2 = class1.getMethod(<span class=\"string\">&quot;compare&quot;</span>, Object.class);</span><br><span class=\"line\">          setSampleMethod2.invoke(obj1, obj2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-2-网络加载\"><a href=\"#2-3-2-网络加载\" class=\"headerlink\" title=\"2.3.2 网络加载:\"></a>2.3.2 网络加载:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sf.jvm.load.classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sf.jvm.load.api.ICalculator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String rootUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkClassLoader</span><span class=\"params\">(String rootUrl)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.rootUrl = rootUrl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getClassData(String className) &#123;</span><br><span class=\"line\">      String path = classNameToPath(className);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          URL url = <span class=\"keyword\">new</span> URL(path);</span><br><span class=\"line\">          InputStream ins = url.openStream();</span><br><span class=\"line\">          ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">          <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bufferSize];</span><br><span class=\"line\">          <span class=\"keyword\">int</span> bytesNumRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              baos.write(buffer, <span class=\"number\">0</span>, bytesNumRead);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> baos.toByteArray();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">classNameToPath</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rootUrl + <span class=\"string\">&quot;/&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"string\">&quot;.class&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      String url = <span class=\"string\">&quot;http://localhost:8080/ClassloaderTest/classes&quot;</span>;</span><br><span class=\"line\">      NetworkClassLoader ncl = <span class=\"keyword\">new</span> NetworkClassLoader(url);</span><br><span class=\"line\">      String basicClassName = <span class=\"string\">&quot;sf.jvm.load.simple.CalculatorBasic&quot;</span>;</span><br><span class=\"line\">      String advancedClassName = <span class=\"string\">&quot;sf.jvm.load.simple.CalculatorAdvanced&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class=\"line\">          ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class=\"line\">          System.out.println(calculator.getVersion());</span><br><span class=\"line\">          clazz = ncl.loadClass(advancedClassName);</span><br><span class=\"line\">          calculator = (ICalculator) clazz.newInstance();</span><br><span class=\"line\">          System.out.println(calculator.getVersion());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"JVM性能监控及故障分析工具","_content":"\n\n# JVM 性能监控及故障分析工具\n\n## 1.概要\nJDK官方提供了不少好用的JAVA故障处理工具,JDK的命令行工具在JDK的bin目录下供用户使用。\n## ２.jps\n### ２.1.简介　\njps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。\n命令格式：\n```java\njps [options] [hostid] \n```\noptions 参数详解:\n参数 | 解释\n----| ----\n -q | 仅输出VM标识符，不包括classname,jar name,arguments in main method \n -m | 输出main method的参数 \n -l | 输出完全的包名，应用主类名，jar的完全路径名 \n -v | 输出jvm参数 \n -V | 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 \n -J | 传递参数到vm,例如:-J-Xms512m\nhostid 参数解释:\n[protocol:][[//]hostname][:port][/servername]\n\n### ２.２.实例\n\n```java\n[java@RCS-AS-01 root]$ jps\n3201 Jps\n20819 AuthBootstrap\n```\n\n```java\n[java@RCS-AS-01 root]$ jps -lv\n20819 com.feinno.urcs.auth.main.AuthBootstrap -Duser.dir=/home/urcs/urcs-as-authentication -Xmx1024m -Xms1024m\n```\n\n```java\n[java@RCS-AS-01 root]$ jps -lvm 10.10.220.101\nRMI Registry not available at 10.10.220.101:1099\nConnection refused to host: 10.10.220.101; nested exception is:java.net.ConnectException: Connection refused。\n需要在远程机器上开启：jstatd\n```\n\n## 3.jstat\n### 3.1.简介　\n\nJstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于Java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具。\n命令格式：\n```java\njstat [options]\n```\n###  3.2.options 参数详解:\n\n* 3.2.1. jstat -class <pid> : 显示加载 class 的数量,及所占空间等信息,\n\n显示列名|具体描述\n------|-------\nLoaded|装载的类的数量\nBytes|装载类所占用的字节数\nUnloaded|卸载类的数量\nBytes|卸载类的字节数\nTime|装载和卸载类所花费的时间\n\n* 3.2.2.jstat -compiler <pid>:显示 VM 实时编译的数量等信息,\n\n显示列名|具体描述\n------|-------\nCompiled|编译任务执行数量\nFailed|编译任务执行失败数量\nInvalid|编译任务执行失效数量\nTime|编译任务消耗时间\nFailedType|最后一个编译失败任务的类型\nFailedMethod|最后一个编译失败任务所在的类及方法\n\n* 3.2.3.jstat -gc <pid>: 可以显示 gc 的信息,查看 gc 的次数,及时间,\n\n显示列名|具体描述\n------|-------\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nS0U|年轻代中第一个 survivor(幸存区)目前已使用空间(字节)\nS1U|年轻代中第二个 survivor(幸存区)目前已使用空间(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nEU|年轻代中 Eden(伊甸园)目前已使用空间(字节)\nOC|Old 代的容量(字节)\nOU|Old 代目前已使用空间(字节)\nPC|Perm(持久代)的容量(字节)\nPU|Perm(持久代)目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n*  3.2.4. jstat -gccapacity <pid>:可以显示,VM 内存中三代(young,old,perm)对象的使用和占用大小\n\n显示列名|具体描述\n------|-------\nNGCMN|年轻代(young)中初始化(最小)的大小(字节)\nNGCMX|年轻代(young)的最大容量(字节)\nNGC|年轻代(young)中当前的容量(字节)\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nOGCMN|old 代中初始化(最小)的大小(字节)\nOGCMX|old 代的最大容量(字节)\nOGC|old 代当前新生成的容量(字节)\nOC|Old 代的容量(字节)\nPGCMN|perm 代中初始化(最小)的大小(字节)\nPGCMX|perm 代的最大容量(字节)\nPGC|perm 代当前新生成的容量(字节)\nPC|Perm(持久代)的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\n\n* 3.2.5.jstat -gcutil <pid>:统计 gc 信息\n\n显示列名|具体描述\n------|-------\nS0| 年轻代中第一个 survivor(幸存区)已使用的占当前容量百分比\nS1|年轻代中第二个 survivor(幸存区)已使用的占当前容量百分比\nE|年轻代中 Eden(伊甸园)已使用的占当前容量百分比\nO|old 代已使用的占当前容量百分比\nP|perm 代已使用的占当前容量百分比\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.6. jstat -gcnew <pid>:年轻代对象的信息,\n\n显示列名|具体描述\n------|-------\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nS0U|年轻代中第一个 survivor(幸存区)目前已使用空间(字节)\nS1U|年轻代中第二个 survivor(幸存区)目前已使用空间(字节)\nTT|持有次数限制\nMTT|最大持有次数限制\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nEU|年轻代中 Eden(伊甸园)目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\n\n* 3.2.7. jstat -gcnewcapacity <pid>: 年轻代对象的信息及其占用量,\n\n显示列名|具体描述\n------|-------\nNGCMN|年轻代(young)中初始化(最小)的大小(字节)\nNGCMX|年轻代(young)的最大容量(字节)\nNGC|年轻代(young)中当前的容量(字节)\nS0CMX|年轻代中第一个 survivor(幸存区)的最大容量(字节)\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1CMX|年轻代中第二个 survivor(幸存区)的最大容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nECMX|年轻代中 Eden(伊甸园)的最大容量(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\n\n* 3.2.8. jstat -gcold <pid>:old 代对象的信息,\n\n显示列名|具体描述\n------|-------\nPC|Perm(持久代)的容量(字节)\nPU|Perm(持久代)目前已使用空间(字节)\nOC|Old 代的容量(字节)\nOU|Old 代目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.9.stat -gcoldcapacity <pid>: old 代对象的信息及其占用量\n\n显示列名|具体描述\n------|-------\nOGCMN|old 代中初始化(最小)的大小(字节)\nOGCMX|old 代的最大容量(字节)\nOGC|old 代当前新生成的容量(字节)\nOC|Old 代的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.10. jstat -gcpermcapacity<pid>: perm 对象的信息及其占用量,\n\n显示列名|具体描述\n------|-------\nPGCMN|perm 代中初始化(最小)的大小(字节)\nPGCMX|perm 代的最大容量(字节)\nPGC|perm 代当前新生成的容量(字节)\nPC|Perm(持久代)的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.11. jstat -printcompilation <pid>:当前 VM 执行的信息,\n\n显示列名|具体描述\n------|-------\nCompiled|编译任务的数目\nSize|方法生成的字节码的大小\nType|编译类型\nMethod|类名和方法名用来标识编译的方法,类名使用/做为一个命名空间分隔符,方法名是给定类中的方法,上述格式是由-XX:+PrintComplation 选项进行设置的\n\n### 3.3.实例:\n\n```java\n[java@RCS-AS-01 root]$ jstat -gcutil 16885 1000\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00  93.51  54.24  10.36  98.25  96.86    205   16.720     3    1.041   17.760\n  0.00  93.51  54.24  10.36  98.25  96.86    205   16.720     3    1.041   17.760\n```\n\n```java\n[java@RCS-AS-01 root]$ jstat -class 16885 1000\nLoaded  Bytes  Unloaded  Bytes     Time\n 10051 19327.1       32    44.2      27.15\n 10051 19327.1       32    44.2      27.15\n```\n\n## 4.jinfo\n### 4.1.简介　\n\njinfo(Java Configuration Information)，主要用于查看指定Java进程(或核心文件、远程调试服务器)的Java配置信息。\n命令格式：\n\n```java\njinfo [options] pid\njinfo [options] executable core\njinfo [options] [server-id@]remote-hostname-or-IP\n```\n\n参数详解:\n参数 | 解释\n----| ----\n pid  | 进程号\n executable | 产生core dump的java executable\n core  | core file\n remote-hostname-or-IP  | 主机名或ip\n server-id | 远程主机上的debug server的唯一id\n\noptions 参数详解:\n\n参数 | 解释\n----| ----\nno option | 打印命令行参数和系统属性\n-flags | 打印命令行参数\n-sysprops | 打印系统属性\n-h | 帮助\n\n### 4.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jinfo 16885\nAttaching to process ID 16885, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.65-b01\nJava System Properties:\njava.runtime.name = Java(TM) SE Runtime Environment\njava.vm.version = 25.65-b01\nsun.boot.library.path = /usr/local/jdk8u65/jre/lib/amd64\njava.vendor.url = http://java.oracle.com/\njava.vm.vendor = Oracle Corporation\npath.separator = :\nfile.encoding.pkg = sun.io\njava.vm.name = Java HotSpot(TM) 64-Bit Server VM\n.....\nVM Flags:\nNon-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=357564416 -XX:OldSize=716177408 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC\nCommand line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m\n```\n\n```java\n[java@RCS-AS-01 root]$ jinfo -flags 16885\nAttaching to process ID 16885, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.65-b01\nNon-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=357564416 -XX:OldSize=716177408 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC\nCommand line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m\n```\n\n## 5.jmap\n\n### 5.1.简介　\njps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。\n命令格式：\n```java\njmap [options] pid\njmap [options] executable core\njmap [options] [server-id@]remote-hostname-or-IP\n```\n参数详解:\n参数 | 解释\n----| ----\n pid  | 进程号\n executable | 产生core dump的java executable\n core  | core file\n remote-hostname-or-IP  | 主机名或ip\n server-id | 远程主机上的debug server的唯一id\n \noptions 参数详解:\n参数 | 解释\n----| ----\n-dump:[live,]format=b,file=<filename> | 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. \n-finalizerinfo | 打印正等候回收的对象的信息.\n-heap  | 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.\n-histo[:live] | 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. \n-permstat | 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来. \n-F | 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效. \n-h | -help 打印辅助信息 \n-J | 传递参数给jmap启动的jvm.\n\n### 5.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jmap -dump:live,format=b,file=/tmp/heap.dump 16885\nDumping heap to /tmp/heap.dump ...\nHeap dump file created\n```\n\n## 6.jstack\n\n### 6.1.简介　\njstack（ Stack Trace for Java） 命令 用于 生成 虚拟 机 当前 时刻 的 线程 快照（ 一般 称为 threaddump 或 javacore 文件）。 线程 快照 就是 当前 虚拟 机内 每一 条 线程 正在 执行 的 方法 堆栈 的 集合， 生成 线程 快照 的 主要 目的 是 定位 线程 出现 长时间 停顿 的 原因， 如 线程间死锁,死 循环,请求 外部 资源 导致 的 长时间 等待 等 都是 导致 线程 长时间 停顿 的 常见 原因。\n\n命令格式：\n\n```java\njstack [options] pid\njstack [options] executable core\njstack [options] [server-id@]remote-hostname-or-IP\n```\n\n参数详解:\n\n参数 | 解释\n----| ----\npid | 进程号\nexecutable | 产生 core dump 的 java executable\ncore | core file\nremote-hostname-or-IP | 主机名或 ip\nserver-id | 远程主机上的 debug server 的唯一 id\n\noptions 参数详解:\n\n参数 | 解释\n----| ----\n-F | 当 jstack [-l] pid 没有相应的时候强制打印栈信息\n-l | 长列表. 打印关于锁的附加信息,例如属于 java.util.concurrent 的 ownable synchronizers 列表.\n-m | 打印 java 和 native c/c++框架的所有栈信息.\n-h | -help 打印帮助信息\n\n### 6.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jstack 16885 > /tmp/stack16885.1\n\n查看文件显示：\n2017-07-29 16:20:51\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.65-b01 mixed mode):\n\n\"HikariCP connection filler (pool HikariPool-11)\" #26011 daemon prio=5 os_prio=0 tid=0x0000000000f46000 nid=0x2bde waiting on condition [0x00007f334e8b4000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000c25016e8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n............\n```\n\n## 7.jhat\n\n### 7.1.简介　\n\n提供 jhat（ JVM Heap Analysis Tool） 命令 与 jmap 搭配 使用， 来 分析 jmap 生成 的 堆 转储 快照。\n命令格式：\n```java\n　jhat -J-Xmx512m <heap dump file>\n```\n备注:\njhat 内置 了 一个 微型 的 HTTP/ HTML 服务器， 生成 dump 文件 的 分析 结果 后， 可以 在 浏览器 中 查看。 不过 实事求是 地说， 在 实际 工作中， 除非 笔者 手上 真的 没有 别的 工具 可用， 否则 一般 都 不会 去 直接 使用 jhat 命令 来 分析 dump 文件， 主要原因 有 二： 一是 一般 不会 在 部署 应用 程序 的 服务器 上 直接 分析 dump 文件， 即使 可以 这样做， 也会 尽量 将dump 文件 拷贝 到 其他 机器[ 4] 上进 行 分析， 因为 分析 工作 是一 个 耗时 而且 消耗 硬件 资源 的 过程， 既然 都要 在 其他 机器 上 进行， 就 没 必要 受到 命令行 工具 的 限制 了。 另外 一个 原因 是 jhat 的 分析 功能 相对来说 比较 简陋， 后文 将会 介绍 到 的 VisualVM\n\n### 7.2.实例:\n\n1、产生dump文件 c:\\>jmap -dump:file=f:\\yown\\dump.bin   16912\nDumping heap to F:\\apps\\dump.txt ...\nHeap dump file created\n\n2、生成站点分析报告，便于网络访问 c:\\>jhat -J-Xmx512m -port 88f:\\yown\\dump.bin\n```\nReading from f:\\apps\\dump.bin...\nDump file created Thu Jul 26 16:31:36 CST 2012\nSnapshot read, resolving...\nResolving 2194971 objects...\nChasing references, expect 438 dots.............................................\n................................................................................\n................................................................................\n................................................................................\n................................................................................\n.........................................................................\nEliminating duplicate references................................................\n................................................................................\n................................................................................\n................................................................................\n................................................................................\n......................................................................\nSnapshot resolved.\nStarted HTTP server on port 88\nServer is ready. 3.访问 http://localhost:88/ 这里记录了进程中所有类及实例个数\n```\n\n## 8.jvisualvm\n\n### 8.1.简介:\n\nVisualVM（ All- in- One Java Troubleshooting Tool） 是 到 目前 为止， 随 JDK 发布 的 功能 最强 大的 运行 监视 和 故障 处理 程序， 并且 可以 预见 在 未来 一段时间 内 都是 官方 主力 发展 的 虚拟 机 故障 处理 工具。 官方 在 VisualVM 的 软件 说明 中写 上了“ All- in- One” 的 描述 字样， 预示 着 它 除了 运行 监视、 故障 处理 外， 还 提供 了 很多 其他 方面 的 功能。VisualVM 基于 NetBeans 平台 开发， 因此 它 一 开始 就 具备 了 插件 扩展 功能 的 特性， 通过 插件 扩展 支持， VisualVM 可以 做到：\n·显示 虚拟 机 进程 及 进程 的 配置 和 环境 信息（ jps、 jinfo）\n·监视 应用 程序 的 CPU、 GC、 堆、 方法 区 及 线程 的 信息（ jstat、 jstack）。\n·dump 及 分析 堆 转储 快照（ jmap、 jhat）\n·方法 级 的 程序 运行 性能 分析， 找出 被 调用 最多、 运行 时间 最长 的 方法\n·离 线程 序 快照： 收集 程序 的 运行时 配置、 线程 dump、 内存 dump 等 信息 建立 一个 快照， 可以 将 快照 发送 开发者 处 进行 Bug 反馈。\n·其他 plugins 的 无限 的 可能性\n\n### 8.2.界面展示如下图\n\n![这里写图片描述](http://img.blog.csdn.net/20170729163459058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20170729163624195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 9.开启Java服务远程监控\n### 9.1.启动脚本中添加如下参数\n```ruby\nJAVA_ARGS[2]=\"-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=10.10.220.101\"\n```\n### 9.2.通过jvisualvm可以监控远程java服务，如下：\n![这里写图片描述](http://img.blog.csdn.net/20170729163143819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n","source":"_posts/language/jvm/JVM性能监控及故障分析工具.md","raw":"---\ntitle: JVM性能监控及故障分析工具\ncategories:\n- java\n---\n\n\n# JVM 性能监控及故障分析工具\n\n## 1.概要\nJDK官方提供了不少好用的JAVA故障处理工具,JDK的命令行工具在JDK的bin目录下供用户使用。\n## ２.jps\n### ２.1.简介　\njps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。\n命令格式：\n```java\njps [options] [hostid] \n```\noptions 参数详解:\n参数 | 解释\n----| ----\n -q | 仅输出VM标识符，不包括classname,jar name,arguments in main method \n -m | 输出main method的参数 \n -l | 输出完全的包名，应用主类名，jar的完全路径名 \n -v | 输出jvm参数 \n -V | 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 \n -J | 传递参数到vm,例如:-J-Xms512m\nhostid 参数解释:\n[protocol:][[//]hostname][:port][/servername]\n\n### ２.２.实例\n\n```java\n[java@RCS-AS-01 root]$ jps\n3201 Jps\n20819 AuthBootstrap\n```\n\n```java\n[java@RCS-AS-01 root]$ jps -lv\n20819 com.feinno.urcs.auth.main.AuthBootstrap -Duser.dir=/home/urcs/urcs-as-authentication -Xmx1024m -Xms1024m\n```\n\n```java\n[java@RCS-AS-01 root]$ jps -lvm 10.10.220.101\nRMI Registry not available at 10.10.220.101:1099\nConnection refused to host: 10.10.220.101; nested exception is:java.net.ConnectException: Connection refused。\n需要在远程机器上开启：jstatd\n```\n\n## 3.jstat\n### 3.1.简介　\n\nJstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于Java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具。\n命令格式：\n```java\njstat [options]\n```\n###  3.2.options 参数详解:\n\n* 3.2.1. jstat -class <pid> : 显示加载 class 的数量,及所占空间等信息,\n\n显示列名|具体描述\n------|-------\nLoaded|装载的类的数量\nBytes|装载类所占用的字节数\nUnloaded|卸载类的数量\nBytes|卸载类的字节数\nTime|装载和卸载类所花费的时间\n\n* 3.2.2.jstat -compiler <pid>:显示 VM 实时编译的数量等信息,\n\n显示列名|具体描述\n------|-------\nCompiled|编译任务执行数量\nFailed|编译任务执行失败数量\nInvalid|编译任务执行失效数量\nTime|编译任务消耗时间\nFailedType|最后一个编译失败任务的类型\nFailedMethod|最后一个编译失败任务所在的类及方法\n\n* 3.2.3.jstat -gc <pid>: 可以显示 gc 的信息,查看 gc 的次数,及时间,\n\n显示列名|具体描述\n------|-------\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nS0U|年轻代中第一个 survivor(幸存区)目前已使用空间(字节)\nS1U|年轻代中第二个 survivor(幸存区)目前已使用空间(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nEU|年轻代中 Eden(伊甸园)目前已使用空间(字节)\nOC|Old 代的容量(字节)\nOU|Old 代目前已使用空间(字节)\nPC|Perm(持久代)的容量(字节)\nPU|Perm(持久代)目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n*  3.2.4. jstat -gccapacity <pid>:可以显示,VM 内存中三代(young,old,perm)对象的使用和占用大小\n\n显示列名|具体描述\n------|-------\nNGCMN|年轻代(young)中初始化(最小)的大小(字节)\nNGCMX|年轻代(young)的最大容量(字节)\nNGC|年轻代(young)中当前的容量(字节)\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nOGCMN|old 代中初始化(最小)的大小(字节)\nOGCMX|old 代的最大容量(字节)\nOGC|old 代当前新生成的容量(字节)\nOC|Old 代的容量(字节)\nPGCMN|perm 代中初始化(最小)的大小(字节)\nPGCMX|perm 代的最大容量(字节)\nPGC|perm 代当前新生成的容量(字节)\nPC|Perm(持久代)的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\n\n* 3.2.5.jstat -gcutil <pid>:统计 gc 信息\n\n显示列名|具体描述\n------|-------\nS0| 年轻代中第一个 survivor(幸存区)已使用的占当前容量百分比\nS1|年轻代中第二个 survivor(幸存区)已使用的占当前容量百分比\nE|年轻代中 Eden(伊甸园)已使用的占当前容量百分比\nO|old 代已使用的占当前容量百分比\nP|perm 代已使用的占当前容量百分比\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.6. jstat -gcnew <pid>:年轻代对象的信息,\n\n显示列名|具体描述\n------|-------\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nS0U|年轻代中第一个 survivor(幸存区)目前已使用空间(字节)\nS1U|年轻代中第二个 survivor(幸存区)目前已使用空间(字节)\nTT|持有次数限制\nMTT|最大持有次数限制\nEC|年轻代中 Eden(伊甸园)的容量(字节)\nEU|年轻代中 Eden(伊甸园)目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nYGCT|从应用程序启动到采样时年轻代中 gc 所用时间(s)\n\n* 3.2.7. jstat -gcnewcapacity <pid>: 年轻代对象的信息及其占用量,\n\n显示列名|具体描述\n------|-------\nNGCMN|年轻代(young)中初始化(最小)的大小(字节)\nNGCMX|年轻代(young)的最大容量(字节)\nNGC|年轻代(young)中当前的容量(字节)\nS0CMX|年轻代中第一个 survivor(幸存区)的最大容量(字节)\nS0C|年轻代中第一个 survivor(幸存区)的容量(字节)\nS1CMX|年轻代中第二个 survivor(幸存区)的最大容量(字节)\nS1C|年轻代中第二个 survivor(幸存区)的容量(字节)\nECMX|年轻代中 Eden(伊甸园)的最大容量(字节)\nEC|年轻代中 Eden(伊甸园)的容量(字节)\n\n* 3.2.8. jstat -gcold <pid>:old 代对象的信息,\n\n显示列名|具体描述\n------|-------\nPC|Perm(持久代)的容量(字节)\nPU|Perm(持久代)目前已使用空间(字节)\nOC|Old 代的容量(字节)\nOU|Old 代目前已使用空间(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.9.stat -gcoldcapacity <pid>: old 代对象的信息及其占用量\n\n显示列名|具体描述\n------|-------\nOGCMN|old 代中初始化(最小)的大小(字节)\nOGCMX|old 代的最大容量(字节)\nOGC|old 代当前新生成的容量(字节)\nOC|Old 代的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.10. jstat -gcpermcapacity<pid>: perm 对象的信息及其占用量,\n\n显示列名|具体描述\n------|-------\nPGCMN|perm 代中初始化(最小)的大小(字节)\nPGCMX|perm 代的最大容量(字节)\nPGC|perm 代当前新生成的容量(字节)\nPC|Perm(持久代)的容量(字节)\nYGC|从应用程序启动到采样时年轻代中 gc 次数\nFGC|从应用程序启动到采样时 old 代(全 gc)gc 次数\nFGCT|从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)\nGCT|从应用程序启动到采样时 gc 用的总时间(s)\n\n* 3.2.11. jstat -printcompilation <pid>:当前 VM 执行的信息,\n\n显示列名|具体描述\n------|-------\nCompiled|编译任务的数目\nSize|方法生成的字节码的大小\nType|编译类型\nMethod|类名和方法名用来标识编译的方法,类名使用/做为一个命名空间分隔符,方法名是给定类中的方法,上述格式是由-XX:+PrintComplation 选项进行设置的\n\n### 3.3.实例:\n\n```java\n[java@RCS-AS-01 root]$ jstat -gcutil 16885 1000\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00  93.51  54.24  10.36  98.25  96.86    205   16.720     3    1.041   17.760\n  0.00  93.51  54.24  10.36  98.25  96.86    205   16.720     3    1.041   17.760\n```\n\n```java\n[java@RCS-AS-01 root]$ jstat -class 16885 1000\nLoaded  Bytes  Unloaded  Bytes     Time\n 10051 19327.1       32    44.2      27.15\n 10051 19327.1       32    44.2      27.15\n```\n\n## 4.jinfo\n### 4.1.简介　\n\njinfo(Java Configuration Information)，主要用于查看指定Java进程(或核心文件、远程调试服务器)的Java配置信息。\n命令格式：\n\n```java\njinfo [options] pid\njinfo [options] executable core\njinfo [options] [server-id@]remote-hostname-or-IP\n```\n\n参数详解:\n参数 | 解释\n----| ----\n pid  | 进程号\n executable | 产生core dump的java executable\n core  | core file\n remote-hostname-or-IP  | 主机名或ip\n server-id | 远程主机上的debug server的唯一id\n\noptions 参数详解:\n\n参数 | 解释\n----| ----\nno option | 打印命令行参数和系统属性\n-flags | 打印命令行参数\n-sysprops | 打印系统属性\n-h | 帮助\n\n### 4.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jinfo 16885\nAttaching to process ID 16885, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.65-b01\nJava System Properties:\njava.runtime.name = Java(TM) SE Runtime Environment\njava.vm.version = 25.65-b01\nsun.boot.library.path = /usr/local/jdk8u65/jre/lib/amd64\njava.vendor.url = http://java.oracle.com/\njava.vm.vendor = Oracle Corporation\npath.separator = :\nfile.encoding.pkg = sun.io\njava.vm.name = Java HotSpot(TM) 64-Bit Server VM\n.....\nVM Flags:\nNon-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=357564416 -XX:OldSize=716177408 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC\nCommand line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m\n```\n\n```java\n[java@RCS-AS-01 root]$ jinfo -flags 16885\nAttaching to process ID 16885, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.65-b01\nNon-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=357564416 -XX:OldSize=716177408 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC\nCommand line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m\n```\n\n## 5.jmap\n\n### 5.1.简介　\njps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。\n命令格式：\n```java\njmap [options] pid\njmap [options] executable core\njmap [options] [server-id@]remote-hostname-or-IP\n```\n参数详解:\n参数 | 解释\n----| ----\n pid  | 进程号\n executable | 产生core dump的java executable\n core  | core file\n remote-hostname-or-IP  | 主机名或ip\n server-id | 远程主机上的debug server的唯一id\n \noptions 参数详解:\n参数 | 解释\n----| ----\n-dump:[live,]format=b,file=<filename> | 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. \n-finalizerinfo | 打印正等候回收的对象的信息.\n-heap  | 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.\n-histo[:live] | 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. \n-permstat | 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来. \n-F | 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效. \n-h | -help 打印辅助信息 \n-J | 传递参数给jmap启动的jvm.\n\n### 5.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jmap -dump:live,format=b,file=/tmp/heap.dump 16885\nDumping heap to /tmp/heap.dump ...\nHeap dump file created\n```\n\n## 6.jstack\n\n### 6.1.简介　\njstack（ Stack Trace for Java） 命令 用于 生成 虚拟 机 当前 时刻 的 线程 快照（ 一般 称为 threaddump 或 javacore 文件）。 线程 快照 就是 当前 虚拟 机内 每一 条 线程 正在 执行 的 方法 堆栈 的 集合， 生成 线程 快照 的 主要 目的 是 定位 线程 出现 长时间 停顿 的 原因， 如 线程间死锁,死 循环,请求 外部 资源 导致 的 长时间 等待 等 都是 导致 线程 长时间 停顿 的 常见 原因。\n\n命令格式：\n\n```java\njstack [options] pid\njstack [options] executable core\njstack [options] [server-id@]remote-hostname-or-IP\n```\n\n参数详解:\n\n参数 | 解释\n----| ----\npid | 进程号\nexecutable | 产生 core dump 的 java executable\ncore | core file\nremote-hostname-or-IP | 主机名或 ip\nserver-id | 远程主机上的 debug server 的唯一 id\n\noptions 参数详解:\n\n参数 | 解释\n----| ----\n-F | 当 jstack [-l] pid 没有相应的时候强制打印栈信息\n-l | 长列表. 打印关于锁的附加信息,例如属于 java.util.concurrent 的 ownable synchronizers 列表.\n-m | 打印 java 和 native c/c++框架的所有栈信息.\n-h | -help 打印帮助信息\n\n### 6.2.实例\n\n```java\n[java@RCS-AS-01 root]$ jstack 16885 > /tmp/stack16885.1\n\n查看文件显示：\n2017-07-29 16:20:51\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.65-b01 mixed mode):\n\n\"HikariCP connection filler (pool HikariPool-11)\" #26011 daemon prio=5 os_prio=0 tid=0x0000000000f46000 nid=0x2bde waiting on condition [0x00007f334e8b4000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000c25016e8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n............\n```\n\n## 7.jhat\n\n### 7.1.简介　\n\n提供 jhat（ JVM Heap Analysis Tool） 命令 与 jmap 搭配 使用， 来 分析 jmap 生成 的 堆 转储 快照。\n命令格式：\n```java\n　jhat -J-Xmx512m <heap dump file>\n```\n备注:\njhat 内置 了 一个 微型 的 HTTP/ HTML 服务器， 生成 dump 文件 的 分析 结果 后， 可以 在 浏览器 中 查看。 不过 实事求是 地说， 在 实际 工作中， 除非 笔者 手上 真的 没有 别的 工具 可用， 否则 一般 都 不会 去 直接 使用 jhat 命令 来 分析 dump 文件， 主要原因 有 二： 一是 一般 不会 在 部署 应用 程序 的 服务器 上 直接 分析 dump 文件， 即使 可以 这样做， 也会 尽量 将dump 文件 拷贝 到 其他 机器[ 4] 上进 行 分析， 因为 分析 工作 是一 个 耗时 而且 消耗 硬件 资源 的 过程， 既然 都要 在 其他 机器 上 进行， 就 没 必要 受到 命令行 工具 的 限制 了。 另外 一个 原因 是 jhat 的 分析 功能 相对来说 比较 简陋， 后文 将会 介绍 到 的 VisualVM\n\n### 7.2.实例:\n\n1、产生dump文件 c:\\>jmap -dump:file=f:\\yown\\dump.bin   16912\nDumping heap to F:\\apps\\dump.txt ...\nHeap dump file created\n\n2、生成站点分析报告，便于网络访问 c:\\>jhat -J-Xmx512m -port 88f:\\yown\\dump.bin\n```\nReading from f:\\apps\\dump.bin...\nDump file created Thu Jul 26 16:31:36 CST 2012\nSnapshot read, resolving...\nResolving 2194971 objects...\nChasing references, expect 438 dots.............................................\n................................................................................\n................................................................................\n................................................................................\n................................................................................\n.........................................................................\nEliminating duplicate references................................................\n................................................................................\n................................................................................\n................................................................................\n................................................................................\n......................................................................\nSnapshot resolved.\nStarted HTTP server on port 88\nServer is ready. 3.访问 http://localhost:88/ 这里记录了进程中所有类及实例个数\n```\n\n## 8.jvisualvm\n\n### 8.1.简介:\n\nVisualVM（ All- in- One Java Troubleshooting Tool） 是 到 目前 为止， 随 JDK 发布 的 功能 最强 大的 运行 监视 和 故障 处理 程序， 并且 可以 预见 在 未来 一段时间 内 都是 官方 主力 发展 的 虚拟 机 故障 处理 工具。 官方 在 VisualVM 的 软件 说明 中写 上了“ All- in- One” 的 描述 字样， 预示 着 它 除了 运行 监视、 故障 处理 外， 还 提供 了 很多 其他 方面 的 功能。VisualVM 基于 NetBeans 平台 开发， 因此 它 一 开始 就 具备 了 插件 扩展 功能 的 特性， 通过 插件 扩展 支持， VisualVM 可以 做到：\n·显示 虚拟 机 进程 及 进程 的 配置 和 环境 信息（ jps、 jinfo）\n·监视 应用 程序 的 CPU、 GC、 堆、 方法 区 及 线程 的 信息（ jstat、 jstack）。\n·dump 及 分析 堆 转储 快照（ jmap、 jhat）\n·方法 级 的 程序 运行 性能 分析， 找出 被 调用 最多、 运行 时间 最长 的 方法\n·离 线程 序 快照： 收集 程序 的 运行时 配置、 线程 dump、 内存 dump 等 信息 建立 一个 快照， 可以 将 快照 发送 开发者 处 进行 Bug 反馈。\n·其他 plugins 的 无限 的 可能性\n\n### 8.2.界面展示如下图\n\n![这里写图片描述](http://img.blog.csdn.net/20170729163459058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20170729163624195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 9.开启Java服务远程监控\n### 9.1.启动脚本中添加如下参数\n```ruby\nJAVA_ARGS[2]=\"-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=10.10.220.101\"\n```\n### 9.2.通过jvisualvm可以监控远程java服务，如下：\n![这里写图片描述](http://img.blog.csdn.net/20170729163143819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n","slug":"language/jvm/JVM性能监控及故障分析工具","published":1,"date":"2021-07-31T09:04:32.022Z","updated":"2021-07-31T09:04:32.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrjv2c4000sy2uke5j158ch","content":"<h1 id=\"JVM-性能监控及故障分析工具\"><a href=\"#JVM-性能监控及故障分析工具\" class=\"headerlink\" title=\"JVM 性能监控及故障分析工具\"></a>JVM 性能监控及故障分析工具</h1><h2 id=\"1-概要\"><a href=\"#1-概要\" class=\"headerlink\" title=\"1.概要\"></a>1.概要</h2><p>JDK官方提供了不少好用的JAVA故障处理工具,JDK的命令行工具在JDK的bin目录下供用户使用。</p>\n<h2 id=\"２-jps\"><a href=\"#２-jps\" class=\"headerlink\" title=\"２.jps\"></a>２.jps</h2><h3 id=\"２-1-简介\"><a href=\"#２-1-简介\" class=\"headerlink\" title=\"２.1.简介\"></a>２.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [options] [hostid] </span><br></pre></td></tr></table></figure>\n<p>options 参数详解:<br>参数 | 解释<br>—-| —-<br> -q | 仅输出VM标识符，不包括classname,jar name,arguments in main method<br> -m | 输出main method的参数<br> -l | 输出完全的包名，应用主类名，jar的完全路径名<br> -v | 输出jvm参数<br> -V | 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件<br> -J | 传递参数到vm,例如:-J-Xms512m<br>hostid 参数解释:<br>[protocol:][[//]hostname][:port][/servername]</p>\n<h3 id=\"２-２-实例\"><a href=\"#２-２-实例\" class=\"headerlink\" title=\"２.２.实例\"></a>２.２.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps</span><br><span class=\"line\"><span class=\"number\">3201</span> Jps</span><br><span class=\"line\"><span class=\"number\">20819</span> AuthBootstrap</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps -lv</span><br><span class=\"line\"><span class=\"number\">20819</span> com.feinno.urcs.auth.main.AuthBootstrap -Duser.dir=/home/urcs/urcs-as-authentication -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps -lvm <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span></span><br><span class=\"line\">RMI Registry not available at <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span>:<span class=\"number\">1099</span></span><br><span class=\"line\">Connection refused to host: <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span>; nested exception is:java.net.ConnectException: Connection refused。</span><br><span class=\"line\">需要在远程机器上开启：jstatd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-jstat\"><a href=\"#3-jstat\" class=\"headerlink\" title=\"3.jstat\"></a>3.jstat</h2><h3 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1.简介\"></a>3.1.简介</h3><p>Jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于Java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [options]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-options-参数详解\"><a href=\"#3-2-options-参数详解\" class=\"headerlink\" title=\"3.2.options 参数详解:\"></a>3.2.options 参数详解:</h3><ul>\n<li>3.2.1. jstat -class <pid> : 显示加载 class 的数量,及所占空间等信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Loaded</td>\n<td>装载的类的数量</td>\n</tr>\n<tr>\n<td>Bytes</td>\n<td>装载类所占用的字节数</td>\n</tr>\n<tr>\n<td>Unloaded</td>\n<td>卸载类的数量</td>\n</tr>\n<tr>\n<td>Bytes</td>\n<td>卸载类的字节数</td>\n</tr>\n<tr>\n<td>Time</td>\n<td>装载和卸载类所花费的时间</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.2.jstat -compiler <pid>:显示 VM 实时编译的数量等信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compiled</td>\n<td>编译任务执行数量</td>\n</tr>\n<tr>\n<td>Failed</td>\n<td>编译任务执行失败数量</td>\n</tr>\n<tr>\n<td>Invalid</td>\n<td>编译任务执行失效数量</td>\n</tr>\n<tr>\n<td>Time</td>\n<td>编译任务消耗时间</td>\n</tr>\n<tr>\n<td>FailedType</td>\n<td>最后一个编译失败任务的类型</td>\n</tr>\n<tr>\n<td>FailedMethod</td>\n<td>最后一个编译失败任务所在的类及方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.3.jstat -gc <pid>: 可以显示 gc 的信息,查看 gc 的次数,及时间,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S0U</td>\n<td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>S1U</td>\n<td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>EU</td>\n<td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>OU</td>\n<td>Old 代目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>PU</td>\n<td>Perm(持久代)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li> 3.2.4. jstat -gccapacity <pid>:可以显示,VM 内存中三代(young,old,perm)对象的使用和占用大小</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NGCMN</td>\n<td>年轻代(young)中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>NGCMX</td>\n<td>年轻代(young)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>NGC</td>\n<td>年轻代(young)中当前的容量(字节)</td>\n</tr>\n<tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>OGCMN</td>\n<td>old 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>OGCMX</td>\n<td>old 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>OGC</td>\n<td>old 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>PGCMN</td>\n<td>perm 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>PGCMX</td>\n<td>perm 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>PGC</td>\n<td>perm 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.5.jstat -gcutil <pid>:统计 gc 信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0</td>\n<td>年轻代中第一个 survivor(幸存区)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>S1</td>\n<td>年轻代中第二个 survivor(幸存区)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>E</td>\n<td>年轻代中 Eden(伊甸园)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>O</td>\n<td>old 代已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>P</td>\n<td>perm 代已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.6. jstat -gcnew <pid>:年轻代对象的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S0U</td>\n<td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>S1U</td>\n<td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>TT</td>\n<td>持有次数限制</td>\n</tr>\n<tr>\n<td>MTT</td>\n<td>最大持有次数限制</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>EU</td>\n<td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.7. jstat -gcnewcapacity <pid>: 年轻代对象的信息及其占用量,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NGCMN</td>\n<td>年轻代(young)中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>NGCMX</td>\n<td>年轻代(young)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>NGC</td>\n<td>年轻代(young)中当前的容量(字节)</td>\n</tr>\n<tr>\n<td>S0CMX</td>\n<td>年轻代中第一个 survivor(幸存区)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1CMX</td>\n<td>年轻代中第二个 survivor(幸存区)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>ECMX</td>\n<td>年轻代中 Eden(伊甸园)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.8. jstat -gcold <pid>:old 代对象的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>PU</td>\n<td>Perm(持久代)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>OU</td>\n<td>Old 代目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.9.stat -gcoldcapacity <pid>: old 代对象的信息及其占用量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OGCMN</td>\n<td>old 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>OGCMX</td>\n<td>old 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>OGC</td>\n<td>old 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.10. jstat -gcpermcapacity<pid>: perm 对象的信息及其占用量,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PGCMN</td>\n<td>perm 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>PGCMX</td>\n<td>perm 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>PGC</td>\n<td>perm 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.11. jstat -printcompilation <pid>:当前 VM 执行的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compiled</td>\n<td>编译任务的数目</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>方法生成的字节码的大小</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>编译类型</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>类名和方法名用来标识编译的方法,类名使用/做为一个命名空间分隔符,方法名是给定类中的方法,上述格式是由-XX:+PrintComplation 选项进行设置的</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-实例\"><a href=\"#3-3-实例\" class=\"headerlink\" title=\"3.3.实例:\"></a>3.3.实例:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstat -gcutil <span class=\"number\">16885</span> <span class=\"number\">1000</span></span><br><span class=\"line\">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">  <span class=\"number\">0.00</span>  <span class=\"number\">93.51</span>  <span class=\"number\">54.24</span>  <span class=\"number\">10.36</span>  <span class=\"number\">98.25</span>  <span class=\"number\">96.86</span>    <span class=\"number\">205</span>   <span class=\"number\">16.720</span>     <span class=\"number\">3</span>    <span class=\"number\">1.041</span>   <span class=\"number\">17.760</span></span><br><span class=\"line\">  <span class=\"number\">0.00</span>  <span class=\"number\">93.51</span>  <span class=\"number\">54.24</span>  <span class=\"number\">10.36</span>  <span class=\"number\">98.25</span>  <span class=\"number\">96.86</span>    <span class=\"number\">205</span>   <span class=\"number\">16.720</span>     <span class=\"number\">3</span>    <span class=\"number\">1.041</span>   <span class=\"number\">17.760</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstat -<span class=\"class\"><span class=\"keyword\">class</span> 16885 1000</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Loaded</span>  <span class=\"title\">Bytes</span>  <span class=\"title\">Unloaded</span>  <span class=\"title\">Bytes</span>     <span class=\"title\">Time</span></span></span><br><span class=\"line\"><span class=\"class\"> 10051 19327.1       32    44.2      27.15</span></span><br><span class=\"line\"><span class=\"class\"> 10051 19327.1       32    44.2      27.15</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-jinfo\"><a href=\"#4-jinfo\" class=\"headerlink\" title=\"4.jinfo\"></a>4.jinfo</h2><h3 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1.简介\"></a>4.1.简介</h3><p>jinfo(Java Configuration Information)，主要用于查看指定Java进程(或核心文件、远程调试服务器)的Java配置信息。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [options] pid</span><br><span class=\"line\">jinfo [options] executable core</span><br><span class=\"line\">jinfo [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n\n<p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p>\n<p>options 参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no option</td>\n<td>打印命令行参数和系统属性</td>\n</tr>\n<tr>\n<td>-flags</td>\n<td>打印命令行参数</td>\n</tr>\n<tr>\n<td>-sysprops</td>\n<td>打印系统属性</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>帮助</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-2-实例\"><a href=\"#4-2-实例\" class=\"headerlink\" title=\"4.2.实例\"></a>4.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jinfo <span class=\"number\">16885</span></span><br><span class=\"line\">Attaching to process ID <span class=\"number\">16885</span>, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">Java System Properties:</span><br><span class=\"line\">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class=\"line\">java.vm.version = <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">sun.boot.library.path = /usr/local/jdk8u65/jre/lib/amd64</span><br><span class=\"line\">java.vendor.url = http:<span class=\"comment\">//java.oracle.com/</span></span><br><span class=\"line\">java.vm.vendor = Oracle Corporation</span><br><span class=\"line\">path.separator = :</span><br><span class=\"line\">file.encoding.pkg = sun.io</span><br><span class=\"line\">java.vm.name = <span class=\"function\">Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server VM</span></span><br><span class=\"line\"><span class=\"function\">.....</span></span><br><span class=\"line\"><span class=\"function\">VM Flags:</span></span><br><span class=\"line\"><span class=\"function\">Non-<span class=\"keyword\">default</span> VM flags: -XX:CICompilerCount</span>=<span class=\"number\">2</span> -XX:InitialHeapSize=<span class=\"number\">1073741824</span> -XX:MaxHeapSize=<span class=\"number\">1073741824</span> -XX:MaxNewSize=<span class=\"number\">357564416</span> -XX:MinHeapDeltaBytes=<span class=\"number\">524288</span> -XX:NewSize=<span class=\"number\">357564416</span> -XX:OldSize=<span class=\"number\">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class=\"line\">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jinfo -flags <span class=\"number\">16885</span></span><br><span class=\"line\">Attaching to process ID <span class=\"number\">16885</span>, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">Non-<span class=\"keyword\">default</span> VM flags: -XX:CICompilerCount=<span class=\"number\">2</span> -XX:InitialHeapSize=<span class=\"number\">1073741824</span> -XX:MaxHeapSize=<span class=\"number\">1073741824</span> -XX:MaxNewSize=<span class=\"number\">357564416</span> -XX:MinHeapDeltaBytes=<span class=\"number\">524288</span> -XX:NewSize=<span class=\"number\">357564416</span> -XX:OldSize=<span class=\"number\">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class=\"line\">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-jmap\"><a href=\"#5-jmap\" class=\"headerlink\" title=\"5.jmap\"></a>5.jmap</h2><h3 id=\"5-1-简介\"><a href=\"#5-1-简介\" class=\"headerlink\" title=\"5.1.简介\"></a>5.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [options] pid</span><br><span class=\"line\">jmap [options] executable core</span><br><span class=\"line\">jmap [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n<p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p>\n<p>options 参数详解:<br>参数 | 解释<br>—-| —-<br>-dump:[live,]format=b,file=<filename> | 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.<br>-finalizerinfo | 打印正等候回收的对象的信息.<br>-heap  | 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.<br>-histo[:live] | 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.<br>-permstat | 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.<br>-F | 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效.<br>-h | -help 打印辅助信息<br>-J | 传递参数给jmap启动的jvm.</p>\n<h3 id=\"5-2-实例\"><a href=\"#5-2-实例\" class=\"headerlink\" title=\"5.2.实例\"></a>5.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jmap -dump:live,format=b,file=/tmp/heap.dump <span class=\"number\">16885</span></span><br><span class=\"line\">Dumping heap to /tmp/heap.dump ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-jstack\"><a href=\"#6-jstack\" class=\"headerlink\" title=\"6.jstack\"></a>6.jstack</h2><h3 id=\"6-1-简介\"><a href=\"#6-1-简介\" class=\"headerlink\" title=\"6.1.简介\"></a>6.1.简介</h3><p>jstack（ Stack Trace for Java） 命令 用于 生成 虚拟 机 当前 时刻 的 线程 快照（ 一般 称为 threaddump 或 javacore 文件）。 线程 快照 就是 当前 虚拟 机内 每一 条 线程 正在 执行 的 方法 堆栈 的 集合， 生成 线程 快照 的 主要 目的 是 定位 线程 出现 长时间 停顿 的 原因， 如 线程间死锁,死 循环,请求 外部 资源 导致 的 长时间 等待 等 都是 导致 线程 长时间 停顿 的 常见 原因。</p>\n<p>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [options] pid</span><br><span class=\"line\">jstack [options] executable core</span><br><span class=\"line\">jstack [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n\n<p>参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pid</td>\n<td>进程号</td>\n</tr>\n<tr>\n<td>executable</td>\n<td>产生 core dump 的 java executable</td>\n</tr>\n<tr>\n<td>core</td>\n<td>core file</td>\n</tr>\n<tr>\n<td>remote-hostname-or-IP</td>\n<td>主机名或 ip</td>\n</tr>\n<tr>\n<td>server-id</td>\n<td>远程主机上的 debug server 的唯一 id</td>\n</tr>\n</tbody></table>\n<p>options 参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-F</td>\n<td>当 jstack [-l] pid 没有相应的时候强制打印栈信息</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>长列表. 打印关于锁的附加信息,例如属于 java.util.concurrent 的 ownable synchronizers 列表.</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>打印 java 和 native c/c++框架的所有栈信息.</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>-help 打印帮助信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-2-实例\"><a href=\"#6-2-实例\" class=\"headerlink\" title=\"6.2.实例\"></a>6.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstack <span class=\"number\">16885</span> &gt; /tmp/stack16885<span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">查看文件显示：</span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">07</span>-<span class=\"number\">29</span> <span class=\"number\">16</span>:<span class=\"number\">20</span>:<span class=\"number\">51</span></span><br><span class=\"line\"><span class=\"function\">Full thread dump Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server <span class=\"title\">VM</span> <span class=\"params\">(<span class=\"number\">25.65</span>-b01 mixed mode)</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">&quot;HikariCP connection <span class=\"title\">filler</span> <span class=\"params\">(pool HikariPool-<span class=\"number\">11</span>)</span>&quot; #26011 daemon prio</span>=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x0000000000f46000</span> nid=<span class=\"number\">0x2bde</span> waiting on condition [<span class=\"number\">0x00007f334e8b4000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class=\"line\">        at sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">        - parking to wait <span class=\"keyword\">for</span>  &lt;<span class=\"number\">0x00000000c25016e8</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class=\"line\">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class=\"number\">215</span>)</span><br><span class=\"line\">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:<span class=\"number\">2078</span>)</span><br><span class=\"line\">        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:<span class=\"number\">467</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class=\"number\">1066</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class=\"number\">1127</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class=\"number\">617</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\">............</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-jhat\"><a href=\"#7-jhat\" class=\"headerlink\" title=\"7.jhat\"></a>7.jhat</h2><h3 id=\"7-1-简介\"><a href=\"#7-1-简介\" class=\"headerlink\" title=\"7.1.简介\"></a>7.1.简介</h3><p>提供 jhat（ JVM Heap Analysis Tool） 命令 与 jmap 搭配 使用， 来 分析 jmap 生成 的 堆 转储 快照。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　jhat -J-Xmx512m &lt;heap dump file&gt;</span><br></pre></td></tr></table></figure>\n<p>备注:<br>jhat 内置 了 一个 微型 的 HTTP/ HTML 服务器， 生成 dump 文件 的 分析 结果 后， 可以 在 浏览器 中 查看。 不过 实事求是 地说， 在 实际 工作中， 除非 笔者 手上 真的 没有 别的 工具 可用， 否则 一般 都 不会 去 直接 使用 jhat 命令 来 分析 dump 文件， 主要原因 有 二： 一是 一般 不会 在 部署 应用 程序 的 服务器 上 直接 分析 dump 文件， 即使 可以 这样做， 也会 尽量 将dump 文件 拷贝 到 其他 机器[ 4] 上进 行 分析， 因为 分析 工作 是一 个 耗时 而且 消耗 硬件 资源 的 过程， 既然 都要 在 其他 机器 上 进行， 就 没 必要 受到 命令行 工具 的 限制 了。 另外 一个 原因 是 jhat 的 分析 功能 相对来说 比较 简陋， 后文 将会 介绍 到 的 VisualVM</p>\n<h3 id=\"7-2-实例\"><a href=\"#7-2-实例\" class=\"headerlink\" title=\"7.2.实例:\"></a>7.2.实例:</h3><p>1、产生dump文件 c:&gt;jmap -dump:file=f:\\yown\\dump.bin   16912<br>Dumping heap to F:\\apps\\dump.txt …<br>Heap dump file created</p>\n<p>2、生成站点分析报告，便于网络访问 c:&gt;jhat -J-Xmx512m -port 88f:\\yown\\dump.bin</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reading from f:\\apps\\dump.bin...</span><br><span class=\"line\">Dump file created Thu Jul 26 16:31:36 CST 2012</span><br><span class=\"line\">Snapshot read, resolving...</span><br><span class=\"line\">Resolving 2194971 objects...</span><br><span class=\"line\">Chasing references, expect 438 dots.............................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">.........................................................................</span><br><span class=\"line\">Eliminating duplicate references................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">......................................................................</span><br><span class=\"line\">Snapshot resolved.</span><br><span class=\"line\">Started HTTP server on port 88</span><br><span class=\"line\">Server is ready. 3.访问 http://localhost:88/ 这里记录了进程中所有类及实例个数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-jvisualvm\"><a href=\"#8-jvisualvm\" class=\"headerlink\" title=\"8.jvisualvm\"></a>8.jvisualvm</h2><h3 id=\"8-1-简介\"><a href=\"#8-1-简介\" class=\"headerlink\" title=\"8.1.简介:\"></a>8.1.简介:</h3><p>VisualVM（ All- in- One Java Troubleshooting Tool） 是 到 目前 为止， 随 JDK 发布 的 功能 最强 大的 运行 监视 和 故障 处理 程序， 并且 可以 预见 在 未来 一段时间 内 都是 官方 主力 发展 的 虚拟 机 故障 处理 工具。 官方 在 VisualVM 的 软件 说明 中写 上了“ All- in- One” 的 描述 字样， 预示 着 它 除了 运行 监视、 故障 处理 外， 还 提供 了 很多 其他 方面 的 功能。VisualVM 基于 NetBeans 平台 开发， 因此 它 一 开始 就 具备 了 插件 扩展 功能 的 特性， 通过 插件 扩展 支持， VisualVM 可以 做到：<br>·显示 虚拟 机 进程 及 进程 的 配置 和 环境 信息（ jps、 jinfo）<br>·监视 应用 程序 的 CPU、 GC、 堆、 方法 区 及 线程 的 信息（ jstat、 jstack）。<br>·dump 及 分析 堆 转储 快照（ jmap、 jhat）<br>·方法 级 的 程序 运行 性能 分析， 找出 被 调用 最多、 运行 时间 最长 的 方法<br>·离 线程 序 快照： 收集 程序 的 运行时 配置、 线程 dump、 内存 dump 等 信息 建立 一个 快照， 可以 将 快照 发送 开发者 处 进行 Bug 反馈。<br>·其他 plugins 的 无限 的 可能性</p>\n<h3 id=\"8-2-界面展示如下图\"><a href=\"#8-2-界面展示如下图\" class=\"headerlink\" title=\"8.2.界面展示如下图\"></a>8.2.界面展示如下图</h3><p><img src=\"http://img.blog.csdn.net/20170729163459058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170729163624195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"9-开启Java服务远程监控\"><a href=\"#9-开启Java服务远程监控\" class=\"headerlink\" title=\"9.开启Java服务远程监控\"></a>9.开启Java服务远程监控</h2><h3 id=\"9-1-启动脚本中添加如下参数\"><a href=\"#9-1-启动脚本中添加如下参数\" class=\"headerlink\" title=\"9.1.启动脚本中添加如下参数\"></a>9.1.启动脚本中添加如下参数</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_ARGS[<span class=\"number\">2</span>]=<span class=\"string\">&quot;-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=10.10.220.101&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-2-通过jvisualvm可以监控远程java服务，如下：\"><a href=\"#9-2-通过jvisualvm可以监控远程java服务，如下：\" class=\"headerlink\" title=\"9.2.通过jvisualvm可以监控远程java服务，如下：\"></a>9.2.通过jvisualvm可以监控远程java服务，如下：</h3><p><img src=\"http://img.blog.csdn.net/20170729163143819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JVM-性能监控及故障分析工具\"><a href=\"#JVM-性能监控及故障分析工具\" class=\"headerlink\" title=\"JVM 性能监控及故障分析工具\"></a>JVM 性能监控及故障分析工具</h1><h2 id=\"1-概要\"><a href=\"#1-概要\" class=\"headerlink\" title=\"1.概要\"></a>1.概要</h2><p>JDK官方提供了不少好用的JAVA故障处理工具,JDK的命令行工具在JDK的bin目录下供用户使用。</p>\n<h2 id=\"２-jps\"><a href=\"#２-jps\" class=\"headerlink\" title=\"２.jps\"></a>２.jps</h2><h3 id=\"２-1-简介\"><a href=\"#２-1-简介\" class=\"headerlink\" title=\"２.1.简介\"></a>２.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [options] [hostid] </span><br></pre></td></tr></table></figure>\n<p>options 参数详解:<br>参数 | 解释<br>—-| —-<br> -q | 仅输出VM标识符，不包括classname,jar name,arguments in main method<br> -m | 输出main method的参数<br> -l | 输出完全的包名，应用主类名，jar的完全路径名<br> -v | 输出jvm参数<br> -V | 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件<br> -J | 传递参数到vm,例如:-J-Xms512m<br>hostid 参数解释:<br>[protocol:][[//]hostname][:port][/servername]</p>\n<h3 id=\"２-２-实例\"><a href=\"#２-２-实例\" class=\"headerlink\" title=\"２.２.实例\"></a>２.２.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps</span><br><span class=\"line\"><span class=\"number\">3201</span> Jps</span><br><span class=\"line\"><span class=\"number\">20819</span> AuthBootstrap</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps -lv</span><br><span class=\"line\"><span class=\"number\">20819</span> com.feinno.urcs.auth.main.AuthBootstrap -Duser.dir=/home/urcs/urcs-as-authentication -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jps -lvm <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span></span><br><span class=\"line\">RMI Registry not available at <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span>:<span class=\"number\">1099</span></span><br><span class=\"line\">Connection refused to host: <span class=\"number\">10.10</span><span class=\"number\">.220</span><span class=\"number\">.101</span>; nested exception is:java.net.ConnectException: Connection refused。</span><br><span class=\"line\">需要在远程机器上开启：jstatd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-jstat\"><a href=\"#3-jstat\" class=\"headerlink\" title=\"3.jstat\"></a>3.jstat</h2><h3 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1.简介\"></a>3.1.简介</h3><p>Jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于Java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [options]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-options-参数详解\"><a href=\"#3-2-options-参数详解\" class=\"headerlink\" title=\"3.2.options 参数详解:\"></a>3.2.options 参数详解:</h3><ul>\n<li>3.2.1. jstat -class <pid> : 显示加载 class 的数量,及所占空间等信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Loaded</td>\n<td>装载的类的数量</td>\n</tr>\n<tr>\n<td>Bytes</td>\n<td>装载类所占用的字节数</td>\n</tr>\n<tr>\n<td>Unloaded</td>\n<td>卸载类的数量</td>\n</tr>\n<tr>\n<td>Bytes</td>\n<td>卸载类的字节数</td>\n</tr>\n<tr>\n<td>Time</td>\n<td>装载和卸载类所花费的时间</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.2.jstat -compiler <pid>:显示 VM 实时编译的数量等信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compiled</td>\n<td>编译任务执行数量</td>\n</tr>\n<tr>\n<td>Failed</td>\n<td>编译任务执行失败数量</td>\n</tr>\n<tr>\n<td>Invalid</td>\n<td>编译任务执行失效数量</td>\n</tr>\n<tr>\n<td>Time</td>\n<td>编译任务消耗时间</td>\n</tr>\n<tr>\n<td>FailedType</td>\n<td>最后一个编译失败任务的类型</td>\n</tr>\n<tr>\n<td>FailedMethod</td>\n<td>最后一个编译失败任务所在的类及方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.3.jstat -gc <pid>: 可以显示 gc 的信息,查看 gc 的次数,及时间,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S0U</td>\n<td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>S1U</td>\n<td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>EU</td>\n<td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>OU</td>\n<td>Old 代目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>PU</td>\n<td>Perm(持久代)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li> 3.2.4. jstat -gccapacity <pid>:可以显示,VM 内存中三代(young,old,perm)对象的使用和占用大小</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NGCMN</td>\n<td>年轻代(young)中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>NGCMX</td>\n<td>年轻代(young)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>NGC</td>\n<td>年轻代(young)中当前的容量(字节)</td>\n</tr>\n<tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>OGCMN</td>\n<td>old 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>OGCMX</td>\n<td>old 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>OGC</td>\n<td>old 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>PGCMN</td>\n<td>perm 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>PGCMX</td>\n<td>perm 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>PGC</td>\n<td>perm 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.5.jstat -gcutil <pid>:统计 gc 信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0</td>\n<td>年轻代中第一个 survivor(幸存区)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>S1</td>\n<td>年轻代中第二个 survivor(幸存区)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>E</td>\n<td>年轻代中 Eden(伊甸园)已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>O</td>\n<td>old 代已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>P</td>\n<td>perm 代已使用的占当前容量百分比</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.6. jstat -gcnew <pid>:年轻代对象的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S0U</td>\n<td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>S1U</td>\n<td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>TT</td>\n<td>持有次数限制</td>\n</tr>\n<tr>\n<td>MTT</td>\n<td>最大持有次数限制</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n<tr>\n<td>EU</td>\n<td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>YGCT</td>\n<td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.7. jstat -gcnewcapacity <pid>: 年轻代对象的信息及其占用量,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NGCMN</td>\n<td>年轻代(young)中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>NGCMX</td>\n<td>年轻代(young)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>NGC</td>\n<td>年轻代(young)中当前的容量(字节)</td>\n</tr>\n<tr>\n<td>S0CMX</td>\n<td>年轻代中第一个 survivor(幸存区)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>S0C</td>\n<td>年轻代中第一个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>S1CMX</td>\n<td>年轻代中第二个 survivor(幸存区)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>S1C</td>\n<td>年轻代中第二个 survivor(幸存区)的容量(字节)</td>\n</tr>\n<tr>\n<td>ECMX</td>\n<td>年轻代中 Eden(伊甸园)的最大容量(字节)</td>\n</tr>\n<tr>\n<td>EC</td>\n<td>年轻代中 Eden(伊甸园)的容量(字节)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.8. jstat -gcold <pid>:old 代对象的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>PU</td>\n<td>Perm(持久代)目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>OU</td>\n<td>Old 代目前已使用空间(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.9.stat -gcoldcapacity <pid>: old 代对象的信息及其占用量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OGCMN</td>\n<td>old 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>OGCMX</td>\n<td>old 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>OGC</td>\n<td>old 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>OC</td>\n<td>Old 代的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.10. jstat -gcpermcapacity<pid>: perm 对象的信息及其占用量,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PGCMN</td>\n<td>perm 代中初始化(最小)的大小(字节)</td>\n</tr>\n<tr>\n<td>PGCMX</td>\n<td>perm 代的最大容量(字节)</td>\n</tr>\n<tr>\n<td>PGC</td>\n<td>perm 代当前新生成的容量(字节)</td>\n</tr>\n<tr>\n<td>PC</td>\n<td>Perm(持久代)的容量(字节)</td>\n</tr>\n<tr>\n<td>YGC</td>\n<td>从应用程序启动到采样时年轻代中 gc 次数</td>\n</tr>\n<tr>\n<td>FGC</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td>\n</tr>\n<tr>\n<td>FGCT</td>\n<td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td>\n</tr>\n<tr>\n<td>GCT</td>\n<td>从应用程序启动到采样时 gc 用的总时间(s)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3.2.11. jstat -printcompilation <pid>:当前 VM 执行的信息,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>显示列名</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compiled</td>\n<td>编译任务的数目</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>方法生成的字节码的大小</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>编译类型</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>类名和方法名用来标识编译的方法,类名使用/做为一个命名空间分隔符,方法名是给定类中的方法,上述格式是由-XX:+PrintComplation 选项进行设置的</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-实例\"><a href=\"#3-3-实例\" class=\"headerlink\" title=\"3.3.实例:\"></a>3.3.实例:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstat -gcutil <span class=\"number\">16885</span> <span class=\"number\">1000</span></span><br><span class=\"line\">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">  <span class=\"number\">0.00</span>  <span class=\"number\">93.51</span>  <span class=\"number\">54.24</span>  <span class=\"number\">10.36</span>  <span class=\"number\">98.25</span>  <span class=\"number\">96.86</span>    <span class=\"number\">205</span>   <span class=\"number\">16.720</span>     <span class=\"number\">3</span>    <span class=\"number\">1.041</span>   <span class=\"number\">17.760</span></span><br><span class=\"line\">  <span class=\"number\">0.00</span>  <span class=\"number\">93.51</span>  <span class=\"number\">54.24</span>  <span class=\"number\">10.36</span>  <span class=\"number\">98.25</span>  <span class=\"number\">96.86</span>    <span class=\"number\">205</span>   <span class=\"number\">16.720</span>     <span class=\"number\">3</span>    <span class=\"number\">1.041</span>   <span class=\"number\">17.760</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstat -<span class=\"class\"><span class=\"keyword\">class</span> 16885 1000</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Loaded</span>  <span class=\"title\">Bytes</span>  <span class=\"title\">Unloaded</span>  <span class=\"title\">Bytes</span>     <span class=\"title\">Time</span></span></span><br><span class=\"line\"><span class=\"class\"> 10051 19327.1       32    44.2      27.15</span></span><br><span class=\"line\"><span class=\"class\"> 10051 19327.1       32    44.2      27.15</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-jinfo\"><a href=\"#4-jinfo\" class=\"headerlink\" title=\"4.jinfo\"></a>4.jinfo</h2><h3 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1.简介\"></a>4.1.简介</h3><p>jinfo(Java Configuration Information)，主要用于查看指定Java进程(或核心文件、远程调试服务器)的Java配置信息。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [options] pid</span><br><span class=\"line\">jinfo [options] executable core</span><br><span class=\"line\">jinfo [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n\n<p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p>\n<p>options 参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no option</td>\n<td>打印命令行参数和系统属性</td>\n</tr>\n<tr>\n<td>-flags</td>\n<td>打印命令行参数</td>\n</tr>\n<tr>\n<td>-sysprops</td>\n<td>打印系统属性</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>帮助</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-2-实例\"><a href=\"#4-2-实例\" class=\"headerlink\" title=\"4.2.实例\"></a>4.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jinfo <span class=\"number\">16885</span></span><br><span class=\"line\">Attaching to process ID <span class=\"number\">16885</span>, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">Java System Properties:</span><br><span class=\"line\">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class=\"line\">java.vm.version = <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">sun.boot.library.path = /usr/local/jdk8u65/jre/lib/amd64</span><br><span class=\"line\">java.vendor.url = http:<span class=\"comment\">//java.oracle.com/</span></span><br><span class=\"line\">java.vm.vendor = Oracle Corporation</span><br><span class=\"line\">path.separator = :</span><br><span class=\"line\">file.encoding.pkg = sun.io</span><br><span class=\"line\">java.vm.name = <span class=\"function\">Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server VM</span></span><br><span class=\"line\"><span class=\"function\">.....</span></span><br><span class=\"line\"><span class=\"function\">VM Flags:</span></span><br><span class=\"line\"><span class=\"function\">Non-<span class=\"keyword\">default</span> VM flags: -XX:CICompilerCount</span>=<span class=\"number\">2</span> -XX:InitialHeapSize=<span class=\"number\">1073741824</span> -XX:MaxHeapSize=<span class=\"number\">1073741824</span> -XX:MaxNewSize=<span class=\"number\">357564416</span> -XX:MinHeapDeltaBytes=<span class=\"number\">524288</span> -XX:NewSize=<span class=\"number\">357564416</span> -XX:OldSize=<span class=\"number\">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class=\"line\">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jinfo -flags <span class=\"number\">16885</span></span><br><span class=\"line\">Attaching to process ID <span class=\"number\">16885</span>, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is <span class=\"number\">25.65</span>-b01</span><br><span class=\"line\">Non-<span class=\"keyword\">default</span> VM flags: -XX:CICompilerCount=<span class=\"number\">2</span> -XX:InitialHeapSize=<span class=\"number\">1073741824</span> -XX:MaxHeapSize=<span class=\"number\">1073741824</span> -XX:MaxNewSize=<span class=\"number\">357564416</span> -XX:MinHeapDeltaBytes=<span class=\"number\">524288</span> -XX:NewSize=<span class=\"number\">357564416</span> -XX:OldSize=<span class=\"number\">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class=\"line\">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-jmap\"><a href=\"#5-jmap\" class=\"headerlink\" title=\"5.jmap\"></a>5.jmap</h2><h3 id=\"5-1-简介\"><a href=\"#5-1-简介\" class=\"headerlink\" title=\"5.1.简介\"></a>5.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [options] pid</span><br><span class=\"line\">jmap [options] executable core</span><br><span class=\"line\">jmap [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n<p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p>\n<p>options 参数详解:<br>参数 | 解释<br>—-| —-<br>-dump:[live,]format=b,file=<filename> | 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.<br>-finalizerinfo | 打印正等候回收的对象的信息.<br>-heap  | 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.<br>-histo[:live] | 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.<br>-permstat | 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.<br>-F | 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效.<br>-h | -help 打印辅助信息<br>-J | 传递参数给jmap启动的jvm.</p>\n<h3 id=\"5-2-实例\"><a href=\"#5-2-实例\" class=\"headerlink\" title=\"5.2.实例\"></a>5.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jmap -dump:live,format=b,file=/tmp/heap.dump <span class=\"number\">16885</span></span><br><span class=\"line\">Dumping heap to /tmp/heap.dump ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-jstack\"><a href=\"#6-jstack\" class=\"headerlink\" title=\"6.jstack\"></a>6.jstack</h2><h3 id=\"6-1-简介\"><a href=\"#6-1-简介\" class=\"headerlink\" title=\"6.1.简介\"></a>6.1.简介</h3><p>jstack（ Stack Trace for Java） 命令 用于 生成 虚拟 机 当前 时刻 的 线程 快照（ 一般 称为 threaddump 或 javacore 文件）。 线程 快照 就是 当前 虚拟 机内 每一 条 线程 正在 执行 的 方法 堆栈 的 集合， 生成 线程 快照 的 主要 目的 是 定位 线程 出现 长时间 停顿 的 原因， 如 线程间死锁,死 循环,请求 外部 资源 导致 的 长时间 等待 等 都是 导致 线程 长时间 停顿 的 常见 原因。</p>\n<p>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [options] pid</span><br><span class=\"line\">jstack [options] executable core</span><br><span class=\"line\">jstack [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>\n\n<p>参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pid</td>\n<td>进程号</td>\n</tr>\n<tr>\n<td>executable</td>\n<td>产生 core dump 的 java executable</td>\n</tr>\n<tr>\n<td>core</td>\n<td>core file</td>\n</tr>\n<tr>\n<td>remote-hostname-or-IP</td>\n<td>主机名或 ip</td>\n</tr>\n<tr>\n<td>server-id</td>\n<td>远程主机上的 debug server 的唯一 id</td>\n</tr>\n</tbody></table>\n<p>options 参数详解:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-F</td>\n<td>当 jstack [-l] pid 没有相应的时候强制打印栈信息</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>长列表. 打印关于锁的附加信息,例如属于 java.util.concurrent 的 ownable synchronizers 列表.</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>打印 java 和 native c/c++框架的所有栈信息.</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>-help 打印帮助信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-2-实例\"><a href=\"#6-2-实例\" class=\"headerlink\" title=\"6.2.实例\"></a>6.2.实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java<span class=\"meta\">@RCS</span>-AS-<span class=\"number\">01</span> root]$ jstack <span class=\"number\">16885</span> &gt; /tmp/stack16885<span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">查看文件显示：</span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">07</span>-<span class=\"number\">29</span> <span class=\"number\">16</span>:<span class=\"number\">20</span>:<span class=\"number\">51</span></span><br><span class=\"line\"><span class=\"function\">Full thread dump Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server <span class=\"title\">VM</span> <span class=\"params\">(<span class=\"number\">25.65</span>-b01 mixed mode)</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">&quot;HikariCP connection <span class=\"title\">filler</span> <span class=\"params\">(pool HikariPool-<span class=\"number\">11</span>)</span>&quot; #26011 daemon prio</span>=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x0000000000f46000</span> nid=<span class=\"number\">0x2bde</span> waiting on condition [<span class=\"number\">0x00007f334e8b4000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class=\"line\">        at sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">        - parking to wait <span class=\"keyword\">for</span>  &lt;<span class=\"number\">0x00000000c25016e8</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class=\"line\">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class=\"number\">215</span>)</span><br><span class=\"line\">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:<span class=\"number\">2078</span>)</span><br><span class=\"line\">        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:<span class=\"number\">467</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class=\"number\">1066</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class=\"number\">1127</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class=\"number\">617</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\">............</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-jhat\"><a href=\"#7-jhat\" class=\"headerlink\" title=\"7.jhat\"></a>7.jhat</h2><h3 id=\"7-1-简介\"><a href=\"#7-1-简介\" class=\"headerlink\" title=\"7.1.简介\"></a>7.1.简介</h3><p>提供 jhat（ JVM Heap Analysis Tool） 命令 与 jmap 搭配 使用， 来 分析 jmap 生成 的 堆 转储 快照。<br>命令格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　jhat -J-Xmx512m &lt;heap dump file&gt;</span><br></pre></td></tr></table></figure>\n<p>备注:<br>jhat 内置 了 一个 微型 的 HTTP/ HTML 服务器， 生成 dump 文件 的 分析 结果 后， 可以 在 浏览器 中 查看。 不过 实事求是 地说， 在 实际 工作中， 除非 笔者 手上 真的 没有 别的 工具 可用， 否则 一般 都 不会 去 直接 使用 jhat 命令 来 分析 dump 文件， 主要原因 有 二： 一是 一般 不会 在 部署 应用 程序 的 服务器 上 直接 分析 dump 文件， 即使 可以 这样做， 也会 尽量 将dump 文件 拷贝 到 其他 机器[ 4] 上进 行 分析， 因为 分析 工作 是一 个 耗时 而且 消耗 硬件 资源 的 过程， 既然 都要 在 其他 机器 上 进行， 就 没 必要 受到 命令行 工具 的 限制 了。 另外 一个 原因 是 jhat 的 分析 功能 相对来说 比较 简陋， 后文 将会 介绍 到 的 VisualVM</p>\n<h3 id=\"7-2-实例\"><a href=\"#7-2-实例\" class=\"headerlink\" title=\"7.2.实例:\"></a>7.2.实例:</h3><p>1、产生dump文件 c:&gt;jmap -dump:file=f:\\yown\\dump.bin   16912<br>Dumping heap to F:\\apps\\dump.txt …<br>Heap dump file created</p>\n<p>2、生成站点分析报告，便于网络访问 c:&gt;jhat -J-Xmx512m -port 88f:\\yown\\dump.bin</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reading from f:\\apps\\dump.bin...</span><br><span class=\"line\">Dump file created Thu Jul 26 16:31:36 CST 2012</span><br><span class=\"line\">Snapshot read, resolving...</span><br><span class=\"line\">Resolving 2194971 objects...</span><br><span class=\"line\">Chasing references, expect 438 dots.............................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">.........................................................................</span><br><span class=\"line\">Eliminating duplicate references................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">................................................................................</span><br><span class=\"line\">......................................................................</span><br><span class=\"line\">Snapshot resolved.</span><br><span class=\"line\">Started HTTP server on port 88</span><br><span class=\"line\">Server is ready. 3.访问 http://localhost:88/ 这里记录了进程中所有类及实例个数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-jvisualvm\"><a href=\"#8-jvisualvm\" class=\"headerlink\" title=\"8.jvisualvm\"></a>8.jvisualvm</h2><h3 id=\"8-1-简介\"><a href=\"#8-1-简介\" class=\"headerlink\" title=\"8.1.简介:\"></a>8.1.简介:</h3><p>VisualVM（ All- in- One Java Troubleshooting Tool） 是 到 目前 为止， 随 JDK 发布 的 功能 最强 大的 运行 监视 和 故障 处理 程序， 并且 可以 预见 在 未来 一段时间 内 都是 官方 主力 发展 的 虚拟 机 故障 处理 工具。 官方 在 VisualVM 的 软件 说明 中写 上了“ All- in- One” 的 描述 字样， 预示 着 它 除了 运行 监视、 故障 处理 外， 还 提供 了 很多 其他 方面 的 功能。VisualVM 基于 NetBeans 平台 开发， 因此 它 一 开始 就 具备 了 插件 扩展 功能 的 特性， 通过 插件 扩展 支持， VisualVM 可以 做到：<br>·显示 虚拟 机 进程 及 进程 的 配置 和 环境 信息（ jps、 jinfo）<br>·监视 应用 程序 的 CPU、 GC、 堆、 方法 区 及 线程 的 信息（ jstat、 jstack）。<br>·dump 及 分析 堆 转储 快照（ jmap、 jhat）<br>·方法 级 的 程序 运行 性能 分析， 找出 被 调用 最多、 运行 时间 最长 的 方法<br>·离 线程 序 快照： 收集 程序 的 运行时 配置、 线程 dump、 内存 dump 等 信息 建立 一个 快照， 可以 将 快照 发送 开发者 处 进行 Bug 反馈。<br>·其他 plugins 的 无限 的 可能性</p>\n<h3 id=\"8-2-界面展示如下图\"><a href=\"#8-2-界面展示如下图\" class=\"headerlink\" title=\"8.2.界面展示如下图\"></a>8.2.界面展示如下图</h3><p><img src=\"http://img.blog.csdn.net/20170729163459058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170729163624195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"9-开启Java服务远程监控\"><a href=\"#9-开启Java服务远程监控\" class=\"headerlink\" title=\"9.开启Java服务远程监控\"></a>9.开启Java服务远程监控</h2><h3 id=\"9-1-启动脚本中添加如下参数\"><a href=\"#9-1-启动脚本中添加如下参数\" class=\"headerlink\" title=\"9.1.启动脚本中添加如下参数\"></a>9.1.启动脚本中添加如下参数</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_ARGS[<span class=\"number\">2</span>]=<span class=\"string\">&quot;-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=10.10.220.101&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-2-通过jvisualvm可以监控远程java服务，如下：\"><a href=\"#9-2-通过jvisualvm可以监控远程java服务，如下：\" class=\"headerlink\" title=\"9.2.通过jvisualvm可以监控远程java服务，如下：\"></a>9.2.通过jvisualvm可以监控远程java服务，如下：</h3><p><img src=\"http://img.blog.csdn.net/20170729163143819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckrrjv2bf0000y2ukdhi0ev7m","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2bw000ay2ukdob9bnw4"},{"post_id":"ckrrjv2bt0005y2uk7tk51izw","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2bx000cy2ukhxoxg5if"},{"post_id":"ckrrjv2bv0007y2uk585xbxab","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2by000ey2ukgv16fkwl"},{"post_id":"ckrrjv2bn0001y2ukf6b6216j","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2by000gy2uk77ya7ryl"},{"post_id":"ckrrjv2bv0008y2ukcxhk7of0","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2bz000iy2uk2rft730u"},{"post_id":"ckrrjv2bw000by2ukchsf7qww","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c0000ky2uk7p6g4m5x"},{"post_id":"ckrrjv2br0003y2ukec922snv","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c0000my2ukfcf12c7p"},{"post_id":"ckrrjv2bx000dy2ukh5ww9389","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c1000ny2ukevwxghxy"},{"post_id":"ckrrjv2by000fy2uk284y9jan","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c1000oy2uk4qos3kl9"},{"post_id":"ckrrjv2bz000hy2uk74un1jvu","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c1000py2uk0xdfdupi"},{"post_id":"ckrrjv2bz000jy2uke08y8hg1","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c1000qy2uk3xwwag55"},{"post_id":"ckrrjv2c0000ly2ukffoff5z1","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c1000ry2uk04wody1j"},{"post_id":"ckrrjv2c4000sy2uke5j158ch","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjv2c4000ty2ukace86dch"},{"post_id":"ckrrjv2bs0004y2uk0fi83apj","category_id":"ckrrjv2bp0002y2ukhwt65e56","_id":"ckrrjvvcd000uy2ukdjwi0wq8"}],"PostTag":[],"Tag":[]}}