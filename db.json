{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1}],"Cache":[{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"source/_posts/tool/hexo-config.md","hash":"f51d851b236c0d782dca3c11fe56fda71c7f88e4","modified":1627060503482},{"_id":"source/_posts/nav/kind.md","hash":"0687bf53013de0a7a65471964678f4a541cc145e","modified":1627056987984},{"_id":"source/_posts/language/readme.md","hash":"afcafa087506ff2189f5765677e106e1e8d09885","modified":1627056987983},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":499162500000},{"_id":"source/_posts/tool/hexo-install.md","hash":"fbdefa30beb3e8754ea0d95ced56138220f7b2e1","modified":1627060503485},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"b87737dd30d2eaa5b240b196c55cc8d52ffba75c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"e5b9b369bbcf90c199a65a877eb75fba05cd7f90","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":499162500000},{"_id":"source/_posts/language/java/深入理解单例模式-静态内部类单例原理.md","hash":"72272889c8c1e8f3ec28a71d8ee94af2db7bfb78","modified":1627056987983},{"_id":"source/_posts/algorithm/分布式算法/分布式raft算法.md","hash":"5321b54bbca907a1c8247aa5d286a31a1f557e88","modified":1627056987983},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"580b1e9bd356ed6781c32ccc49c6fa3486b94620","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"16513ab1745533d0f4cdbdee323339ebab6d02c1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"37f2f2efcb102c706e2460dc9cdeaa302366d318","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":499162500000}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"# 分类","source":"_posts/nav/kind.md","raw":"# 分类","slug":"nav/kind","published":1,"date":"2021-07-23T16:16:27.984Z","updated":"2021-07-23T16:16:27.984Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04nr0000pduk17wd5e52","content":"<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1>"},{"_content":"### 简介\n\n本模块为编程语言模块，包含编程语言基础/高级特性/部分软件/框架的源码分析\n\n### 内容\n\n- java\n- c\n- js\n- python\n- shell\n- go\n\n### 备注\n\n知识点大部分来源于网络，如果知识点侵害到您的权益，请及时反馈。\n","source":"_posts/language/readme.md","raw":"### 简介\n\n本模块为编程语言模块，包含编程语言基础/高级特性/部分软件/框架的源码分析\n\n### 内容\n\n- java\n- c\n- js\n- python\n- shell\n- go\n\n### 备注\n\n知识点大部分来源于网络，如果知识点侵害到您的权益，请及时反馈。\n","slug":"language/readme","published":1,"date":"2021-07-23T16:16:27.983Z","updated":"2021-07-23T16:16:27.983Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04nv0001pduk8ffs1jdv","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本模块为编程语言模块，包含编程语言基础/高级特性/部分软件/框架的源码分析</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><ul>\n<li>java</li>\n<li>c</li>\n<li>js</li>\n<li>python</li>\n<li>shell</li>\n<li>go</li>\n</ul>\n<h3 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h3><p>知识点大部分来源于网络，如果知识点侵害到您的权益，请及时反馈。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本模块为编程语言模块，包含编程语言基础/高级特性/部分软件/框架的源码分析</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><ul>\n<li>java</li>\n<li>c</li>\n<li>js</li>\n<li>python</li>\n<li>shell</li>\n<li>go</li>\n</ul>\n<h3 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h3><p>知识点大部分来源于网络，如果知识点侵害到您的权益，请及时反馈。</p>\n"},{"title":"hexo配置详解","_content":"hexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","source":"_posts/tool/hexo-config.md","raw":"---\ntitle: hexo配置详解\n---\nhexo配置详解，包含分类，归档，标题等\n\n```\n# Site\ntitle:  #主页标题\nsubtitle:  #副标题\ndescription: #网站描述description主要用于SEO\nkeywords:  #博客关键字\nauthor: #作者，左下角显示\nlanguage: zh_Hans # 选择中文简体\ntimezone: 'Asia/Shanghai'  #时区:国内选择上海\n# Url\nurl: http://yoursite.com  #填自己的github pages网址 \nroot: /                   #网站根目录\npermalink: :year/:month/:day/:title/        #文章的 永久链接 格式\npermalink_defaults:                         #永久链接中各部分的默认值\npretty_urls:                                #改写 permalink 的值来美化 URL\ntrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除\ntrailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除\n\n# Directory\nsource_dir: source        #资源文件夹，这个文件夹用来存放内容。\npublic_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags             #标签文件夹\narchive_dir: archives     #归档文件夹\ncategory_dir: categories  #分类文件夹\ncode_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录\ni18n_dir: :lang           #国际化（i18n）文件夹\nskip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 \ndefault_layout: post    #预设布局\ntitlecase: false  #把标题转换为 title case\nexternal_link:    #在新标签中打开链接\n  enable: true #在新标签中打开链接\n  field: site #对整个网站（site）生效或仅对文章（post）生效\n  exclude: ''  #需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹\nrelative_link: false  #把链接改为与根目录的相对位址\nfuture: true  #显示未来的文章\nhighlight:\n  enable: true  #开启代码块高亮\n  line_number: true  #显示行数\n  auto_detect: false  #如果未指定语言，则启用自动检测\n  tab_replace: ''  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs\n  wrap: true    # 将代码块包装到<table>\n  hljs: false   # CSS类使用hljs-*前缀\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized  #默认分类\ncategory_map:   #分类别名\ntag_map:   #标签别名\n\n# Metadata elements\nmeta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD  #日期格式\ntime_format: HH:mm:ss   #时间格式\nuse_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10  #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page  #分页目录\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude:  #Hexo 会忽略这些文件和目录\nignore:   #Ignore files/folders\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: icarus #当前主题名称。值为false时禁用主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:   #部署部分的设置\n  type: git\n  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址\n  branch: master\n```","slug":"tool/hexo-config","published":1,"date":"2021-07-23T17:15:03.482Z","updated":"2021-07-23T17:15:03.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04nw0002pduk0sn47lcc","content":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>hexo配置详解，包含分类，归档，标题等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title:  #主页标题</span><br><span class=\"line\">subtitle:  #副标题</span><br><span class=\"line\">description: #网站描述description主要用于SEO</span><br><span class=\"line\">keywords:  #博客关键字</span><br><span class=\"line\">author: #作者，左下角显示</span><br><span class=\"line\">language: zh_Hans # 选择中文简体</span><br><span class=\"line\">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class=\"line\"># Url</span><br><span class=\"line\">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class=\"line\">root: /                   #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class=\"line\">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class=\"line\">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class=\"line\">trailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class=\"line\">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory</span><br><span class=\"line\">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags             #标签文件夹</span><br><span class=\"line\">archive_dir: archives     #归档文件夹</span><br><span class=\"line\">category_dir: categories  #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class=\"line\">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class=\"line\">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing</span><br><span class=\"line\">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class=\"line\">default_layout: post    #预设布局</span><br><span class=\"line\">titlecase: false  #把标题转换为 title case</span><br><span class=\"line\">external_link:    #在新标签中打开链接</span><br><span class=\"line\">  enable: true #在新标签中打开链接</span><br><span class=\"line\">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class=\"line\">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class=\"line\">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class=\"line\">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  #显示未来的文章</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true  #开启代码块高亮</span><br><span class=\"line\">  line_number: true  #显示行数</span><br><span class=\"line\">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class=\"line\">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class=\"line\">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class=\"line\">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class=\"line\"></span><br><span class=\"line\"># Home page setting</span><br><span class=\"line\"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class=\"line\"># order_by: Posts order. (Order by date descending by default)</span><br><span class=\"line\">index_generator:</span><br><span class=\"line\">  path: &#x27;&#x27;</span><br><span class=\"line\">  per_page: 10</span><br><span class=\"line\">  order_by: -date</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag</span><br><span class=\"line\">default_category: uncategorized  #默认分类</span><br><span class=\"line\">category_map:   #分类别名</span><br><span class=\"line\">tag_map:   #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Metadata elements</span><br><span class=\"line\">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD  #日期格式</span><br><span class=\"line\">time_format: HH:mm:ss   #时间格式</span><br><span class=\"line\">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page  #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Include / Exclude file(s)</span><br><span class=\"line\">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class=\"line\">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class=\"line\">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class=\"line\">ignore:   #Ignore files/folders</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:   #部署部分的设置</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>"},{"title":"hexo-安装","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/tool/hexo-install.md","raw":"---\ntitle: hexo-安装\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. \nIf you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"tool/hexo-install","published":1,"date":"2021-07-23T17:15:03.485Z","updated":"2021-07-23T17:15:03.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04nx0003pdukba57http","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info.<br>If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","source":"_posts/algorithm/分布式算法/分布式raft算法.md","raw":"### Raft 算法\n\n#### 一、更加直观的 Raft 算法\n\nRaft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。\n为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。\n\n#### 1.解决什么问题\n\n分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。\n\nRaft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。\n\n![replicated state machine](https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg 'replicated state machine')\n\nRaft 有一个明确的场景，就是管理复制日志的一致性。\n\n如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。\n一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。\n\n![state machine](https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg 'state machine')\n\n#### 2.Raft 概览\n\n先看一段动画演示，[Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/) 。\n\n相比 Paxos，Raft 算法理解起来直观的很。\n\nRaft 算法将 Server 划分为 3 种状态，或者也可以称作角色：\n\n- Leader\n\n负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。\n\n- Follower\n\n被动响应请求 RPC，从不主动发起请求 RPC。\n\n- Candidate\n\n一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower\n\n状态或者说角色的流转如下：\n\n![state](https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png 'state')\n\n在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。\n\n复制状态机通过复制日志来实现：\n\n- 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令\n- 状态机：状态机会按顺序执行这些命令\n- 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的\n\n###\n\n## 二、Raft 算法流程\n\nRaft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。\n\n### 1.Term\n\nTerm 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。\n\n任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n\n### 2.RPC\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。\n\nRPC 有三种：\n\n- RequestVote RPC：候选人在选举期间发起\n- AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成\n- InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者\n\n### 3.选举流程\n\n（1）follower 增加当前的 term，转变为 candidate。\n（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。\n（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png)\n\n![](https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png)\n\ncandidate 节点保持（2）的状态，直到下面三种情况中的一种发生。\n\n- 该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。\n- 另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。\n- 一段时间后依然没有胜者。该种情况下会开启新一轮的选举。\n\nRaft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。\n\n### 4.日志复制\n\n日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。\n\n当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。\n\n在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。\n\n## 三、Raft 和 Paxos 的工程应用\n\nRaft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。\n\n可以看到 Raft 算法的实现已经非常多了，[https://raft.github.io//#implementations](https://raft.github.io/#implementations)\n\n### 1.Raft 的应用\n\n这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。\nEtcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。\n更多 Etcd 的应用可以查看文档：[https://coreos.com/etcd/docs/latest/](https://coreos.com/etcd/docs/latest/)\n\n### 2.Zookeeper 中的 Paxos\n\nZookeeper 使用了一种修改后的 Paxos 协议。\n\n在 Zookeeper 中，始终分为两种场景:\n\n- Leader activation\n\n在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。\n\n- Active messaging\n  在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。\n\n在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。\n\n无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。\n\nZookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。\n\n### 3.如何解决 split brain 问题\n\n分布式协议一个著名问题就是 split brain 问题。\n\n简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。\n\n区块链的分叉其实类似分布式系统的 split brain。\n\n一般来说，Zookeeper 会默认设置：\n\n- zookeeper cluster 的节点数目必须是奇数。\n- zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。\n\nMajority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。\n\n## 四、从 CAP 的角度理解几种不同的算法\n\n### 1.两阶段提交协议\n\n两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。\n首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。\n\n### 2.Paxos 和 Raft 算法\n\nPaxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。\n\n参考\n[Raft 一致性算法](https://blog.csdn.net/cszhouwei/article/details/38374603)\n[Raft 一致性算法论文译文](http://www.infoq.com/cn/articles/raft-paper)\n","slug":"algorithm/分布式算法/分布式raft算法","published":1,"date":"2021-07-23T16:16:27.983Z","updated":"2021-07-23T16:16:27.983Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04nx0004pdukec9s7a7t","content":"<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Raft-算法\"><a href=\"#Raft-算法\" class=\"headerlink\" title=\"Raft 算法\"></a>Raft 算法</h3><h4 id=\"一、更加直观的-Raft-算法\"><a href=\"#一、更加直观的-Raft-算法\" class=\"headerlink\" title=\"一、更加直观的 Raft 算法\"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p>\n<h4 id=\"1-解决什么问题\"><a href=\"#1-解决什么问题\" class=\"headerlink\" title=\"1.解决什么问题\"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p>\n<p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg\" alt=\"replicated state machine\" title=\"replicated state machine\"></p>\n<p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p>\n<p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg\" alt=\"state machine\" title=\"state machine\"></p>\n<h4 id=\"2-Raft-概览\"><a href=\"#2-Raft-概览\" class=\"headerlink\" title=\"2.Raft 概览\"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href=\"http://thesecretlivesofdata.com/raft/\">Understandable Distributed Consensus</a> 。</p>\n<p>相比 Paxos，Raft 算法理解起来直观的很。</p>\n<p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p>\n<ul>\n<li>Leader</li>\n</ul>\n<p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p>\n<ul>\n<li>Follower</li>\n</ul>\n<p>被动响应请求 RPC，从不主动发起请求 RPC。</p>\n<ul>\n<li>Candidate</li>\n</ul>\n<p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p>\n<p>状态或者说角色的流转如下：</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png\" alt=\"state\" title=\"state\"></p>\n<p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p>\n<p>复制状态机通过复制日志来实现：</p>\n<ul>\n<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>\n<li>状态机：状态机会按顺序执行这些命令</li>\n<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"二、Raft-算法流程\"><a href=\"#二、Raft-算法流程\" class=\"headerlink\" title=\"二、Raft 算法流程\"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p>\n<h3 id=\"1-Term\"><a href=\"#1-Term\" class=\"headerlink\" title=\"1.Term\"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p>\n<p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p>\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2.RPC\"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p>\n<p>RPC 有三种：</p>\n<ul>\n<li>RequestVote RPC：候选人在选举期间发起</li>\n<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>\n<li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li>\n</ul>\n<h3 id=\"3-选举流程\"><a href=\"#3-选举流程\" class=\"headerlink\" title=\"3.选举流程\"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png\"></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png\"></p>\n<p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p>\n<ul>\n<li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li>\n<li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li>\n<li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li>\n</ul>\n<p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p>\n<h3 id=\"4-日志复制\"><a href=\"#4-日志复制\" class=\"headerlink\" title=\"4.日志复制\"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>\n<p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p>\n<p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p>\n<h2 id=\"三、Raft-和-Paxos-的工程应用\"><a href=\"#三、Raft-和-Paxos-的工程应用\" class=\"headerlink\" title=\"三、Raft 和 Paxos 的工程应用\"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p>\n<p>可以看到 Raft 算法的实现已经非常多了，<a href=\"https://raft.github.io/#implementations\">https://raft.github.io//#implementations</a></p>\n<h3 id=\"1-Raft-的应用\"><a href=\"#1-Raft-的应用\" class=\"headerlink\" title=\"1.Raft 的应用\"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href=\"https://coreos.com/etcd/docs/latest/\">https://coreos.com/etcd/docs/latest/</a></p>\n<h3 id=\"2-Zookeeper-中的-Paxos\"><a href=\"#2-Zookeeper-中的-Paxos\" class=\"headerlink\" title=\"2.Zookeeper 中的 Paxos\"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p>\n<p>在 Zookeeper 中，始终分为两种场景:</p>\n<ul>\n<li>Leader activation</li>\n</ul>\n<p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p>\n<ul>\n<li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li>\n</ul>\n<p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p>\n<p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p>\n<p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p>\n<h3 id=\"3-如何解决-split-brain-问题\"><a href=\"#3-如何解决-split-brain-问题\" class=\"headerlink\" title=\"3.如何解决 split brain 问题\"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p>\n<p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p>\n<p>区块链的分叉其实类似分布式系统的 split brain。</p>\n<p>一般来说，Zookeeper 会默认设置：</p>\n<ul>\n<li>zookeeper cluster 的节点数目必须是奇数。</li>\n<li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>\n</ul>\n<p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p>\n<h2 id=\"四、从-CAP-的角度理解几种不同的算法\"><a href=\"#四、从-CAP-的角度理解几种不同的算法\" class=\"headerlink\" title=\"四、从 CAP 的角度理解几种不同的算法\"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id=\"1-两阶段提交协议\"><a href=\"#1-两阶段提交协议\" class=\"headerlink\" title=\"1.两阶段提交协议\"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p>\n<h3 id=\"2-Paxos-和-Raft-算法\"><a href=\"#2-Paxos-和-Raft-算法\" class=\"headerlink\" title=\"2.Paxos 和 Raft 算法\"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p>\n<p>参考<br><a href=\"https://blog.csdn.net/cszhouwei/article/details/38374603\">Raft 一致性算法</a><br><a href=\"http://www.infoq.com/cn/articles/raft-paper\">Raft 一致性算法论文译文</a></p>\n"},{"_content":"# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","source":"_posts/language/java/深入理解单例模式-静态内部类单例原理.md","raw":"# 深入理解单例模式：静态内部类单例原理\n\n本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。\n\n## 1.单例原则\n\n首先我们要先了解下单例的四大原则：\n\n- 1.构造私有。\n- 2.以静态方法或者枚举返回实例。\n- 3.确保实例只有一个，尤其是多线程环境。\n- 4.确保反序列换时不会重新构建对象。\n\n## 2.常用的单例模式：\n\n饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。\n\n### 2.1.饿汉模式：\n\n饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。\n参考如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = new SingleTon();\n    private SingleTon(){}\n    public static SingleTon getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n### 2.2.懒汉模式：\n\n懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。\n参考如下\n\n```\npublic class SingleTon{\n    private static SingleTon  INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance() {\n        if(INSTANCE == null){\n            INSTANCE = new SingleTon();\n        }\n        return INSTANCE；\n    }\n}\n```\n\n### 2.3.双重锁懒汉模式(Double Check Lock)\n\nDCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，\n当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。\n但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：\n\n```\npublic class SingleTon{\n    private static SingleTon INSTANCE = null;\n    private SingleTon(){}\n    public static SingleTon getInstance(){if(INSTANCE == null){\n        synchronized(SingleTon.class){\n            if(INSTANCE == null){\n                INSTANCE = new SingleTon();\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\nINSTANCE = new SingleTon();\n这个步骤，其实在 jvm 里面的执行分为三步：\n\n- 1.在堆内存开辟内存空间。\n- 2.在堆内存中实例化 SingleTon 里面的各个参数。\n- 3.把对象指向堆内存空间。\n\n由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，\nINSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。\n\n不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为\n\n```\nprivate volatile static SingleTon INSTANCE = null;\n```\n\n就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。\n\n### 2.4.静态内部类模式：\n\n静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。\n即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，\n才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，\n这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n```\npublic class SingleTon{\n    private SingleTon(){}\n\n    private static class SingleTonHoler{\n        private static SingleTon INSTANCE = new SingleTon();\n    }\n\n    public static SingleTon getInstance(){\n        return SingleTonHoler.INSTANCE;\n    }\n}\n```\n\n那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。\n类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。\n\n- 1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：\n  new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n- 2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n- 3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n- 4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。\n- 5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、\n  REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n\n这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，\n那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，\n跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，\n取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，\n把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:\n\n虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，\n如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，\n直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，\n就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，\n其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n\n故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，\n由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。\n\n### 2.5.枚举类型单例模式\n\n```\n//枚举单例：\npublic enum SingleTon{\n    INSTANCE;\n    public void method(){\n    //TODO\n    }\n}\n```\n\n枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以\nSingleTon.INSTANCE 的方式调用。\n\n## 参考\n\nhttps://blog.csdn.net/mnb65482/article/details/80458571\n《深入理解 JAVA 虚拟机》\n《Android 源码设计模式解析与实战》\n《java 虚拟机规范》\n","slug":"language/java/深入理解单例模式-静态内部类单例原理","published":1,"date":"2021-07-23T16:16:27.983Z","updated":"2021-07-23T16:16:27.983Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrgn04ny0005pdukb8pkb1e5","content":"<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"深入理解单例模式：静态内部类单例原理\"><a href=\"#深入理解单例模式：静态内部类单例原理\" class=\"headerlink\" title=\"深入理解单例模式：静态内部类单例原理\"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p>\n<h2 id=\"1-单例原则\"><a href=\"#1-单例原则\" class=\"headerlink\" title=\"1.单例原则\"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p>\n<ul>\n<li>1.构造私有。</li>\n<li>2.以静态方法或者枚举返回实例。</li>\n<li>3.确保实例只有一个，尤其是多线程环境。</li>\n<li>4.确保反序列换时不会重新构建对象。</li>\n</ul>\n<h2 id=\"2-常用的单例模式：\"><a href=\"#2-常用的单例模式：\" class=\"headerlink\" title=\"2.常用的单例模式：\"></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p>\n<h3 id=\"2-1-饿汉模式：\"><a href=\"#2-1-饿汉模式：\" class=\"headerlink\" title=\"2.1.饿汉模式：\"></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-懒汉模式：\"><a href=\"#2-2-懒汉模式：\" class=\"headerlink\" title=\"2.2.懒汉模式：\"></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon  INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance() &#123;</span><br><span class=\"line\">        if(INSTANCE == null)&#123;</span><br><span class=\"line\">            INSTANCE = new SingleTon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-双重锁懒汉模式-Double-Check-Lock\"><a href=\"#2-3-双重锁懒汉模式-Double-Check-Lock\" class=\"headerlink\" title=\"2.3.双重锁懒汉模式(Double Check Lock)\"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private static SingleTon INSTANCE = null;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class=\"line\">        synchronized(SingleTon.class)&#123;</span><br><span class=\"line\">            if(INSTANCE == null)&#123;</span><br><span class=\"line\">                INSTANCE = new SingleTon();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p>\n<ul>\n<li>1.在堆内存开辟内存空间。</li>\n<li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li>\n<li>3.把对象指向堆内存空间。</li>\n</ul>\n<p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p>\n<p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure>\n\n<p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p>\n<h3 id=\"2-4-静态内部类模式：\"><a href=\"#2-4-静态内部类模式：\" class=\"headerlink\" title=\"2.4.静态内部类模式：\"></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingleTon&#123;</span><br><span class=\"line\">    private SingleTon()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingleTonHoler&#123;</span><br><span class=\"line\">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingleTon getInstance()&#123;</span><br><span class=\"line\">        return SingleTonHoler.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p>\n<ul>\n<li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li>\n<li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li>\n<li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li>\n<li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li>\n<li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n</ul>\n<p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p>\n<h3 id=\"2-5-枚举类型单例模式\"><a href=\"#2-5-枚举类型单例模式\" class=\"headerlink\" title=\"2.5.枚举类型单例模式\"></a>2.5.枚举类型单例模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//枚举单例：</span><br><span class=\"line\">public enum SingleTon&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    public void method()&#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/mnb65482/article/details/80458571\">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}